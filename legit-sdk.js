// legit-sdk library bundle
// Generated by esbuild

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    function assertPath(path6) {
      if (typeof path6 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path6));
      }
    }
    __name(assertPath, "assertPath");
    function normalizeStringPosix(path6, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path6.length; ++i) {
        if (i < path6.length)
          code = path6.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path6.slice(lastSlash + 1, i);
            else
              res = path6.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    __name(normalizeStringPosix, "normalizeStringPosix");
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    __name(_format, "_format");
    var posix = {
      // path.resolve([from ...], to)
      resolve: /* @__PURE__ */ __name(function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path6;
          if (i >= 0)
            path6 = arguments[i];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path6 = cwd;
          }
          assertPath(path6);
          if (path6.length === 0) {
            continue;
          }
          resolvedPath = path6 + "/" + resolvedPath;
          resolvedAbsolute = path6.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      }, "resolve"),
      normalize: /* @__PURE__ */ __name(function normalize(path6) {
        assertPath(path6);
        if (path6.length === 0) return ".";
        var isAbsolute = path6.charCodeAt(0) === 47;
        var trailingSeparator = path6.charCodeAt(path6.length - 1) === 47;
        path6 = normalizeStringPosix(path6, !isAbsolute);
        if (path6.length === 0 && !isAbsolute) path6 = ".";
        if (path6.length > 0 && trailingSeparator) path6 += "/";
        if (isAbsolute) return "/" + path6;
        return path6;
      }, "normalize"),
      isAbsolute: /* @__PURE__ */ __name(function isAbsolute(path6) {
        assertPath(path6);
        return path6.length > 0 && path6.charCodeAt(0) === 47;
      }, "isAbsolute"),
      join: /* @__PURE__ */ __name(function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      }, "join"),
      relative: /* @__PURE__ */ __name(function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      }, "relative"),
      _makeLong: /* @__PURE__ */ __name(function _makeLong(path6) {
        return path6;
      }, "_makeLong"),
      dirname: /* @__PURE__ */ __name(function dirname5(path6) {
        assertPath(path6);
        if (path6.length === 0) return ".";
        var code = path6.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path6.length - 1; i >= 1; --i) {
          code = path6.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path6.slice(0, end);
      }, "dirname"),
      basename: /* @__PURE__ */ __name(function basename2(path6, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path6);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
          if (ext.length === path6.length && ext === path6) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path6.length - 1; i >= 0; --i) {
            var code = path6.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path6.length;
          return path6.slice(start, end);
        } else {
          for (i = path6.length - 1; i >= 0; --i) {
            if (path6.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) return "";
          return path6.slice(start, end);
        }
      }, "basename"),
      extname: /* @__PURE__ */ __name(function extname(path6) {
        assertPath(path6);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path6.length - 1; i >= 0; --i) {
          var code = path6.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path6.slice(startDot, end);
      }, "extname"),
      format: /* @__PURE__ */ __name(function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      }, "format"),
      parse: /* @__PURE__ */ __name(function parse(path6) {
        assertPath(path6);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path6.length === 0) return ret;
        var code = path6.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path6.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path6.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path6.slice(1, end);
            else ret.base = ret.name = path6.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path6.slice(1, startDot);
            ret.base = path6.slice(1, end);
          } else {
            ret.name = path6.slice(startPart, startDot);
            ret.base = path6.slice(startPart, end);
          }
          ret.ext = path6.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path6.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      }, "parse"),
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module.exports = posix;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.constants = exports.SEP = void 0;
    exports.SEP = "/";
    exports.constants = {
      O_RDONLY: 0,
      O_WRONLY: 1,
      O_RDWR: 2,
      S_IFMT: 61440,
      S_IFREG: 32768,
      S_IFDIR: 16384,
      S_IFCHR: 8192,
      S_IFBLK: 24576,
      S_IFIFO: 4096,
      S_IFLNK: 40960,
      S_IFSOCK: 49152,
      O_CREAT: 64,
      O_EXCL: 128,
      O_NOCTTY: 256,
      O_TRUNC: 512,
      O_APPEND: 1024,
      O_DIRECTORY: 65536,
      O_NOATIME: 262144,
      O_NOFOLLOW: 131072,
      O_SYNC: 1052672,
      O_SYMLINK: 2097152,
      O_DIRECT: 16384,
      O_NONBLOCK: 2048,
      S_IRWXU: 448,
      S_IRUSR: 256,
      S_IWUSR: 128,
      S_IXUSR: 64,
      S_IRWXG: 56,
      S_IRGRP: 32,
      S_IWGRP: 16,
      S_IXGRP: 8,
      S_IRWXO: 7,
      S_IROTH: 4,
      S_IWOTH: 2,
      S_IXOTH: 1,
      F_OK: 0,
      R_OK: 4,
      W_OK: 2,
      X_OK: 1,
      UV_FS_SYMLINK_DIR: 1,
      UV_FS_SYMLINK_JUNCTION: 2,
      UV_FS_COPYFILE_EXCL: 1,
      UV_FS_COPYFILE_FICLONE: 2,
      UV_FS_COPYFILE_FICLONE_FORCE: 4,
      COPYFILE_EXCL: 1,
      COPYFILE_FICLONE: 2,
      COPYFILE_FICLONE_FORCE: 4
    };
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/Stats.js
var require_Stats = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/Stats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Stats = void 0;
    var constants_1 = require_constants();
    var { S_IFMT, S_IFDIR, S_IFREG, S_IFBLK, S_IFCHR, S_IFLNK, S_IFIFO, S_IFSOCK } = constants_1.constants;
    var _Stats = class _Stats {
      static build(node, bigint = false) {
        const stats = new _Stats();
        const { uid, gid, atime, mtime, ctime } = node;
        const getStatNumber = !bigint ? (number) => number : (number) => BigInt(number);
        stats.uid = getStatNumber(uid);
        stats.gid = getStatNumber(gid);
        stats.rdev = getStatNumber(node.rdev);
        stats.blksize = getStatNumber(4096);
        stats.ino = getStatNumber(node.ino);
        stats.size = getStatNumber(node.getSize());
        stats.blocks = getStatNumber(1);
        stats.atime = atime;
        stats.mtime = mtime;
        stats.ctime = ctime;
        stats.birthtime = ctime;
        stats.atimeMs = getStatNumber(atime.getTime());
        stats.mtimeMs = getStatNumber(mtime.getTime());
        const ctimeMs = getStatNumber(ctime.getTime());
        stats.ctimeMs = ctimeMs;
        stats.birthtimeMs = ctimeMs;
        if (bigint) {
          stats.atimeNs = BigInt(atime.getTime()) * BigInt(1e6);
          stats.mtimeNs = BigInt(mtime.getTime()) * BigInt(1e6);
          const ctimeNs = BigInt(ctime.getTime()) * BigInt(1e6);
          stats.ctimeNs = ctimeNs;
          stats.birthtimeNs = ctimeNs;
        }
        stats.dev = getStatNumber(0);
        stats.mode = getStatNumber(node.mode);
        stats.nlink = getStatNumber(node.nlink);
        return stats;
      }
      _checkModeProperty(property) {
        return (Number(this.mode) & S_IFMT) === property;
      }
      isDirectory() {
        return this._checkModeProperty(S_IFDIR);
      }
      isFile() {
        return this._checkModeProperty(S_IFREG);
      }
      isBlockDevice() {
        return this._checkModeProperty(S_IFBLK);
      }
      isCharacterDevice() {
        return this._checkModeProperty(S_IFCHR);
      }
      isSymbolicLink() {
        return this._checkModeProperty(S_IFLNK);
      }
      isFIFO() {
        return this._checkModeProperty(S_IFIFO);
      }
      isSocket() {
        return this._checkModeProperty(S_IFSOCK);
      }
    };
    __name(_Stats, "Stats");
    var Stats = _Stats;
    exports.Stats = Stats;
    exports.default = Stats;
  }
});

// ../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    __name(getLens, "getLens");
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(byteLength, "byteLength");
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(_byteLength, "_byteLength");
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    __name(toByteArray, "toByteArray");
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    __name(tripletToBase64, "tripletToBase64");
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    __name(encodeChunk, "encodeChunk");
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    __name(fromByteArray, "fromByteArray");
  }
});

// ../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// ../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: /* @__PURE__ */ __name(function() {
          return 42;
        }, "foo") };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    __name(typedArraySupport, "typedArraySupport");
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }, "get")
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }, "get")
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    __name(createBuffer, "createBuffer");
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    __name(Buffer3, "Buffer");
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    __name(from, "from");
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    __name(assertSize, "assertSize");
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    __name(alloc, "alloc");
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    __name(allocUnsafe, "allocUnsafe");
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    __name(fromString, "fromString");
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    __name(fromArrayLike, "fromArrayLike");
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    __name(fromArrayView, "fromArrayView");
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    __name(fromObject, "fromObject");
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    __name(checked, "checked");
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    __name(SlowBuffer, "SlowBuffer");
    Buffer3.isBuffer = /* @__PURE__ */ __name(function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    }, "isBuffer");
    Buffer3.compare = /* @__PURE__ */ __name(function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }, "compare");
    Buffer3.isEncoding = /* @__PURE__ */ __name(function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, "isEncoding");
    Buffer3.concat = /* @__PURE__ */ __name(function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    }, "concat");
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(byteLength, "byteLength");
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(slowToString, "slowToString");
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    __name(swap, "swap");
    Buffer3.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    }, "swap16");
    Buffer3.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    }, "swap32");
    Buffer3.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    }, "swap64");
    Buffer3.prototype.toString = /* @__PURE__ */ __name(function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    }, "toString");
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = /* @__PURE__ */ __name(function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    }, "equals");
    Buffer3.prototype.inspect = /* @__PURE__ */ __name(function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    }, "inspect");
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = /* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }, "compare");
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    __name(bidirectionalIndexOf, "bidirectionalIndexOf");
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      __name(read, "read");
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    __name(arrayIndexOf, "arrayIndexOf");
    Buffer3.prototype.includes = /* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    }, "includes");
    Buffer3.prototype.indexOf = /* @__PURE__ */ __name(function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    }, "indexOf");
    Buffer3.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    }, "lastIndexOf");
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    __name(hexWrite, "hexWrite");
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(utf8Write, "utf8Write");
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    __name(asciiWrite, "asciiWrite");
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    __name(base64Write, "base64Write");
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(ucs2Write, "ucs2Write");
    Buffer3.prototype.write = /* @__PURE__ */ __name(function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }, "write");
    Buffer3.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    }, "toJSON");
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    __name(base64Slice, "base64Slice");
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    __name(utf8Slice, "utf8Slice");
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    __name(decodeCodePointsArray, "decodeCodePointsArray");
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    __name(asciiSlice, "asciiSlice");
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    __name(latin1Slice, "latin1Slice");
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    __name(hexSlice, "hexSlice");
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    __name(utf16leSlice, "utf16leSlice");
    Buffer3.prototype.slice = /* @__PURE__ */ __name(function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    }, "slice");
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    __name(checkOffset, "checkOffset");
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    }, "readUIntLE");
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    }, "readUIntBE");
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    }, "readUInt8");
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    }, "readUInt16LE");
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    }, "readUInt16BE");
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    }, "readUInt32LE");
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    }, "readUInt32BE");
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    }, "readBigUInt64LE"));
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    }, "readBigUInt64BE"));
    Buffer3.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    }, "readIntLE");
    Buffer3.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    }, "readIntBE");
    Buffer3.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    }, "readInt8");
    Buffer3.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16LE");
    Buffer3.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16BE");
    Buffer3.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    }, "readInt32LE");
    Buffer3.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    }, "readInt32BE");
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    }, "readBigInt64LE"));
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    }, "readBigInt64BE"));
    Buffer3.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    }, "readFloatLE");
    Buffer3.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    }, "readFloatBE");
    Buffer3.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    }, "readDoubleLE");
    Buffer3.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    }, "readDoubleBE");
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    __name(checkInt, "checkInt");
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    }, "writeUIntLE");
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    }, "writeUIntBE");
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    }, "writeUInt8");
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeUInt16LE");
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeUInt16BE");
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    }, "writeUInt32LE");
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeUInt32BE");
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    __name(wrtBigUInt64LE, "wrtBigUInt64LE");
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    __name(wrtBigUInt64BE, "wrtBigUInt64BE");
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64LE"));
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64BE"));
    Buffer3.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    }, "writeIntLE");
    Buffer3.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    }, "writeIntBE");
    Buffer3.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    }, "writeInt8");
    Buffer3.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeInt16LE");
    Buffer3.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeInt16BE");
    Buffer3.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    }, "writeInt32LE");
    Buffer3.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeInt32BE");
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64LE"));
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64BE"));
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    __name(checkIEEE754, "checkIEEE754");
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    __name(writeFloat, "writeFloat");
    Buffer3.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    }, "writeFloatLE");
    Buffer3.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    }, "writeFloatBE");
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    __name(writeDouble, "writeDouble");
    Buffer3.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    }, "writeDoubleLE");
    Buffer3.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }, "writeDoubleBE");
    Buffer3.prototype.copy = /* @__PURE__ */ __name(function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    }, "copy");
    Buffer3.prototype.fill = /* @__PURE__ */ __name(function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    }, "fill");
    var errors = {};
    function E(sym, getMessage, Base) {
      var _a;
      errors[sym] = (_a = class extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      }, __name(_a, "NodeError"), _a);
    }
    __name(E, "E");
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    __name(addNumericalSeparator, "addNumericalSeparator");
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    __name(checkBounds, "checkBounds");
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    __name(checkIntBI, "checkIntBI");
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    __name(validateNumber, "validateNumber");
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    __name(boundsError, "boundsError");
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    __name(base64clean, "base64clean");
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    __name(utf8ToBytes, "utf8ToBytes");
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    __name(asciiToBytes, "asciiToBytes");
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    __name(utf16leToBytes, "utf16leToBytes");
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    __name(base64ToBytes, "base64ToBytes");
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    __name(blitBuffer, "blitBuffer");
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    __name(isInstance, "isInstance");
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    __name(numberIsNaN, "numberIsNaN");
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    __name(defineBigIntMethod, "defineBigIntMethod");
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    __name(BufferBigIntNotDefined, "BufferBigIntNotDefined");
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/buffer.js
var require_buffer2 = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Buffer = void 0;
    var node_buffer_1 = require_buffer();
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_buffer_1.Buffer;
    }, "get") });
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/internal/buffer.js
var require_buffer3 = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/internal/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferFrom = exports.bufferAllocUnsafe = exports.Buffer = void 0;
    var buffer_1 = require_buffer2();
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return buffer_1.Buffer;
    }, "get") });
    function bufferV0P12Ponyfill(arg0, ...args) {
      return new buffer_1.Buffer(arg0, ...args);
    }
    __name(bufferV0P12Ponyfill, "bufferV0P12Ponyfill");
    var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
    exports.bufferAllocUnsafe = bufferAllocUnsafe;
    var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
    exports.bufferFrom = bufferFrom;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inherits = inherits;
    exports.promisify = promisify;
    exports.inspect = inspect;
    exports.format = format;
    function inherits(ctor, superCtor) {
      if (ctor === void 0 || ctor === null) {
        throw new TypeError("The constructor to inherit from is not defined");
      }
      if (superCtor === void 0 || superCtor === null) {
        throw new TypeError("The super constructor to inherit from is not defined");
      }
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
    __name(inherits, "inherits");
    function promisify(fn) {
      if (typeof fn !== "function") {
        throw new TypeError('The "original" argument must be of type function');
      }
      return function(...args) {
        return new Promise((resolve, reject) => {
          fn.call(this, ...args, (err, result) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        });
      };
    }
    __name(promisify, "promisify");
    function inspect(value) {
      if (value === null)
        return "null";
      if (value === void 0)
        return "undefined";
      if (typeof value === "string")
        return `'${value}'`;
      if (typeof value === "number" || typeof value === "boolean")
        return String(value);
      if (Array.isArray(value)) {
        const items = value.map((item) => inspect(item)).join(", ");
        return `[ ${items} ]`;
      }
      if (typeof value === "object") {
        const entries = Object.entries(value).map(([key, val]) => `${key}: ${inspect(val)}`).join(", ");
        return `{ ${entries} }`;
      }
      return String(value);
    }
    __name(inspect, "inspect");
    function format(template, ...args) {
      if (args.length === 0)
        return template;
      let result = template;
      let argIndex = 0;
      result = result.replace(/%[sdj%]/g, (match) => {
        if (argIndex >= args.length)
          return match;
        const arg = args[argIndex++];
        switch (match) {
          case "%s":
            return String(arg);
          case "%d":
            return Number(arg).toString();
          case "%j":
            try {
              return JSON.stringify(arg);
            } catch {
              return "[Circular]";
            }
          case "%%":
            return "%";
          default:
            return match;
        }
      });
      while (argIndex < args.length) {
        result += " " + String(args[argIndex++]);
      }
      return result;
    }
    __name(format, "format");
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/internal/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/internal/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AssertionError = exports.RangeError = exports.TypeError = exports.Error = void 0;
    exports.message = message;
    exports.E = E;
    var util_1 = require_util();
    var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
    var messages = {};
    function makeNodeError(Base) {
      var _a;
      return _a = class extends Base {
        constructor(key, ...args) {
          super(message(key, args));
          this.code = key;
          this[kCode] = key;
          this.name = `${super.name} [${this[kCode]}]`;
        }
      }, __name(_a, "NodeError"), _a;
    }
    __name(makeNodeError, "makeNodeError");
    var g = typeof globalThis !== "undefined" ? globalThis : globalThis;
    var _AssertionError = class _AssertionError extends g.Error {
      constructor(options) {
        if (typeof options !== "object" || options === null) {
          throw new exports.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
        }
        if (options.message) {
          super(options.message);
        } else {
          super(`${(0, util_1.inspect)(options.actual).slice(0, 128)} ${options.operator} ${(0, util_1.inspect)(options.expected).slice(0, 128)}`);
        }
        this.generatedMessage = !options.message;
        this.name = "AssertionError [ERR_ASSERTION]";
        this.code = "ERR_ASSERTION";
        this.actual = options.actual;
        this.expected = options.expected;
        this.operator = options.operator;
        exports.Error.captureStackTrace(this, options.stackStartFunction);
      }
    };
    __name(_AssertionError, "AssertionError");
    var AssertionError = _AssertionError;
    exports.AssertionError = AssertionError;
    function message(key, args) {
      if (typeof key !== "string")
        throw new exports.Error("Error message key must be a string");
      const msg = messages[key];
      if (!msg)
        throw new exports.Error(`An invalid error message key was used: ${key}.`);
      let fmt;
      if (typeof msg === "function") {
        fmt = msg;
      } else {
        fmt = util_1.format;
        if (args === void 0 || args.length === 0)
          return msg;
        args.unshift(msg);
      }
      return String(fmt.apply(null, args));
    }
    __name(message, "message");
    function E(sym, val) {
      messages[sym] = typeof val === "function" ? val : String(val);
    }
    __name(E, "E");
    exports.Error = makeNodeError(g.Error);
    exports.TypeError = makeNodeError(g.TypeError);
    exports.RangeError = makeNodeError(g.RangeError);
    E("ERR_DIR_CLOSED", "Directory handle was closed");
    E("ERR_DIR_CONCURRENT_OPERATION", "Cannot do synchronous work on directory handle with concurrent asynchronous operations");
    E("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
    E("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
    E("ERR_INVALID_OPT_VALUE", (name, value) => {
      return `The value "${String(value)}" is invalid for option "${name}"`;
    });
    E("ERR_INVALID_OPT_VALUE_ENCODING", (value) => `The value "${String(value)}" is invalid for option "encoding"`);
    E("ERR_INVALID_ARG_VALUE", "Unable to open file as blob");
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/encoding.js
var require_encoding = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ENCODING_UTF8 = void 0;
    exports.assertEncoding = assertEncoding;
    exports.strToEncoding = strToEncoding;
    var buffer_1 = require_buffer3();
    var errors = require_errors();
    exports.ENCODING_UTF8 = "utf8";
    function assertEncoding(encoding) {
      if (encoding && !buffer_1.Buffer.isEncoding(encoding))
        throw new errors.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
    }
    __name(assertEncoding, "assertEncoding");
    function strToEncoding(str, encoding) {
      if (!encoding || encoding === exports.ENCODING_UTF8)
        return str;
      if (encoding === "buffer")
        return new buffer_1.Buffer(str);
      return new buffer_1.Buffer(str).toString(encoding);
    }
    __name(strToEncoding, "strToEncoding");
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/Dirent.js
var require_Dirent = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/Dirent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dirent = void 0;
    var constants_1 = require_constants();
    var encoding_1 = require_encoding();
    var { S_IFMT, S_IFDIR, S_IFREG, S_IFBLK, S_IFCHR, S_IFLNK, S_IFIFO, S_IFSOCK } = constants_1.constants;
    var _Dirent = class _Dirent {
      constructor() {
        this.name = "";
        this.path = "";
        this.parentPath = "";
        this.mode = 0;
      }
      static build(link, encoding) {
        const dirent = new _Dirent();
        const { mode } = link.getNode();
        dirent.name = (0, encoding_1.strToEncoding)(link.getName(), encoding);
        dirent.mode = mode;
        dirent.path = link.getParentPath();
        dirent.parentPath = dirent.path;
        return dirent;
      }
      _checkModeProperty(property) {
        return (this.mode & S_IFMT) === property;
      }
      isDirectory() {
        return this._checkModeProperty(S_IFDIR);
      }
      isFile() {
        return this._checkModeProperty(S_IFREG);
      }
      isBlockDevice() {
        return this._checkModeProperty(S_IFBLK);
      }
      isCharacterDevice() {
        return this._checkModeProperty(S_IFCHR);
      }
      isSymbolicLink() {
        return this._checkModeProperty(S_IFLNK);
      }
      isFIFO() {
        return this._checkModeProperty(S_IFIFO);
      }
      isSocket() {
        return this._checkModeProperty(S_IFSOCK);
      }
    };
    __name(_Dirent, "Dirent");
    var Dirent = _Dirent;
    exports.Dirent = Dirent;
    exports.default = Dirent;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/path.js
var require_path = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.basename = exports.isAbsolute = exports.normalize = exports.dirname = exports.relative = exports.join = exports.posix = exports.sep = exports.resolve = void 0;
    var node_path_1 = require_path_browserify();
    Object.defineProperty(exports, "resolve", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_path_1.resolve;
    }, "get") });
    Object.defineProperty(exports, "sep", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_path_1.sep;
    }, "get") });
    Object.defineProperty(exports, "posix", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_path_1.posix;
    }, "get") });
    Object.defineProperty(exports, "join", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_path_1.join;
    }, "get") });
    Object.defineProperty(exports, "relative", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_path_1.relative;
    }, "get") });
    Object.defineProperty(exports, "dirname", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_path_1.dirname;
    }, "get") });
    Object.defineProperty(exports, "normalize", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_path_1.normalize;
    }, "get") });
    Object.defineProperty(exports, "isAbsolute", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_path_1.isAbsolute;
    }, "get") });
    Object.defineProperty(exports, "basename", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_path_1.basename;
    }, "get") });
  }
});

// ../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  __name(__, "__");
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, "sent"), trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  __name(verb, "verb");
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
  __name(step, "step");
}
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: /* @__PURE__ */ __name(function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }, "next")
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  __name(awaitReturn, "awaitReturn");
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  __name(verb, "verb");
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  __name(resume, "resume");
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  __name(step, "step");
  function fulfill(value) {
    resume("next", value);
  }
  __name(fulfill, "fulfill");
  function reject(value) {
    resume("throw", value);
  }
  __name(reject, "reject");
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
  __name(settle, "settle");
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
  __name(verb, "verb");
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  __name(verb, "verb");
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
  __name(settle, "settle");
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = /* @__PURE__ */ __name(function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    }, "dispose");
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  __name(fail, "fail");
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  __name(next, "next");
  return next();
}
function __rewriteRelativeImportExtension(path6, preserveJsx) {
  if (typeof path6 === "string" && /^\.\.?\//.test(path6)) {
    return path6.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path6;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = /* @__PURE__ */ __name(function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    }, "extendStatics");
    __name(__extends, "__extends");
    __assign = /* @__PURE__ */ __name(function() {
      __assign = Object.assign || /* @__PURE__ */ __name(function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      }, "__assign");
      return __assign.apply(this, arguments);
    }, "__assign");
    __name(__rest, "__rest");
    __name(__decorate, "__decorate");
    __name(__param, "__param");
    __name(__esDecorate, "__esDecorate");
    __name(__runInitializers, "__runInitializers");
    __name(__propKey, "__propKey");
    __name(__setFunctionName, "__setFunctionName");
    __name(__metadata, "__metadata");
    __name(__awaiter, "__awaiter");
    __name(__generator, "__generator");
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    };
    __name(__exportStar, "__exportStar");
    __name(__values, "__values");
    __name(__read, "__read");
    __name(__spread, "__spread");
    __name(__spreadArrays, "__spreadArrays");
    __name(__spreadArray, "__spreadArray");
    __name(__await, "__await");
    __name(__asyncGenerator, "__asyncGenerator");
    __name(__asyncDelegator, "__asyncDelegator");
    __name(__asyncValues, "__asyncValues");
    __name(__makeTemplateObject, "__makeTemplateObject");
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    ownKeys = /* @__PURE__ */ __name(function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    }, "ownKeys");
    __name(__importStar, "__importStar");
    __name(__importDefault, "__importDefault");
    __name(__classPrivateFieldGet, "__classPrivateFieldGet");
    __name(__classPrivateFieldSet, "__classPrivateFieldSet");
    __name(__classPrivateFieldIn, "__classPrivateFieldIn");
    __name(__addDisposableResource, "__addDisposableResource");
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __name(__disposeResources, "__disposeResources");
    __name(__rewriteRelativeImportExtension, "__rewriteRelativeImportExtension");
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/json.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flattenJSON = void 0;
    var buffer_1 = require_buffer3();
    var path_1 = require_path();
    var pathJoin = path_1.posix ? path_1.posix.join : path_1.join;
    var flattenJSON = /* @__PURE__ */ __name((nestedJSON) => {
      const flatJSON = {};
      function flatten(pathPrefix, node) {
        for (const path6 in node) {
          const contentOrNode = node[path6];
          const joinedPath = pathJoin(pathPrefix, path6);
          if (typeof contentOrNode === "string" || contentOrNode instanceof buffer_1.Buffer) {
            flatJSON[joinedPath] = contentOrNode;
          } else if (typeof contentOrNode === "object" && contentOrNode !== null && !(contentOrNode instanceof buffer_1.Buffer) && Object.keys(contentOrNode).length > 0) {
            flatten(joinedPath, contentOrNode);
          } else {
            flatJSON[joinedPath] = null;
          }
        }
      }
      __name(flatten, "flatten");
      flatten("", nestedJSON);
      return flatJSON;
    }, "flattenJSON");
    exports.flattenJSON = flattenJSON;
  }
});

// ../../node_modules/.pnpm/thingies@2.5.0_tslib@2.8.1/node_modules/thingies/lib/fanout.js
var require_fanout = __commonJS({
  "../../node_modules/.pnpm/thingies@2.5.0_tslib@2.8.1/node_modules/thingies/lib/fanout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FanOut = void 0;
    var _FanOut = class _FanOut {
      constructor() {
        this.listeners = /* @__PURE__ */ new Set();
      }
      emit(data) {
        this.listeners.forEach((listener) => listener(data));
      }
      listen(listener) {
        const listeners = this.listeners;
        listeners.add(listener);
        return () => listeners.delete(listener);
      }
    };
    __name(_FanOut, "FanOut");
    var FanOut = _FanOut;
    exports.FanOut = FanOut;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/process.js
var require_process = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/process.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProcess = createProcess;
    var maybeReturnProcess = /* @__PURE__ */ __name(() => {
      if (typeof process !== "undefined") {
        return process;
      }
      try {
        return __require("process");
      } catch {
        return void 0;
      }
    }, "maybeReturnProcess");
    function createProcess() {
      const p = maybeReturnProcess() || {};
      if (!p.cwd)
        p.cwd = () => "/";
      if (!p.emitWarning)
        p.emitWarning = (message, type) => {
          console.warn(`${type}${type ? ": " : ""}${message}`);
        };
      if (!p.env)
        p.env = {};
      return p;
    }
    __name(createProcess, "createProcess");
    exports.default = createProcess();
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/Node.js
var require_Node = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/Node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Node = void 0;
    var fanout_1 = require_fanout();
    var process_1 = require_process();
    var buffer_1 = require_buffer3();
    var constants_1 = require_constants();
    var { S_IFMT, S_IFDIR, S_IFREG, S_IFLNK, S_IFCHR } = constants_1.constants;
    var getuid = /* @__PURE__ */ __name(() => process_1.default.getuid?.() ?? 0, "getuid");
    var getgid = /* @__PURE__ */ __name(() => process_1.default.getgid?.() ?? 0, "getgid");
    var _Node = class _Node {
      constructor(ino, mode = 438) {
        this.changes = new fanout_1.FanOut();
        this._uid = getuid();
        this._gid = getgid();
        this._atime = /* @__PURE__ */ new Date();
        this._mtime = /* @__PURE__ */ new Date();
        this._ctime = /* @__PURE__ */ new Date();
        this.rdev = 0;
        this._nlink = 1;
        this.mode = mode;
        this.ino = ino;
      }
      set ctime(ctime) {
        this._ctime = ctime;
      }
      get ctime() {
        return this._ctime;
      }
      set uid(uid) {
        this._uid = uid;
        this.ctime = /* @__PURE__ */ new Date();
      }
      get uid() {
        return this._uid;
      }
      set gid(gid) {
        this._gid = gid;
        this.ctime = /* @__PURE__ */ new Date();
      }
      get gid() {
        return this._gid;
      }
      set atime(atime) {
        this._atime = atime;
      }
      get atime() {
        return this._atime;
      }
      set mtime(mtime) {
        this._mtime = mtime;
        this.ctime = /* @__PURE__ */ new Date();
      }
      get mtime() {
        return this._mtime;
      }
      get perm() {
        return this.mode & ~S_IFMT;
      }
      set perm(perm) {
        this.mode = this.mode & S_IFMT | perm & ~S_IFMT;
        this.ctime = /* @__PURE__ */ new Date();
      }
      set nlink(nlink) {
        this._nlink = nlink;
        this.ctime = /* @__PURE__ */ new Date();
      }
      get nlink() {
        return this._nlink;
      }
      getString(encoding = "utf8") {
        this.atime = /* @__PURE__ */ new Date();
        return this.getBuffer().toString(encoding);
      }
      setString(str) {
        this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
        this.touch();
      }
      getBuffer() {
        this.atime = /* @__PURE__ */ new Date();
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        return (0, buffer_1.bufferFrom)(this.buf);
      }
      setBuffer(buf) {
        this.buf = (0, buffer_1.bufferFrom)(buf);
        this.touch();
      }
      getSize() {
        return this.buf ? this.buf.length : 0;
      }
      setModeProperty(property) {
        this.mode = property;
      }
      isFile() {
        return (this.mode & S_IFMT) === S_IFREG;
      }
      isDirectory() {
        return (this.mode & S_IFMT) === S_IFDIR;
      }
      isSymlink() {
        return (this.mode & S_IFMT) === S_IFLNK;
      }
      isCharacterDevice() {
        return (this.mode & S_IFMT) === S_IFCHR;
      }
      makeSymlink(symlink) {
        this.mode = S_IFLNK | 438;
        this.symlink = symlink;
      }
      write(buf, off = 0, len = buf.length, pos = 0) {
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (pos + len > this.buf.length) {
          const newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
          this.buf.copy(newBuf, 0, 0, this.buf.length);
          this.buf = newBuf;
        }
        buf.copy(this.buf, pos, off, off + len);
        this.touch();
        return len;
      }
      // Returns the number of bytes read.
      read(buf, off = 0, len = buf.byteLength, pos = 0) {
        this.atime = /* @__PURE__ */ new Date();
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (pos >= this.buf.length)
          return 0;
        let actualLen = len;
        if (actualLen > buf.byteLength) {
          actualLen = buf.byteLength;
        }
        if (actualLen + pos > this.buf.length) {
          actualLen = this.buf.length - pos;
        }
        const buf2 = buf instanceof buffer_1.Buffer ? buf : buffer_1.Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        this.buf.copy(buf2, off, pos, pos + actualLen);
        return actualLen;
      }
      truncate(len = 0) {
        if (!len)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        else {
          if (!this.buf)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          if (len <= this.buf.length) {
            this.buf = this.buf.slice(0, len);
          } else {
            const buf = (0, buffer_1.bufferAllocUnsafe)(len);
            this.buf.copy(buf);
            buf.fill(0, this.buf.length);
            this.buf = buf;
          }
        }
        this.touch();
      }
      chmod(perm) {
        this.mode = this.mode & S_IFMT | perm & ~S_IFMT;
        this.touch();
      }
      chown(uid, gid) {
        this.uid = uid;
        this.gid = gid;
        this.touch();
      }
      touch() {
        this.mtime = /* @__PURE__ */ new Date();
        this.changes.emit(["modify"]);
      }
      canRead(uid = getuid(), gid = getgid()) {
        if (this.perm & 4) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 32) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 256) {
            return true;
          }
        }
        return false;
      }
      canWrite(uid = getuid(), gid = getgid()) {
        if (this.perm & 2) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 16) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 128) {
            return true;
          }
        }
        return false;
      }
      canExecute(uid = getuid(), gid = getgid()) {
        if (this.perm & 1) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 8) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 64) {
            return true;
          }
        }
        return false;
      }
      del() {
        this.changes.emit(["delete"]);
      }
      toJSON() {
        return {
          ino: this.ino,
          uid: this.uid,
          gid: this.gid,
          atime: this.atime.getTime(),
          mtime: this.mtime.getTime(),
          ctime: this.ctime.getTime(),
          perm: this.perm,
          mode: this.mode,
          nlink: this.nlink,
          symlink: this.symlink,
          data: this.getString()
        };
      }
    };
    __name(_Node, "Node");
    var Node = _Node;
    exports.Node = Node;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/Link.js
var require_Link = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/Link.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Link = void 0;
    var constants_1 = require_constants();
    var fanout_1 = require_fanout();
    var { S_IFREG } = constants_1.constants;
    var _Link = class _Link {
      get steps() {
        return this._steps;
      }
      // Recursively sync children steps, e.g. in case of dir rename
      set steps(val) {
        this._steps = val;
        for (const [child, link] of this.children.entries()) {
          if (child === "." || child === "..") {
            continue;
          }
          link?.syncSteps();
        }
      }
      constructor(vol, parent, name) {
        this.changes = new fanout_1.FanOut();
        this.children = /* @__PURE__ */ new Map();
        this._steps = [];
        this.ino = 0;
        this.length = 0;
        this.vol = vol;
        this.parent = parent;
        this.name = name;
        this.syncSteps();
      }
      setNode(node) {
        this.node = node;
        this.ino = node.ino;
      }
      getNode() {
        return this.node;
      }
      createChild(name, node = this.vol.createNode(S_IFREG | 438)) {
        const link = new _Link(this.vol, this, name);
        link.setNode(node);
        if (node.isDirectory()) {
          link.children.set(".", link);
          link.getNode().nlink++;
        }
        this.setChild(name, link);
        return link;
      }
      setChild(name, link = new _Link(this.vol, this, name)) {
        this.children.set(name, link);
        link.parent = this;
        this.length++;
        const node = link.getNode();
        if (node.isDirectory()) {
          link.children.set("..", this);
          this.getNode().nlink++;
        }
        this.getNode().mtime = /* @__PURE__ */ new Date();
        this.changes.emit(["child:add", link, this]);
        return link;
      }
      deleteChild(link) {
        const node = link.getNode();
        if (node.isDirectory()) {
          link.children.delete("..");
          this.getNode().nlink--;
        }
        this.children.delete(link.getName());
        this.length--;
        this.getNode().mtime = /* @__PURE__ */ new Date();
        this.changes.emit(["child:del", link, this]);
      }
      getChild(name) {
        this.getNode().atime = /* @__PURE__ */ new Date();
        return this.children.get(name);
      }
      getPath() {
        return this.steps.join(
          "/"
          /* PATH.SEP */
        );
      }
      getParentPath() {
        return this.steps.slice(0, -1).join(
          "/"
          /* PATH.SEP */
        );
      }
      getName() {
        return this.steps[this.steps.length - 1];
      }
      toJSON() {
        return {
          steps: this.steps,
          ino: this.ino,
          children: Array.from(this.children.keys())
        };
      }
      syncSteps() {
        this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];
      }
    };
    __name(_Link, "Link");
    var Link = _Link;
    exports.Link = Link;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/File.js
var require_File = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/File.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.File = void 0;
    var constants_1 = require_constants();
    var { O_APPEND } = constants_1.constants;
    var _File = class _File {
      /**
       * Open a Link-Node pair. `node` is provided separately as that might be a different node
       * rather the one `link` points to, because it might be a symlink.
       * @param link
       * @param node
       * @param flags
       * @param fd
       */
      constructor(link, node, flags, fd) {
        this.link = link;
        this.node = node;
        this.flags = flags;
        this.fd = fd;
        this.position = 0;
        if (this.flags & O_APPEND)
          this.position = this.getSize();
      }
      getString(encoding = "utf8") {
        return this.node.getString();
      }
      setString(str) {
        this.node.setString(str);
      }
      getBuffer() {
        return this.node.getBuffer();
      }
      setBuffer(buf) {
        this.node.setBuffer(buf);
      }
      getSize() {
        return this.node.getSize();
      }
      truncate(len) {
        this.node.truncate(len);
      }
      seekTo(position) {
        this.position = position;
      }
      write(buf, offset = 0, length = buf.length, position) {
        if (typeof position !== "number")
          position = this.position;
        const bytes = this.node.write(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      }
      read(buf, offset = 0, length = buf.byteLength, position) {
        if (typeof position !== "number")
          position = this.position;
        const bytes = this.node.read(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      }
      chmod(perm) {
        this.node.chmod(perm);
      }
      chown(uid, gid) {
        this.node.chown(uid, gid);
      }
    };
    __name(_File, "File");
    var File2 = _File;
    exports.File = File2;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FLAGS = exports.ERRSTR = void 0;
    var constants_1 = require_constants();
    exports.ERRSTR = {
      PATH_STR: "path must be a string, Buffer, or Uint8Array",
      // FD:             'file descriptor must be a unsigned 32-bit integer',
      FD: "fd must be a file descriptor",
      MODE_INT: "mode must be an int",
      CB: "callback must be a function",
      UID: "uid must be an unsigned int",
      GID: "gid must be an unsigned int",
      LEN: "len must be an integer",
      ATIME: "atime must be an integer",
      MTIME: "mtime must be an integer",
      PREFIX: "filename prefix is required",
      BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
      OFFSET: "offset must be an integer",
      LENGTH: "length must be an integer",
      POSITION: "position must be an integer"
    };
    var { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_TRUNC, O_APPEND, O_SYNC } = constants_1.constants;
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["r"] = O_RDONLY] = "r";
      FLAGS2[FLAGS2["r+"] = O_RDWR] = "r+";
      FLAGS2[FLAGS2["rs"] = O_RDONLY | O_SYNC] = "rs";
      FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
      FLAGS2[FLAGS2["rs+"] = O_RDWR | O_SYNC] = "rs+";
      FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
      FLAGS2[FLAGS2["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
      FLAGS2[FLAGS2["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
      FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
      FLAGS2[FLAGS2["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
      FLAGS2[FLAGS2["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
      FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
      FLAGS2[FLAGS2["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
      FLAGS2[FLAGS2["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
      FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
      FLAGS2[FLAGS2["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
      FLAGS2[FLAGS2["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
      FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
    })(FLAGS || (exports.FLAGS = FLAGS = {}));
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/queueMicrotask.js
var require_queueMicrotask = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/queueMicrotask.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = typeof queueMicrotask === "function" ? queueMicrotask : (cb) => Promise.resolve().then(() => cb()).catch(() => {
    });
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/util.js
var require_util2 = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filenameToSteps = exports.resolve = exports.unixify = exports.isWin = void 0;
    exports.isFd = isFd;
    exports.validateFd = validateFd;
    exports.dataToBuffer = dataToBuffer;
    var path_1 = require_path();
    var buffer_1 = require_buffer3();
    var process_1 = require_process();
    var encoding_1 = require_encoding();
    var constants_1 = require_constants2();
    exports.isWin = process_1.default.platform === "win32";
    var resolveCrossPlatform = path_1.resolve;
    var pathSep = path_1.posix ? path_1.posix.sep : path_1.sep;
    var isSeparator = /* @__PURE__ */ __name((str, i) => {
      let char = str[i];
      return i > 0 && (char === "/" || exports.isWin && char === "\\");
    }, "isSeparator");
    var removeTrailingSeparator = /* @__PURE__ */ __name((str) => {
      let i = str.length - 1;
      if (i < 2)
        return str;
      while (isSeparator(str, i))
        i--;
      return str.substr(0, i + 1);
    }, "removeTrailingSeparator");
    var normalizePath = /* @__PURE__ */ __name((str, stripTrailing) => {
      if (typeof str !== "string")
        throw new TypeError("expected a string");
      str = str.replace(/[\\\/]+/g, "/");
      if (stripTrailing !== false)
        str = removeTrailingSeparator(str);
      return str;
    }, "normalizePath");
    var unixify = /* @__PURE__ */ __name((filepath, stripTrailing = true) => {
      if (exports.isWin) {
        filepath = normalizePath(filepath, stripTrailing);
        return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
      }
      return filepath;
    }, "unixify");
    exports.unixify = unixify;
    var resolve = /* @__PURE__ */ __name((filename, base = process_1.default.cwd()) => resolveCrossPlatform(base, filename), "resolve");
    exports.resolve = resolve;
    if (exports.isWin) {
      const _resolve = resolve;
      exports.resolve = resolve = /* @__PURE__ */ __name((filename, base) => (0, exports.unixify)(_resolve(filename, base)), "resolve");
    }
    var filenameToSteps = /* @__PURE__ */ __name((filename, base) => {
      const fullPath = resolve(filename, base);
      const fullPathSansSlash = fullPath.substring(1);
      if (!fullPathSansSlash)
        return [];
      return fullPathSansSlash.split(pathSep);
    }, "filenameToSteps");
    exports.filenameToSteps = filenameToSteps;
    function isFd(path6) {
      return path6 >>> 0 === path6;
    }
    __name(isFd, "isFd");
    function validateFd(fd) {
      if (!isFd(fd))
        throw TypeError(constants_1.ERRSTR.FD);
    }
    __name(validateFd, "validateFd");
    function dataToBuffer(data, encoding = encoding_1.ENCODING_UTF8) {
      if (buffer_1.Buffer.isBuffer(data))
        return data;
      else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data);
      else if (encoding === "buffer")
        return (0, buffer_1.bufferFrom)(String(data), "utf8");
      else
        return (0, buffer_1.bufferFrom)(String(data), encoding);
    }
    __name(dataToBuffer, "dataToBuffer");
  }
});

// ../../node_modules/.pnpm/punycode@1.4.1/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "../../node_modules/.pnpm/punycode@1.4.1/node_modules/punycode/punycode.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof globalThis == "object" && globalThis;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      __name(error, "error");
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      __name(map, "map");
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      __name(mapDomain, "mapDomain");
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      __name(ucs2decode, "ucs2decode");
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      __name(ucs2encode, "ucs2encode");
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      __name(basicToDigit, "basicToDigit");
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      __name(digitToBasic, "digitToBasic");
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      __name(adapt, "adapt");
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index2, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index2 >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      __name(decode, "decode");
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      __name(encode, "encode");
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      __name(toUnicode, "toUnicode");
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      __name(toASCII, "toASCII");
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// (disabled):../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect
var require_util3 = __commonJS({
  "(disabled):../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect"() {
  }
});

// ../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    __name(addNumericSeparator, "addNumericSeparator");
    var utilInspect = require_util3();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module.exports = /* @__PURE__ */ __name(function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      __name(inspect, "inspect");
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof globalThis !== "undefined" && obj === globalThis) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    }, "inspect_");
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    __name(wrapQuotes, "wrapQuotes");
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    __name(quote, "quote");
    function canTrustToString(obj) {
      return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
    }
    __name(canTrustToString, "canTrustToString");
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    __name(isArray, "isArray");
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    __name(isDate, "isDate");
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    __name(isRegExp, "isRegExp");
    function isError(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    __name(isError, "isError");
    function isString(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    __name(isString, "isString");
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    __name(isNumber, "isNumber");
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    __name(isBoolean, "isBoolean");
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isSymbol, "isSymbol");
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isBigInt, "isBigInt");
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    __name(has, "has");
    function toStr(obj) {
      return objectToString.call(obj);
    }
    __name(toStr, "toStr");
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    __name(nameOf, "nameOf");
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    __name(indexOf, "indexOf");
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    __name(isMap, "isMap");
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakMap, "isWeakMap");
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakRef, "isWeakRef");
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    __name(isSet, "isSet");
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    __name(isWeakSet, "isWeakSet");
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    __name(isElement, "isElement");
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    __name(inspectString, "inspectString");
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    __name(lowbyte, "lowbyte");
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    __name(markBoxed, "markBoxed");
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    __name(weakCollectionOf, "weakCollectionOf");
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    __name(collectionOf, "collectionOf");
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    __name(singleLineValues, "singleLineValues");
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    __name(getIndent, "getIndent");
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    __name(indentedJoin, "indentedJoin");
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
    __name(arrObjKeys, "arrObjKeys");
  }
});

// ../../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS({
  "../../node_modules/.pnpm/side-channel-list@1.0.0/node_modules/side-channel-list/index.js"(exports, module) {
    "use strict";
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var listGetNode = /* @__PURE__ */ __name(function(list, key, isDelete) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) != null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          if (!isDelete) {
            curr.next = /** @type {NonNullable<typeof list.next>} */
            list.next;
            list.next = curr;
          }
          return curr;
        }
      }
    }, "listGetNode");
    var listGet = /* @__PURE__ */ __name(function(objects, key) {
      if (!objects) {
        return void 0;
      }
      var node = listGetNode(objects, key);
      return node && node.value;
    }, "listGet");
    var listSet = /* @__PURE__ */ __name(function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    }, "listSet");
    var listHas = /* @__PURE__ */ __name(function(objects, key) {
      if (!objects) {
        return false;
      }
      return !!listGetNode(objects, key);
    }, "listHas");
    var listDelete = /* @__PURE__ */ __name(function(objects, key) {
      if (objects) {
        return listGetNode(objects, key, true);
      }
    }, "listDelete");
    module.exports = /* @__PURE__ */ __name(function getSideChannelList() {
      var $o;
      var channel = {
        assert: /* @__PURE__ */ __name(function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        }, "assert"),
        "delete": /* @__PURE__ */ __name(function(key) {
          var root = $o && $o.next;
          var deletedNode = listDelete($o, key);
          if (deletedNode && root && root === deletedNode) {
            $o = void 0;
          }
          return !!deletedNode;
        }, "delete"),
        get: /* @__PURE__ */ __name(function(key) {
          return listGet($o, key);
        }, "get"),
        has: /* @__PURE__ */ __name(function(key) {
          return listHas($o, key);
        }, "has"),
        set: /* @__PURE__ */ __name(function(key, value) {
          if (!$o) {
            $o = {
              next: void 0
            };
          }
          listSet(
            /** @type {NonNullable<typeof $o>} */
            $o,
            key,
            value
          );
        }, "set")
      };
      return channel;
    }, "getSideChannelList");
  }
});

// ../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../../node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    module.exports = Object;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// ../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../../node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    module.exports = Math.abs;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    module.exports = Math.floor;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    module.exports = Math.max;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    module.exports = Math.min;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    module.exports = Math.pow;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    module.exports = Math.round;
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    module.exports = Number.isNaN || /* @__PURE__ */ __name(function isNaN2(a) {
      return a !== a;
    }, "isNaN");
  }
});

// ../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "../../node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = /* @__PURE__ */ __name(function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    }, "sign");
  }
});

// ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// ../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// ../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../../node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = /* @__PURE__ */ __name(function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    }, "hasSymbols");
  }
});

// ../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = /* @__PURE__ */ __name(function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    }, "hasNativeSymbols");
  }
});

// ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = /* @__PURE__ */ __name(function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    }, "concatty");
    var slicy = /* @__PURE__ */ __name(function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    }, "slicy");
    var joiny = /* @__PURE__ */ __name(function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    }, "joiny");
    module.exports = /* @__PURE__ */ __name(function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = /* @__PURE__ */ __name(function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      }, "binder");
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = /* @__PURE__ */ __name(function Empty2() {
        }, "Empty");
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    }, "bind");
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.call;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.apply;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = /* @__PURE__ */ __name(function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    }, "callBindBasic");
  }
});

// ../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "../../node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      /* @__PURE__ */ __name(function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }, "getDunder")
    ) : false;
  }
});

// ../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "../../node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      return reflectGetProto(O);
    }, "getProto") : originalGetProto ? /* @__PURE__ */ __name(function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    }, "getProto") : getDunderProto ? /* @__PURE__ */ __name(function getProto(O) {
      return getDunderProto(O);
    }, "getProto") : null;
  }
});

// ../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = /* @__PURE__ */ __name(function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    }, "getEvalledConstructor");
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = /* @__PURE__ */ __name(function() {
      throw new $TypeError();
    }, "throwTypeError");
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = /* @__PURE__ */ __name(function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    }, "doEval");
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = /* @__PURE__ */ __name(function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    }, "stringToPath");
    var getBaseIntrinsic = /* @__PURE__ */ __name(function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    }, "getBaseIntrinsic");
    module.exports = /* @__PURE__ */ __name(function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    }, "GetIntrinsic");
  }
});

// ../../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "../../node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = /* @__PURE__ */ __name(function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    }, "callBoundIntrinsic");
  }
});

// ../../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS({
  "../../node_modules/.pnpm/side-channel-map@1.0.1/node_modules/side-channel-map/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapDelete = callBound("Map.prototype.delete", true);
    var $mapSize = callBound("Map.prototype.size", true);
    module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */
    /* @__PURE__ */ __name(function getSideChannelMap() {
      var $m;
      var channel = {
        assert: /* @__PURE__ */ __name(function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        }, "assert"),
        "delete": /* @__PURE__ */ __name(function(key) {
          if ($m) {
            var result = $mapDelete($m, key);
            if ($mapSize($m) === 0) {
              $m = void 0;
            }
            return result;
          }
          return false;
        }, "delete"),
        get: /* @__PURE__ */ __name(function(key) {
          if ($m) {
            return $mapGet($m, key);
          }
        }, "get"),
        has: /* @__PURE__ */ __name(function(key) {
          if ($m) {
            return $mapHas($m, key);
          }
          return false;
        }, "has"),
        set: /* @__PURE__ */ __name(function(key, value) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        }, "set")
      };
      return channel;
    }, "getSideChannelMap");
  }
});

// ../../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS({
  "../../node_modules/.pnpm/side-channel-weakmap@1.0.2/node_modules/side-channel-weakmap/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var getSideChannelMap = require_side_channel_map();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
    module.exports = $WeakMap ? (
      /** @type {Exclude<import('.'), false>} */
      /* @__PURE__ */ __name(function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
          assert: /* @__PURE__ */ __name(function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          }, "assert"),
          "delete": /* @__PURE__ */ __name(function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapDelete($wm, key);
              }
            } else if (getSideChannelMap) {
              if ($m) {
                return $m["delete"](key);
              }
            }
            return false;
          }, "delete"),
          get: /* @__PURE__ */ __name(function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            }
            return $m && $m.get(key);
          }, "get"),
          has: /* @__PURE__ */ __name(function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            }
            return !!$m && $m.has(key);
          }, "has"),
          set: /* @__PURE__ */ __name(function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
              if (!$m) {
                $m = getSideChannelMap();
              }
              $m.set(key, value);
            }
          }, "set")
        };
        return channel;
      }, "getSideChannelWeakMap")
    ) : getSideChannelMap;
  }
});

// ../../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../../node_modules/.pnpm/side-channel@1.1.0/node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var getSideChannelList = require_side_channel_list();
    var getSideChannelMap = require_side_channel_map();
    var getSideChannelWeakMap = require_side_channel_weakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    module.exports = /* @__PURE__ */ __name(function getSideChannel() {
      var $channelData;
      var channel = {
        assert: /* @__PURE__ */ __name(function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        }, "assert"),
        "delete": /* @__PURE__ */ __name(function(key) {
          return !!$channelData && $channelData["delete"](key);
        }, "delete"),
        get: /* @__PURE__ */ __name(function(key) {
          return $channelData && $channelData.get(key);
        }, "get"),
        has: /* @__PURE__ */ __name(function(key) {
          return !!$channelData && $channelData.has(key);
        }, "has"),
        set: /* @__PURE__ */ __name(function(key, value) {
          if (!$channelData) {
            $channelData = makeChannel();
          }
          $channelData.set(key, value);
        }, "set")
      };
      return channel;
    }, "getSideChannel");
  }
});

// ../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: /* @__PURE__ */ __name(function(value) {
          return replace.call(value, percentTwenties, "+");
        }, "RFC1738"),
        RFC3986: /* @__PURE__ */ __name(function(value) {
          return String(value);
        }, "RFC3986")
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// ../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = /* @__PURE__ */ __name(function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    }, "compactQueue");
    var arrayToObject = /* @__PURE__ */ __name(function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? { __proto__: null } : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    }, "arrayToObject");
    var merge = /* @__PURE__ */ __name(function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object" && typeof source !== "function") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    }, "merge");
    var assign = /* @__PURE__ */ __name(function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    }, "assignSingleSource");
    var decode = /* @__PURE__ */ __name(function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    }, "decode");
    var limit = 1024;
    var encode = /* @__PURE__ */ __name(function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    }, "encode");
    var compact = /* @__PURE__ */ __name(function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    }, "compact");
    var isRegExp = /* @__PURE__ */ __name(function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    }, "isRegExp");
    var isBuffer = /* @__PURE__ */ __name(function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    }, "isBuffer");
    var combine = /* @__PURE__ */ __name(function combine2(a, b) {
      return [].concat(a, b);
    }, "combine");
    var maybeMap = /* @__PURE__ */ __name(function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    }, "maybeMap");
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// ../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: /* @__PURE__ */ __name(function brackets(prefix) {
        return prefix + "[]";
      }, "brackets"),
      comma: "comma",
      indices: /* @__PURE__ */ __name(function indices(prefix, key) {
        return prefix + "[" + key + "]";
      }, "indices"),
      repeat: /* @__PURE__ */ __name(function repeat(prefix) {
        return prefix;
      }, "repeat")
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = /* @__PURE__ */ __name(function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    }, "pushToArray");
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: /* @__PURE__ */ __name(function serializeDate(date) {
        return toISO.call(date);
      }, "serializeDate"),
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = /* @__PURE__ */ __name(function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    }, "isNonNullishPrimitive");
    var sentinel = {};
    var stringify = /* @__PURE__ */ __name(function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    }, "stringify");
    var normalizeStringifyOptions = /* @__PURE__ */ __name(function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    }, "normalizeStringifyOptions");
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];
        if (options.skipNulls && value === null) {
          continue;
        }
        pushToArray(keys, stringify(
          value,
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false,
      throwOnLimitExceeded: false
    };
    var interpretNumericEntities = /* @__PURE__ */ __name(function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    }, "interpretNumericEntities");
    var parseArrayValue = /* @__PURE__ */ __name(function(val, options, currentArrayLength) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
      }
      return val;
    }, "parseArrayValue");
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = /* @__PURE__ */ __name(function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(
        options.delimiter,
        options.throwOnLimitExceeded ? limit + 1 : limit
      );
      if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
      }
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(
              part.slice(pos + 1),
              options,
              isArray(obj[key]) ? obj[key].length : 0
            ),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    }, "parseQueryStringValues");
    var parseObject = /* @__PURE__ */ __name(function(chain, val, options, valuesParsed) {
      var currentArrayLength = 0;
      if (chain.length > 0 && chain[chain.length - 1] === "[]") {
        var parentKey = chain.slice(0, -1).join("");
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
      }
      var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
        } else {
          obj = options.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index2 = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index2) && root !== decodedRoot && String(index2) === decodedRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    }, "parseObject");
    var parseKeys = /* @__PURE__ */ __name(function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    }, "parseQueryStringKeys");
    var normalizeParseOptions = /* @__PURE__ */ __name(function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
        throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
      };
    }, "normalizeParseOptions");
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? { __proto__: null } : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// ../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/qs@6.14.0/node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// ../../node_modules/.pnpm/url@0.11.4/node_modules/url/url.js
var require_url = __commonJS({
  "../../node_modules/.pnpm/url@0.11.4/node_modules/url/url.js"(exports) {
    "use strict";
    var punycode = require_punycode();
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    __name(Url, "Url");
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
    var delims = [
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      "\n",
      "	"
    ];
    var unwise = [
      "{",
      "}",
      "|",
      "\\",
      "^",
      "`"
    ].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = [
      "%",
      "/",
      "?",
      ";",
      "#"
    ].concat(autoEscape);
    var hostEndingChars = [
      "/",
      "?",
      "#"
    ];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var unsafeProtocol = {
      javascript: true,
      "javascript:": true
    };
    var hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    var slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    var querystring = require_lib();
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && typeof url === "object" && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }
    __name(urlParse, "urlParse");
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (typeof url !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1) {
            continue;
          }
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (typeof obj === "string") {
        obj = urlParse(obj);
      }
      if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
      }
      return obj.format();
    }
    __name(urlFormat, "urlFormat");
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
        query = querystring.stringify(this.query, {
          arrayFormat: "repeat",
          addQueryPrefix: false
        });
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":") {
        protocol += ":";
      }
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") {
          pathname = "/" + pathname;
        }
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#") {
        hash = "#" + hash;
      }
      if (search && search.charAt(0) !== "?") {
        search = "?" + search;
      }
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    __name(urlResolve, "urlResolve");
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source, relative) {
      if (!source) {
        return relative;
      }
      return urlParse(source, false, true).resolveObject(relative);
    }
    __name(urlResolveObject, "urlResolveObject");
    Url.prototype.resolveObject = function(relative) {
      if (typeof relative === "string") {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol") {
            result[rkey] = relative[rkey];
          }
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.pathname = "/";
          result.path = result.pathname;
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift())) {
          }
          if (!relative.host) {
            relative.host = "";
          }
          if (!relative.hostname) {
            relative.hostname = "";
          }
          if (relPath[0] !== "") {
            relPath.unshift("");
          }
          if (relPath.length < 2) {
            relPath.unshift("");
          }
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "") {
            srcPath[0] = result.host;
          } else {
            srcPath.unshift(result.host);
          }
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "") {
              relPath[0] = relative.host;
            } else {
              relPath.unshift(relative.host);
            }
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath) {
          srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (relative.search != null) {
        if (psychotic) {
          result.host = srcPath.shift();
          result.hostname = result.host;
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.hostname = authInHost.shift();
            result.host = result.hostname;
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (result.pathname !== null || result.search !== null) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
          srcPath.splice(i, 1);
        } else if (last === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        result.host = result.hostname;
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.hostname = authInHost.shift();
          result.host = result.hostname;
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (srcPath.length > 0) {
        result.pathname = srcPath.join("/");
      } else {
        result.pathname = null;
        result.path = null;
      }
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;
    exports.Url = Url;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/util.js
var require_util4 = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWriteSyncArgs = exports.getWriteArgs = exports.bufToUint8 = void 0;
    exports.promisify = promisify;
    exports.validateCallback = validateCallback;
    exports.modeToNumber = modeToNumber;
    exports.nullCheck = nullCheck;
    exports.pathToFilename = pathToFilename;
    exports.createError = createError;
    exports.genRndStr6 = genRndStr6;
    exports.flagsToNumber = flagsToNumber;
    exports.streamToBuffer = streamToBuffer;
    exports.bufferToEncoding = bufferToEncoding;
    exports.isReadableStream = isReadableStream;
    var constants_1 = require_constants2();
    var errors = require_errors();
    var buffer_1 = require_buffer3();
    var queueMicrotask_1 = require_queueMicrotask();
    var util_1 = require_util2();
    function promisify(fs, fn, getResult = (input) => input) {
      return (...args) => new Promise((resolve, reject) => {
        fs[fn].bind(fs)(...args, (error, result) => {
          if (error)
            return reject(error);
          return resolve(getResult(result));
        });
      });
    }
    __name(promisify, "promisify");
    function validateCallback(callback) {
      if (typeof callback !== "function")
        throw TypeError(constants_1.ERRSTR.CB);
      return callback;
    }
    __name(validateCallback, "validateCallback");
    function _modeToNumber(mode, def) {
      if (typeof mode === "number")
        return mode;
      if (typeof mode === "string")
        return parseInt(mode, 8);
      if (def)
        return modeToNumber(def);
      return void 0;
    }
    __name(_modeToNumber, "_modeToNumber");
    function modeToNumber(mode, def) {
      const result = _modeToNumber(mode, def);
      if (typeof result !== "number" || isNaN(result))
        throw new TypeError(constants_1.ERRSTR.MODE_INT);
      return result;
    }
    __name(modeToNumber, "modeToNumber");
    function nullCheck(path6, callback) {
      if (("" + path6).indexOf("\0") !== -1) {
        const er = new Error("Path must be a string without null bytes");
        er.code = "ENOENT";
        if (typeof callback !== "function")
          throw er;
        (0, queueMicrotask_1.default)(() => {
          callback(er);
        });
        return false;
      }
      return true;
    }
    __name(nullCheck, "nullCheck");
    function getPathFromURLPosix(url) {
      if (url.hostname !== "") {
        throw new errors.TypeError("ERR_INVALID_FILE_URL_HOST", process.platform);
      }
      const pathname = url.pathname;
      for (let n = 0; n < pathname.length; n++) {
        if (pathname[n] === "%") {
          const third = pathname.codePointAt(n + 2) | 32;
          if (pathname[n + 1] === "2" && third === 102) {
            throw new errors.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    __name(getPathFromURLPosix, "getPathFromURLPosix");
    function pathToFilename(path6) {
      if (path6 instanceof Uint8Array) {
        path6 = (0, buffer_1.bufferFrom)(path6);
      }
      if (typeof path6 !== "string" && !buffer_1.Buffer.isBuffer(path6)) {
        try {
          if (!(path6 instanceof require_url().URL))
            throw new TypeError(constants_1.ERRSTR.PATH_STR);
        } catch (err) {
          throw new TypeError(constants_1.ERRSTR.PATH_STR);
        }
        path6 = getPathFromURLPosix(path6);
      }
      const pathString = String(path6);
      nullCheck(pathString);
      return pathString;
    }
    __name(pathToFilename, "pathToFilename");
    var ENOENT = "ENOENT";
    var EBADF = "EBADF";
    var EINVAL = "EINVAL";
    var EPERM = "EPERM";
    var EPROTO = "EPROTO";
    var EEXIST = "EEXIST";
    var ENOTDIR = "ENOTDIR";
    var EMFILE = "EMFILE";
    var EACCES = "EACCES";
    var EISDIR = "EISDIR";
    var ENOTEMPTY = "ENOTEMPTY";
    var ENOSYS = "ENOSYS";
    var ERR_FS_EISDIR = "ERR_FS_EISDIR";
    var ERR_OUT_OF_RANGE = "ERR_OUT_OF_RANGE";
    function formatError(errorCode, func = "", path6 = "", path22 = "") {
      let pathFormatted = "";
      if (path6)
        pathFormatted = ` '${path6}'`;
      if (path22)
        pathFormatted += ` -> '${path22}'`;
      switch (errorCode) {
        case ENOENT:
          return `ENOENT: no such file or directory, ${func}${pathFormatted}`;
        case EBADF:
          return `EBADF: bad file descriptor, ${func}${pathFormatted}`;
        case EINVAL:
          return `EINVAL: invalid argument, ${func}${pathFormatted}`;
        case EPERM:
          return `EPERM: operation not permitted, ${func}${pathFormatted}`;
        case EPROTO:
          return `EPROTO: protocol error, ${func}${pathFormatted}`;
        case EEXIST:
          return `EEXIST: file already exists, ${func}${pathFormatted}`;
        case ENOTDIR:
          return `ENOTDIR: not a directory, ${func}${pathFormatted}`;
        case EISDIR:
          return `EISDIR: illegal operation on a directory, ${func}${pathFormatted}`;
        case EACCES:
          return `EACCES: permission denied, ${func}${pathFormatted}`;
        case ENOTEMPTY:
          return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
        case EMFILE:
          return `EMFILE: too many open files, ${func}${pathFormatted}`;
        case ENOSYS:
          return `ENOSYS: function not implemented, ${func}${pathFormatted}`;
        case ERR_FS_EISDIR:
          return `[ERR_FS_EISDIR]: Path is a directory: ${func} returned EISDIR (is a directory) ${path6}`;
        case ERR_OUT_OF_RANGE:
          return `[ERR_OUT_OF_RANGE]: value out of range, ${func}${pathFormatted}`;
        default:
          return `${errorCode}: error occurred, ${func}${pathFormatted}`;
      }
    }
    __name(formatError, "formatError");
    function createError(errorCode, func = "", path6 = "", path22 = "", Constructor = Error) {
      const error = new Constructor(formatError(errorCode, func, path6, path22));
      error.code = errorCode;
      if (path6) {
        error.path = path6;
      }
      return error;
    }
    __name(createError, "createError");
    function genRndStr6() {
      return Math.random().toString(36).slice(2, 8).padEnd(6, "0");
    }
    __name(genRndStr6, "genRndStr6");
    function flagsToNumber(flags) {
      if (typeof flags === "number")
        return flags;
      if (typeof flags === "string") {
        const flagsNum = constants_1.FLAGS[flags];
        if (typeof flagsNum !== "undefined")
          return flagsNum;
      }
      throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
    }
    __name(flagsToNumber, "flagsToNumber");
    function streamToBuffer(stream) {
      const chunks = [];
      return new Promise((resolve, reject) => {
        stream.on("data", (chunk) => chunks.push(chunk));
        stream.on("end", () => resolve(buffer_1.Buffer.concat(chunks)));
        stream.on("error", reject);
      });
    }
    __name(streamToBuffer, "streamToBuffer");
    var bufToUint8 = /* @__PURE__ */ __name((buf) => new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength), "bufToUint8");
    exports.bufToUint8 = bufToUint8;
    var getWriteArgs = /* @__PURE__ */ __name((fd, a, b, c, d, e) => {
      (0, util_1.validateFd)(fd);
      let offset = 0;
      let length;
      let position = null;
      let encoding;
      let callback;
      const tipa = typeof a;
      const tipb = typeof b;
      const tipc = typeof c;
      const tipd = typeof d;
      if (tipa !== "string") {
        if (tipb === "function") {
          callback = b;
        } else if (tipc === "function") {
          offset = b | 0;
          callback = c;
        } else if (tipd === "function") {
          offset = b | 0;
          length = c;
          callback = d;
        } else {
          offset = b | 0;
          length = c;
          position = d;
          callback = e;
        }
      } else {
        if (tipb === "function") {
          callback = b;
        } else if (tipc === "function") {
          position = b;
          callback = c;
        } else if (tipd === "function") {
          position = b;
          encoding = c;
          callback = d;
        }
      }
      const buf = (0, util_1.dataToBuffer)(a, encoding);
      if (tipa !== "string") {
        if (typeof length === "undefined")
          length = buf.length;
      } else {
        offset = 0;
        length = buf.length;
      }
      const cb = validateCallback(callback);
      return [fd, tipa === "string", buf, offset, length, position, cb];
    }, "getWriteArgs");
    exports.getWriteArgs = getWriteArgs;
    var getWriteSyncArgs = /* @__PURE__ */ __name((fd, a, b, c, d) => {
      (0, util_1.validateFd)(fd);
      let encoding;
      let offset;
      let length;
      let position;
      const isBuffer = typeof a !== "string";
      if (isBuffer) {
        offset = (b || 0) | 0;
        length = c;
        position = d;
      } else {
        position = b;
        encoding = c;
      }
      const buf = (0, util_1.dataToBuffer)(a, encoding);
      if (isBuffer) {
        if (typeof length === "undefined") {
          length = buf.length;
        }
      } else {
        offset = 0;
        length = buf.length;
      }
      return [fd, buf, offset || 0, length, position];
    }, "getWriteSyncArgs");
    exports.getWriteSyncArgs = getWriteSyncArgs;
    function bufferToEncoding(buffer, encoding) {
      if (!encoding || encoding === "buffer")
        return buffer;
      else
        return buffer.toString(encoding);
    }
    __name(bufferToEncoding, "bufferToEncoding");
    function isReadableStream(stream) {
      return stream !== null && typeof stream === "object" && typeof stream.pipe === "function" && typeof stream.on === "function" && stream.readable === true;
    }
    __name(isReadableStream, "isReadableStream");
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/Superblock.js
var require_Superblock = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/Superblock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Superblock = void 0;
    var path_1 = require_path();
    var Node_1 = require_Node();
    var Link_1 = require_Link();
    var File_1 = require_File();
    var buffer_1 = require_buffer3();
    var process_1 = require_process();
    var constants_1 = require_constants();
    var constants_2 = require_constants2();
    var util_1 = require_util4();
    var util_2 = require_util2();
    var json_1 = require_json();
    var pathSep = path_1.posix ? path_1.posix.sep : path_1.sep;
    var pathRelative = path_1.posix ? path_1.posix.relative : path_1.relative;
    var pathJoin = path_1.posix ? path_1.posix.join : path_1.join;
    var { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_TRUNC, O_APPEND, O_DIRECTORY } = constants_1.constants;
    var _Superblock = class _Superblock {
      static fromJSON(json, cwd) {
        const vol = new _Superblock();
        vol.fromJSON(json, cwd);
        return vol;
      }
      static fromNestedJSON(json, cwd) {
        const vol = new _Superblock();
        vol.fromNestedJSON(json, cwd);
        return vol;
      }
      constructor(props = {}) {
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.maxFiles = 1e4;
        this.openFiles = 0;
        this.open = (filename, flagsNum, modeNum, resolveSymlinks = true) => {
          const file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
          if (!file)
            throw (0, util_1.createError)("ENOENT", "open", filename);
          return file.fd;
        };
        this.writeFile = (id, buf, flagsNum, modeNum) => {
          const isUserFd = typeof id === "number";
          let fd;
          if (isUserFd)
            fd = id;
          else
            fd = this.open((0, util_1.pathToFilename)(id), flagsNum, modeNum);
          let offset = 0;
          let length = buf.length;
          let position = flagsNum & O_APPEND ? void 0 : 0;
          try {
            while (length > 0) {
              const written = this.write(fd, buf, offset, length, position);
              offset += written;
              length -= written;
              if (position !== void 0)
                position += written;
            }
          } finally {
            if (!isUserFd)
              this.close(fd);
          }
        };
        this.read = (fd, buffer, offset, length, position) => {
          if (buffer.byteLength < length) {
            throw (0, util_1.createError)("ERR_OUT_OF_RANGE", "read", void 0, void 0, RangeError);
          }
          const file = this.getFileByFdOrThrow(fd);
          if (file.node.isSymlink()) {
            throw (0, util_1.createError)("EPERM", "read", file.link.getPath());
          }
          return file.read(buffer, Number(offset), Number(length), position === -1 || typeof position !== "number" ? void 0 : position);
        };
        this.readv = (fd, buffers, position) => {
          const file = this.getFileByFdOrThrow(fd);
          let p = position ?? void 0;
          if (p === -1)
            p = void 0;
          let bytesRead = 0;
          for (const buffer of buffers) {
            const bytes = file.read(buffer, 0, buffer.byteLength, p);
            p = void 0;
            bytesRead += bytes;
            if (bytes < buffer.byteLength)
              break;
          }
          return bytesRead;
        };
        this.link = (filename1, filename2) => {
          let link1;
          try {
            link1 = this.getLinkOrThrow(filename1, "link");
          } catch (err) {
            if (err.code)
              err = (0, util_1.createError)(err.code, "link", filename1, filename2);
            throw err;
          }
          const dirname22 = (0, path_1.dirname)(filename2);
          let dir2;
          try {
            dir2 = this.getLinkOrThrow(dirname22, "link");
          } catch (err) {
            if (err.code)
              err = (0, util_1.createError)(err.code, "link", filename1, filename2);
            throw err;
          }
          const name = (0, path_1.basename)(filename2);
          if (dir2.getChild(name))
            throw (0, util_1.createError)("EEXIST", "link", filename1, filename2);
          const node = link1.getNode();
          node.nlink++;
          dir2.createChild(name, node);
        };
        this.unlink = (filename) => {
          const link = this.getLinkOrThrow(filename, "unlink");
          if (link.length)
            throw Error("Dir not empty...");
          this.deleteLink(link);
          const node = link.getNode();
          node.nlink--;
          if (node.nlink <= 0) {
            this.deleteNode(node);
          }
        };
        this.symlink = (targetFilename, pathFilename) => {
          const pathSteps = (0, util_2.filenameToSteps)(pathFilename);
          let dirLink;
          try {
            dirLink = this.getLinkParentAsDirOrThrow(pathSteps);
          } catch (err) {
            if (err.code)
              err = (0, util_1.createError)(err.code, "symlink", targetFilename, pathFilename);
            throw err;
          }
          const name = pathSteps[pathSteps.length - 1];
          if (dirLink.getChild(name))
            throw (0, util_1.createError)("EEXIST", "symlink", targetFilename, pathFilename);
          const node = dirLink.getNode();
          if (!node.canExecute() || !node.canWrite())
            throw (0, util_1.createError)("EACCES", "symlink", targetFilename, pathFilename);
          const symlink = dirLink.createChild(name);
          symlink.getNode().makeSymlink(targetFilename);
          return symlink;
        };
        this.rename = (oldPathFilename, newPathFilename) => {
          let link;
          try {
            link = this.getResolvedLinkOrThrow(oldPathFilename);
          } catch (err) {
            if (err.code)
              err = (0, util_1.createError)(err.code, "rename", oldPathFilename, newPathFilename);
            throw err;
          }
          let newPathDirLink;
          try {
            newPathDirLink = this.getLinkParentAsDirOrThrow(newPathFilename);
          } catch (err) {
            if (err.code)
              err = (0, util_1.createError)(err.code, "rename", oldPathFilename, newPathFilename);
            throw err;
          }
          const oldLinkParent = link.parent;
          if (!oldLinkParent)
            throw (0, util_1.createError)("EINVAL", "rename", oldPathFilename, newPathFilename);
          const oldParentNode = oldLinkParent.getNode();
          const newPathDirNode = newPathDirLink.getNode();
          if (!oldParentNode.canExecute() || !oldParentNode.canWrite() || !newPathDirNode.canExecute() || !newPathDirNode.canWrite()) {
            throw (0, util_1.createError)("EACCES", "rename", oldPathFilename, newPathFilename);
          }
          oldLinkParent.deleteChild(link);
          const name = (0, path_1.basename)(newPathFilename);
          link.name = name;
          link.steps = [...newPathDirLink.steps, name];
          newPathDirLink.setChild(link.getName(), link);
        };
        this.mkdir = (filename, modeNum) => {
          const steps = (0, util_2.filenameToSteps)(filename);
          if (!steps.length)
            throw (0, util_1.createError)("EEXIST", "mkdir", filename);
          const dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
          const name = steps[steps.length - 1];
          if (dir.getChild(name))
            throw (0, util_1.createError)("EEXIST", "mkdir", filename);
          const node = dir.getNode();
          if (!node.canWrite() || !node.canExecute())
            throw (0, util_1.createError)("EACCES", "mkdir", filename);
          dir.createChild(name, this.createNode(constants_1.constants.S_IFDIR | modeNum));
        };
        this.mkdirp = (filename, modeNum) => {
          let created = false;
          const steps = (0, util_2.filenameToSteps)(filename);
          let curr = null;
          let i = steps.length;
          for (i = steps.length; i >= 0; i--) {
            curr = this.getResolvedLink(steps.slice(0, i));
            if (curr)
              break;
          }
          if (!curr) {
            curr = this.root;
            i = 0;
          }
          curr = this.getResolvedLinkOrThrow(path_1.sep + steps.slice(0, i).join(path_1.sep), "mkdir");
          for (i; i < steps.length; i++) {
            const node = curr.getNode();
            if (node.isDirectory()) {
              if (!node.canExecute() || !node.canWrite())
                throw (0, util_1.createError)("EACCES", "mkdir", filename);
            } else {
              throw (0, util_1.createError)("ENOTDIR", "mkdir", filename);
            }
            created = true;
            curr = curr.createChild(steps[i], this.createNode(constants_1.constants.S_IFDIR | modeNum));
          }
          return created ? filename : void 0;
        };
        this.rmdir = (filename, recursive = false) => {
          const link = this.getLinkAsDirOrThrow(filename, "rmdir");
          if (link.length && !recursive)
            throw (0, util_1.createError)("ENOTEMPTY", "rmdir", filename);
          this.deleteLink(link);
        };
        this.rm = (filename, force = false, recursive = false) => {
          let link;
          try {
            link = this.getResolvedLinkOrThrow(filename, "stat");
          } catch (err) {
            if (err.code === "ENOENT" && force)
              return;
            else
              throw err;
          }
          if (link.getNode().isDirectory() && !recursive)
            throw (0, util_1.createError)("ERR_FS_EISDIR", "rm", filename);
          if (!link.parent?.getNode().canWrite())
            throw (0, util_1.createError)("EACCES", "rm", filename);
          this.deleteLink(link);
        };
        this.close = (fd) => {
          (0, util_2.validateFd)(fd);
          const file = this.getFileByFdOrThrow(fd, "close");
          this.closeFile(file);
        };
        const root = this.createLink();
        root.setNode(this.createNode(constants_1.constants.S_IFDIR | 511));
        root.setChild(".", root);
        root.getNode().nlink++;
        root.setChild("..", root);
        root.getNode().nlink++;
        this.root = root;
      }
      createLink(parent, name, isDirectory = false, mode) {
        if (!parent) {
          return new Link_1.Link(this, void 0, "");
        }
        if (!name) {
          throw new Error("createLink: name cannot be empty");
        }
        const finalPerm = mode ?? (isDirectory ? 511 : 438);
        const hasFileType = mode && mode & constants_1.constants.S_IFMT;
        const modeType = hasFileType ? mode & constants_1.constants.S_IFMT : isDirectory ? constants_1.constants.S_IFDIR : constants_1.constants.S_IFREG;
        const finalMode = finalPerm & ~constants_1.constants.S_IFMT | modeType;
        return parent.createChild(name, this.createNode(finalMode));
      }
      deleteLink(link) {
        const parent = link.parent;
        if (parent) {
          parent.deleteChild(link);
          return true;
        }
        return false;
      }
      newInoNumber() {
        const releasedFd = this.releasedInos.pop();
        if (releasedFd)
          return releasedFd;
        else {
          this.ino = (this.ino + 1) % 4294967295;
          return this.ino;
        }
      }
      newFdNumber() {
        const releasedFd = this.releasedFds.pop();
        return typeof releasedFd === "number" ? releasedFd : _Superblock.fd--;
      }
      createNode(mode) {
        const node = new Node_1.Node(this.newInoNumber(), mode);
        this.inodes[node.ino] = node;
        return node;
      }
      deleteNode(node) {
        node.del();
        delete this.inodes[node.ino];
        this.releasedInos.push(node.ino);
      }
      walk(stepsOrFilenameOrLink, resolveSymlinks = false, checkExistence = false, checkAccess = false, funcName) {
        let steps;
        let filename;
        if (stepsOrFilenameOrLink instanceof Link_1.Link) {
          steps = stepsOrFilenameOrLink.steps;
          filename = pathSep + steps.join(pathSep);
        } else if (typeof stepsOrFilenameOrLink === "string") {
          steps = (0, util_2.filenameToSteps)(stepsOrFilenameOrLink);
          filename = stepsOrFilenameOrLink;
        } else {
          steps = stepsOrFilenameOrLink;
          filename = pathSep + steps.join(pathSep);
        }
        let curr = this.root;
        let i = 0;
        while (i < steps.length) {
          let node = curr.getNode();
          if (node.isDirectory()) {
            if (checkAccess && !node.canExecute()) {
              throw (0, util_1.createError)("EACCES", funcName, filename);
            }
          } else {
            if (i < steps.length - 1)
              throw (0, util_1.createError)("ENOTDIR", funcName, filename);
          }
          curr = curr.getChild(steps[i]) ?? null;
          if (!curr)
            if (checkExistence)
              throw (0, util_1.createError)("ENOENT", funcName, filename);
            else
              return null;
          node = curr?.getNode();
          if (node.isSymlink() && (resolveSymlinks || i < steps.length - 1)) {
            const resolvedPath = (0, path_1.isAbsolute)(node.symlink) ? node.symlink : pathJoin((0, path_1.dirname)(curr.getPath()), node.symlink);
            steps = (0, util_2.filenameToSteps)(resolvedPath).concat(steps.slice(i + 1));
            curr = this.root;
            i = 0;
            continue;
          }
          if (checkExistence && !node.isDirectory() && i < steps.length - 1) {
            const errorCode = process_1.default.platform === "win32" ? "ENOENT" : "ENOTDIR";
            throw (0, util_1.createError)(errorCode, funcName, filename);
          }
          i++;
        }
        return curr;
      }
      // Returns a `Link` (hard link) referenced by path "split" into steps.
      getLink(steps) {
        return this.walk(steps, false, false, false);
      }
      // Just link `getLink`, but throws a correct user error, if link to found.
      getLinkOrThrow(filename, funcName) {
        return this.walk(filename, false, true, true, funcName);
      }
      // Just like `getLink`, but also dereference/resolves symbolic links.
      getResolvedLink(filenameOrSteps) {
        return this.walk(filenameOrSteps, true, false, false);
      }
      /**
       * Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.
       */
      getResolvedLinkOrThrow(filename, funcName) {
        return this.walk(filename, true, true, true, funcName);
      }
      resolveSymlinks(link) {
        return this.getResolvedLink(link.steps.slice(1));
      }
      /**
       * Just like `getLinkOrThrow`, but also verifies that the link is a directory.
       */
      getLinkAsDirOrThrow(filename, funcName) {
        const link = this.getLinkOrThrow(filename, funcName);
        if (!link.getNode().isDirectory())
          throw (0, util_1.createError)("ENOTDIR", funcName, filename);
        return link;
      }
      // Get the immediate parent directory of the link.
      getLinkParent(steps) {
        return this.getLink(steps.slice(0, -1));
      }
      getLinkParentAsDirOrThrow(filenameOrSteps, funcName) {
        const steps = (filenameOrSteps instanceof Array ? filenameOrSteps : (0, util_2.filenameToSteps)(filenameOrSteps)).slice(0, -1);
        const filename = pathSep + steps.join(pathSep);
        const link = this.getLinkOrThrow(filename, funcName);
        if (!link.getNode().isDirectory())
          throw (0, util_1.createError)("ENOTDIR", funcName, filename);
        return link;
      }
      getFileByFd(fd) {
        return this.fds[String(fd)];
      }
      getFileByFdOrThrow(fd, funcName) {
        if (!(0, util_2.isFd)(fd))
          throw TypeError(constants_2.ERRSTR.FD);
        const file = this.getFileByFd(fd);
        if (!file)
          throw (0, util_1.createError)("EBADF", funcName);
        return file;
      }
      _toJSON(link = this.root, json = {}, path6, asBuffer) {
        let isEmpty = true;
        let children = link.children;
        if (link.getNode().isFile()) {
          children = /* @__PURE__ */ new Map([[link.getName(), link.parent.getChild(link.getName())]]);
          link = link.parent;
        }
        for (const name of children.keys()) {
          if (name === "." || name === "..") {
            continue;
          }
          isEmpty = false;
          const child = link.getChild(name);
          if (!child) {
            throw new Error("_toJSON: unexpected undefined");
          }
          const node = child.getNode();
          if (node.isFile()) {
            let filename = child.getPath();
            if (path6)
              filename = pathRelative(path6, filename);
            json[filename] = asBuffer ? node.getBuffer() : node.getString();
          } else if (node.isDirectory()) {
            this._toJSON(child, json, path6, asBuffer);
          }
        }
        let dirPath = link.getPath();
        if (path6)
          dirPath = pathRelative(path6, dirPath);
        if (dirPath && isEmpty) {
          json[dirPath] = null;
        }
        return json;
      }
      toJSON(paths, json = {}, isRelative = false, asBuffer = false) {
        const links = [];
        if (paths) {
          if (!Array.isArray(paths))
            paths = [paths];
          for (const path6 of paths) {
            const filename = (0, util_1.pathToFilename)(path6);
            const link = this.getResolvedLink(filename);
            if (!link)
              continue;
            links.push(link);
          }
        } else {
          links.push(this.root);
        }
        if (!links.length)
          return json;
        for (const link of links)
          this._toJSON(link, json, isRelative ? link.getPath() : "", asBuffer);
        return json;
      }
      // TODO: `cwd` should probably not invoke `process.cwd()`.
      fromJSON(json, cwd = process_1.default.cwd()) {
        for (let filename in json) {
          const data = json[filename];
          filename = (0, util_2.resolve)(filename, cwd);
          if (typeof data === "string" || data instanceof buffer_1.Buffer) {
            const dir = (0, path_1.dirname)(filename);
            this.mkdirp(
              dir,
              511
              /* MODE.DIR */
            );
            const buffer = (0, util_2.dataToBuffer)(data);
            this.writeFile(
              filename,
              buffer,
              constants_2.FLAGS.w,
              438
              /* MODE.DEFAULT */
            );
          } else {
            this.mkdirp(
              filename,
              511
              /* MODE.DIR */
            );
          }
        }
      }
      fromNestedJSON(json, cwd) {
        this.fromJSON((0, json_1.flattenJSON)(json), cwd);
      }
      reset() {
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.openFiles = 0;
        this.root = this.createLink();
        this.root.setNode(this.createNode(constants_1.constants.S_IFDIR | 511));
      }
      // Legacy interface
      mountSync(mountpoint, json) {
        this.fromJSON(json, mountpoint);
      }
      openLink(link, flagsNum, resolveSymlinks = true) {
        if (this.openFiles >= this.maxFiles) {
          throw (0, util_1.createError)("EMFILE", "open", link.getPath());
        }
        let realLink = link;
        if (resolveSymlinks)
          realLink = this.getResolvedLinkOrThrow(link.getPath(), "open");
        const node = realLink.getNode();
        if (node.isDirectory()) {
          if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)
            throw (0, util_1.createError)("EISDIR", "open", link.getPath());
        } else {
          if (flagsNum & O_DIRECTORY)
            throw (0, util_1.createError)("ENOTDIR", "open", link.getPath());
        }
        if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_WRONLY) {
          if (!node.canRead()) {
            throw (0, util_1.createError)("EACCES", "open", link.getPath());
          }
        }
        if (flagsNum & (O_WRONLY | O_RDWR)) {
          if (!node.canWrite()) {
            throw (0, util_1.createError)("EACCES", "open", link.getPath());
          }
        }
        const file = new File_1.File(link, node, flagsNum, this.newFdNumber());
        this.fds[file.fd] = file;
        this.openFiles++;
        if (flagsNum & O_TRUNC)
          file.truncate();
        return file;
      }
      openFile(filename, flagsNum, modeNum, resolveSymlinks = true) {
        const steps = (0, util_2.filenameToSteps)(filename);
        let link;
        try {
          link = resolveSymlinks ? this.getResolvedLinkOrThrow(filename, "open") : this.getLinkOrThrow(filename, "open");
          if (link && flagsNum & O_CREAT && flagsNum & O_EXCL)
            throw (0, util_1.createError)("EEXIST", "open", filename);
        } catch (err) {
          if (err.code === "ENOENT" && flagsNum & O_CREAT) {
            const dirName = (0, path_1.dirname)(filename);
            const dirLink = this.getResolvedLinkOrThrow(dirName);
            const dirNode = dirLink.getNode();
            if (!dirNode.isDirectory())
              throw (0, util_1.createError)("ENOTDIR", "open", filename);
            if (!dirNode.canExecute() || !dirNode.canWrite())
              throw (0, util_1.createError)("EACCES", "open", filename);
            modeNum ?? (modeNum = 438);
            link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
          } else
            throw err;
        }
        if (link)
          return this.openLink(link, flagsNum, resolveSymlinks);
        throw (0, util_1.createError)("ENOENT", "open", filename);
      }
      closeFile(file) {
        if (!this.fds[file.fd])
          return;
        this.openFiles--;
        delete this.fds[file.fd];
        this.releasedFds.push(file.fd);
      }
      write(fd, buf, offset, length, position) {
        const file = this.getFileByFdOrThrow(fd, "write");
        if (file.node.isSymlink()) {
          throw (0, util_1.createError)("EBADF", "write", file.link.getPath());
        }
        return file.write(buf, offset, length, position === -1 || typeof position !== "number" ? void 0 : position);
      }
    };
    __name(_Superblock, "Superblock");
    var Superblock = _Superblock;
    exports.Superblock = Superblock;
    Superblock.fd = 2147483647;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/index.js
var require_core = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Superblock = exports.File = exports.Link = exports.Node = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_json(), exports);
    var Node_1 = require_Node();
    Object.defineProperty(exports, "Node", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Node_1.Node;
    }, "get") });
    var Link_1 = require_Link();
    Object.defineProperty(exports, "Link", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Link_1.Link;
    }, "get") });
    var File_1 = require_File();
    Object.defineProperty(exports, "File", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return File_1.File;
    }, "get") });
    var Superblock_1 = require_Superblock();
    Object.defineProperty(exports, "Superblock", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Superblock_1.Superblock;
    }, "get") });
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/StatFs.js
var require_StatFs = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/StatFs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatFs = void 0;
    var _StatFs = class _StatFs {
      static build(superblock, bigint = false) {
        const statfs = new _StatFs();
        const getStatNumber = !bigint ? (number) => number : (number) => BigInt(number);
        statfs.type = getStatNumber(2240043254);
        statfs.bsize = getStatNumber(4096);
        const totalInodes = Object.keys(superblock.inodes).length;
        const totalBlocks = 1e6;
        const usedBlocks = Math.min(totalInodes * 2, totalBlocks);
        const freeBlocks = totalBlocks - usedBlocks;
        statfs.blocks = getStatNumber(totalBlocks);
        statfs.bfree = getStatNumber(freeBlocks);
        statfs.bavail = getStatNumber(freeBlocks);
        const maxFiles = 1e6;
        statfs.files = getStatNumber(maxFiles);
        statfs.ffree = getStatNumber(maxFiles - totalInodes);
        return statfs;
      }
    };
    __name(_StatFs, "StatFs");
    var StatFs = _StatFs;
    exports.StatFs = StatFs;
    exports.default = StatFs;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/setTimeoutUnref.js
var require_setTimeoutUnref = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/setTimeoutUnref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function setTimeoutUnref(callback, time, args) {
      const ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : globalThis, arguments);
      if (ref && typeof ref === "object" && typeof ref.unref === "function")
        ref.unref();
      return ref;
    }
    __name(setTimeoutUnref, "setTimeoutUnref");
    exports.default = setTimeoutUnref;
  }
});

// ../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js
var require_events = __commonJS({
  "../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : /* @__PURE__ */ __name(function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    }, "ReflectApply");
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = /* @__PURE__ */ __name(function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      }, "ReflectOwnKeys");
    } else {
      ReflectOwnKeys = /* @__PURE__ */ __name(function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      }, "ReflectOwnKeys");
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    __name(ProcessEmitWarning, "ProcessEmitWarning");
    var NumberIsNaN = Number.isNaN || /* @__PURE__ */ __name(function NumberIsNaN2(value) {
      return value !== value;
    }, "NumberIsNaN");
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    __name(EventEmitter, "EventEmitter");
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    __name(checkListener, "checkListener");
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return defaultMaxListeners;
      }, "get"),
      set: /* @__PURE__ */ __name(function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }, "set")
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = /* @__PURE__ */ __name(function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    }, "setMaxListeners");
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    __name(_getMaxListeners, "_getMaxListeners");
    EventEmitter.prototype.getMaxListeners = /* @__PURE__ */ __name(function getMaxListeners() {
      return _getMaxListeners(this);
    }, "getMaxListeners");
    EventEmitter.prototype.emit = /* @__PURE__ */ __name(function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    }, "emit");
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    __name(_addListener, "_addListener");
    EventEmitter.prototype.addListener = /* @__PURE__ */ __name(function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    }, "addListener");
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = /* @__PURE__ */ __name(function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    }, "prependListener");
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    __name(onceWrapper, "onceWrapper");
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    __name(_onceWrap, "_onceWrap");
    EventEmitter.prototype.once = /* @__PURE__ */ __name(function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    }, "once");
    EventEmitter.prototype.prependOnceListener = /* @__PURE__ */ __name(function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    }, "prependOnceListener");
    EventEmitter.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    }, "removeListener");
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    }, "removeAllListeners");
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    __name(_listeners, "_listeners");
    EventEmitter.prototype.listeners = /* @__PURE__ */ __name(function listeners(type) {
      return _listeners(this, type, true);
    }, "listeners");
    EventEmitter.prototype.rawListeners = /* @__PURE__ */ __name(function rawListeners(type) {
      return _listeners(this, type, false);
    }, "rawListeners");
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    __name(listenerCount, "listenerCount");
    EventEmitter.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    }, "eventNames");
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    __name(arrayClone, "arrayClone");
    function spliceOne(list, index2) {
      for (; index2 + 1 < list.length; index2++)
        list[index2] = list[index2 + 1];
      list.pop();
    }
    __name(spliceOne, "spliceOne");
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    __name(unwrapListeners, "unwrapListeners");
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        __name(errorListener, "errorListener");
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        __name(resolver, "resolver");
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    __name(once, "once");
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    __name(addErrorHandlerIfEventEmitter, "addErrorHandlerIfEventEmitter");
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, /* @__PURE__ */ __name(function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        }, "wrapListener"));
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      }, "inherits");
    } else {
      module.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = /* @__PURE__ */ __name(function() {
          }, "TempCtor");
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      }, "inherits");
    }
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// (disabled):util
var require_util5 = __commonJS({
  "(disabled):util"() {
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    function ownKeys2(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys2, "ownKeys");
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    __name(_toPrimitive, "_toPrimitive");
    var _require = require_buffer();
    var Buffer3 = _require.Buffer;
    var _require2 = require_util5();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer3.prototype.copy.call(src, target, offset);
    }
    __name(copyBuffer, "copyBuffer");
    module.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      __name(BufferList, "BufferList");
      _createClass(BufferList, [{
        key: "push",
        value: /* @__PURE__ */ __name(function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }, "push")
      }, {
        key: "unshift",
        value: /* @__PURE__ */ __name(function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }, "unshift")
      }, {
        key: "shift",
        value: /* @__PURE__ */ __name(function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }, "shift")
      }, {
        key: "clear",
        value: /* @__PURE__ */ __name(function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }, "clear")
      }, {
        key: "join",
        value: /* @__PURE__ */ __name(function join(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }, "join")
      }, {
        key: "concat",
        value: /* @__PURE__ */ __name(function concat(n) {
          if (this.length === 0) return Buffer3.alloc(0);
          var ret = Buffer3.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }, "concat")
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: /* @__PURE__ */ __name(function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }, "consume")
      }, {
        key: "first",
        value: /* @__PURE__ */ __name(function first() {
          return this.head.data;
        }, "first")
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: /* @__PURE__ */ __name(function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }, "_getString")
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: /* @__PURE__ */ __name(function _getBuffer(n) {
          var ret = Buffer3.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }, "_getBuffer")
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: /* @__PURE__ */ __name(function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }, "value")
      }]);
      return BufferList;
    }();
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    __name(destroy, "destroy");
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    __name(emitErrorAndCloseNT, "emitErrorAndCloseNT");
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    __name(emitCloseNT, "emitCloseNT");
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    __name(undestroy, "undestroy");
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    __name(emitErrorNT, "emitErrorNT");
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    __name(errorOrDestroy, "errorOrDestroy");
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    __name(_inheritsLoose, "_inheritsLoose");
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      __name(getMessage, "getMessage");
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        __name(NodeError2, "NodeError");
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    __name(createErrorType, "createErrorType");
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    __name(oneOf, "oneOf");
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    __name(startsWith, "startsWith");
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    __name(endsWith, "endsWith");
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    __name(includes, "includes");
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    __name(highWaterMarkFrom, "highWaterMarkFrom");
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    __name(getHighWaterMark, "getHighWaterMark");
    module.exports = {
      getHighWaterMark
    };
  }
});

// ../../node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      __name(deprecated, "deprecated");
      return deprecated;
    }
    __name(deprecate, "deprecate");
    function config(name) {
      try {
        if (!globalThis.localStorage) return false;
      } catch (_) {
        return false;
      }
      var val = globalThis.localStorage[name];
      if (null == val) return false;
      return String(val).toLowerCase() === "true";
    }
    __name(config, "config");
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    __name(CorkedRequest, "CorkedRequest");
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer3 = require_buffer().Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    __name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    __name(_isUint8Array, "_isUint8Array");
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    __name(nop, "nop");
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    __name(WritableState, "WritableState");
    WritableState.prototype.getBuffer = /* @__PURE__ */ __name(function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    }, "getBuffer");
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(/* @__PURE__ */ __name(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "writableStateBufferGetter"), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: /* @__PURE__ */ __name(function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }, "value")
      });
    } else {
      realHasInstance = /* @__PURE__ */ __name(function realHasInstance2(object) {
        return object instanceof this;
      }, "realHasInstance");
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    __name(Writable, "Writable");
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    __name(writeAfterEnd, "writeAfterEnd");
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    __name(validChunk, "validChunk");
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer3.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    }, "setDefaultEncoding");
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState && this._writableState.getBuffer();
      }, "get")
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer3.from(chunk, encoding);
      }
      return chunk;
    }
    __name(decodeChunk, "decodeChunk");
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState.highWaterMark;
      }, "get")
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    __name(writeOrBuffer, "writeOrBuffer");
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    __name(doWrite, "doWrite");
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    __name(onwriteError, "onwriteError");
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    __name(onwriteStateUpdate, "onwriteStateUpdate");
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    __name(onwrite, "onwrite");
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    __name(afterWrite, "afterWrite");
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    __name(onwriteDrain, "onwriteDrain");
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    __name(clearBuffer, "clearBuffer");
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState.length;
      }, "get")
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    __name(needFinish, "needFinish");
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    __name(callFinal, "callFinal");
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    __name(prefinish, "prefinish");
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    __name(finishMaybe, "finishMaybe");
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    __name(endWritable, "endWritable");
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    __name(onCorkedFinish, "onCorkedFinish");
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }, "set")
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    __name(Duplex, "Duplex");
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState.highWaterMark;
      }, "get")
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState && this._writableState.getBuffer();
      }, "get")
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._writableState.length;
      }, "get")
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    __name(onend, "onend");
    function onEndNT(self2) {
      self2.end();
    }
    __name(onEndNT, "onEndNT");
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }, "set")
    });
  }
});

// ../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../../node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var isEncoding = Buffer3.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    __name(_normalizeEncoding, "_normalizeEncoding");
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    __name(normalizeEncoding, "normalizeEncoding");
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer3.allocUnsafe(nb);
    }
    __name(StringDecoder, "StringDecoder");
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    __name(utf8CheckByte, "utf8CheckByte");
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    __name(utf8CheckIncomplete, "utf8CheckIncomplete");
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    __name(utf8CheckExtraBytes, "utf8CheckExtraBytes");
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    __name(utf8FillLast, "utf8FillLast");
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    __name(utf8Text, "utf8Text");
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    __name(utf8End, "utf8End");
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    __name(utf16Text, "utf16Text");
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    __name(utf16End, "utf16End");
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    __name(base64Text, "base64Text");
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    __name(base64End, "base64End");
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    __name(simpleWrite, "simpleWrite");
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
    __name(simpleEnd, "simpleEnd");
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    __name(once, "once");
    function noop() {
    }
    __name(noop, "noop");
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    __name(isRequest, "isRequest");
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = /* @__PURE__ */ __name(function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      }, "onlegacyfinish");
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = /* @__PURE__ */ __name(function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      }, "onfinish");
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = /* @__PURE__ */ __name(function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      }, "onend");
      var onerror = /* @__PURE__ */ __name(function onerror2(err) {
        callback.call(stream, err);
      }, "onerror");
      var onclose = /* @__PURE__ */ __name(function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      }, "onclose");
      var onrequest = /* @__PURE__ */ __name(function onrequest2() {
        stream.req.on("finish", onfinish);
      }, "onrequest");
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    __name(eos, "eos");
    module.exports = eos;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    __name(_toPrimitive, "_toPrimitive");
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    __name(createIterResult, "createIterResult");
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    __name(readAndResolve, "readAndResolve");
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    __name(onReadable, "onReadable");
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    __name(wrapForNext, "wrapForNext");
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: /* @__PURE__ */ __name(function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }, "next")
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", /* @__PURE__ */ __name(function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }, "_return")), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = /* @__PURE__ */ __name(function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: /* @__PURE__ */ __name(function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        }, "value"),
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    }, "createReadableStreamAsyncIterator");
    module.exports = createReadableStreamAsyncIterator;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = /* @__PURE__ */ __name(function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    }, "EElistenerCount");
    var Stream = require_stream_browser();
    var Buffer3 = require_buffer().Buffer;
    var OurUint8Array = (typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    __name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    __name(_isUint8Array, "_isUint8Array");
    var debugUtil = require_util5();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = /* @__PURE__ */ __name(function debug2() {
      }, "debug");
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    __name(prependListener, "prependListener");
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    __name(ReadableState, "ReadableState");
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    __name(Readable, "Readable");
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }, "set")
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    __name(readableAddChunk, "readableAddChunk");
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    __name(addChunk, "addChunk");
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    __name(chunkInvalid, "chunkInvalid");
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    __name(computeNewHighWaterMark, "computeNewHighWaterMark");
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    __name(howMuchToRead, "howMuchToRead");
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    __name(onEofChunk, "onEofChunk");
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    __name(emitReadable, "emitReadable");
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    __name(emitReadable_, "emitReadable_");
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    __name(maybeReadMore, "maybeReadMore");
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    __name(maybeReadMore_, "maybeReadMore_");
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      __name(onunpipe, "onunpipe");
      function onend() {
        debug("onend");
        dest.end();
      }
      __name(onend, "onend");
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      __name(cleanup, "cleanup");
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      __name(ondata, "ondata");
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      __name(onerror, "onerror");
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      __name(onclose, "onclose");
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      __name(onfinish, "onfinish");
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      __name(unpipe, "unpipe");
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return /* @__PURE__ */ __name(function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      }, "pipeOnDrainFunctionResult");
    }
    __name(pipeOnDrain, "pipeOnDrain");
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index2 = indexOf(state.pipes, dest);
      if (index2 === -1) return this;
      state.pipes.splice(index2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    __name(updateReadableListening, "updateReadableListening");
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    __name(nReadingNextTick, "nReadingNextTick");
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    __name(resume, "resume");
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    __name(resume_, "resume_");
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    __name(flow, "flow");
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = (/* @__PURE__ */ __name(function methodWrap(method) {
            return /* @__PURE__ */ __name(function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            }, "methodWrapReturnFunction");
          }, "methodWrap"))(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._readableState.highWaterMark;
      }, "get")
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._readableState && this._readableState.buffer;
      }, "get")
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._readableState.flowing;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }, "set")
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get2() {
        return this._readableState.length;
      }, "get")
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    __name(fromList, "fromList");
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    __name(endReadable, "endReadable");
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    __name(endReadableNT, "endReadableNT");
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    __name(indexOf, "indexOf");
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    __name(afterTransform, "afterTransform");
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    __name(Transform, "Transform");
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    __name(prefinish, "prefinish");
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    __name(done, "done");
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    __name(PassThrough, "PassThrough");
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    __name(once, "once");
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    __name(noop, "noop");
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    __name(isRequest, "isRequest");
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    __name(destroyer, "destroyer");
    function call(fn) {
      fn();
    }
    __name(call, "call");
    function pipe(from, to) {
      return from.pipe(to);
    }
    __name(pipe, "pipe");
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    __name(popCallback, "popCallback");
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    __name(pipeline, "pipeline");
    module.exports = pipeline;
  }
});

// ../../node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js
var require_stream_browserify = __commonJS({
  "../../node_modules/.pnpm/stream-browserify@3.0.0/node_modules/stream-browserify/index.js"(exports, module) {
    module.exports = Stream;
    var EE = require_events().EventEmitter;
    var inherits = require_inherits_browser();
    inherits(Stream, EE);
    Stream.Readable = require_stream_readable();
    Stream.Writable = require_stream_writable();
    Stream.Duplex = require_stream_duplex();
    Stream.Transform = require_stream_transform();
    Stream.PassThrough = require_stream_passthrough();
    Stream.finished = require_end_of_stream();
    Stream.pipeline = require_pipeline();
    Stream.Stream = Stream;
    function Stream() {
      EE.call(this);
    }
    __name(Stream, "Stream");
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      __name(ondata, "ondata");
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      __name(ondrain, "ondrain");
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      __name(onend, "onend");
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      __name(onclose, "onclose");
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      __name(onerror, "onerror");
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      __name(cleanup, "cleanup");
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/stream.js
var require_stream = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Writable = exports.Readable = void 0;
    var node_stream_1 = require_stream_browserify();
    Object.defineProperty(exports, "Readable", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_stream_1.Readable;
    }, "get") });
    Object.defineProperty(exports, "Writable", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_stream_1.Writable;
    }, "get") });
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/events.js
var require_events2 = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/vendor/node/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventEmitter = void 0;
    var node_events_1 = require_events();
    Object.defineProperty(exports, "EventEmitter", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return node_events_1.EventEmitter;
    }, "get") });
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/FileHandle.js
var require_FileHandle = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/FileHandle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileHandle = void 0;
    var util_1 = require_util4();
    var events_1 = require_events2();
    var _FileHandle = class _FileHandle extends events_1.EventEmitter {
      constructor(fs, fd) {
        super();
        this.refs = 1;
        this.closePromise = null;
        this.position = 0;
        this.readableWebStreamLocked = false;
        this.fs = fs;
        this.fd = fd;
      }
      getAsyncId() {
        return this.fd;
      }
      appendFile(data, options) {
        return (0, util_1.promisify)(this.fs, "appendFile")(this.fd, data, options);
      }
      chmod(mode) {
        return (0, util_1.promisify)(this.fs, "fchmod")(this.fd, mode);
      }
      chown(uid, gid) {
        return (0, util_1.promisify)(this.fs, "fchown")(this.fd, uid, gid);
      }
      close() {
        if (this.fd === -1) {
          return Promise.resolve();
        }
        if (this.closePromise) {
          return this.closePromise;
        }
        this.refs--;
        if (this.refs === 0) {
          const currentFd = this.fd;
          this.fd = -1;
          this.closePromise = (0, util_1.promisify)(this.fs, "close")(currentFd).finally(() => {
            this.closePromise = null;
          });
        } else {
          this.closePromise = new Promise((resolve, reject) => {
            this.closeResolve = resolve;
            this.closeReject = reject;
          }).finally(() => {
            this.closePromise = null;
            this.closeReject = void 0;
            this.closeResolve = void 0;
          });
        }
        this.emit("close");
        return this.closePromise;
      }
      datasync() {
        return (0, util_1.promisify)(this.fs, "fdatasync")(this.fd);
      }
      createReadStream(options) {
        return this.fs.createReadStream("", { ...options, fd: this });
      }
      createWriteStream(options) {
        return this.fs.createWriteStream("", { ...options, fd: this });
      }
      readableWebStream(options = {}) {
        const { type = "bytes", autoClose = false } = options;
        let position = 0;
        if (this.fd === -1) {
          throw new Error("The FileHandle is closed");
        }
        if (this.closePromise) {
          throw new Error("The FileHandle is closing");
        }
        if (this.readableWebStreamLocked) {
          throw new Error("An error will be thrown if this method is called more than once or is called after the FileHandle is closed or closing.");
        }
        this.readableWebStreamLocked = true;
        this.ref();
        const unlockAndCleanup = /* @__PURE__ */ __name(() => {
          this.readableWebStreamLocked = false;
          this.unref();
          if (autoClose) {
            this.close().catch(() => {
            });
          }
        }, "unlockAndCleanup");
        return new ReadableStream({
          type: type === "bytes" ? "bytes" : void 0,
          autoAllocateChunkSize: 16384,
          pull: /* @__PURE__ */ __name(async (controller) => {
            try {
              const view = controller.byobRequest?.view;
              if (!view) {
                const buffer = new Uint8Array(16384);
                const result2 = await this.read(buffer, 0, buffer.length, position);
                if (result2.bytesRead === 0) {
                  controller.close();
                  unlockAndCleanup();
                  return;
                }
                position += result2.bytesRead;
                controller.enqueue(buffer.slice(0, result2.bytesRead));
                return;
              }
              const result = await this.read(view, view.byteOffset, view.byteLength, position);
              if (result.bytesRead === 0) {
                controller.close();
                unlockAndCleanup();
                return;
              }
              position += result.bytesRead;
              controller.byobRequest.respond(result.bytesRead);
            } catch (error) {
              controller.error(error);
              unlockAndCleanup();
            }
          }, "pull"),
          cancel: /* @__PURE__ */ __name(async () => {
            unlockAndCleanup();
          }, "cancel")
        });
      }
      async read(buffer, offset, length, position) {
        const readPosition = position !== null && position !== void 0 ? position : this.position;
        const result = await (0, util_1.promisify)(this.fs, "read", (bytesRead) => ({ bytesRead, buffer }))(this.fd, buffer, offset, length, readPosition);
        if (position === null || position === void 0) {
          this.position += result.bytesRead;
        }
        return result;
      }
      readv(buffers, position) {
        return (0, util_1.promisify)(this.fs, "readv", (bytesRead) => ({ bytesRead, buffers }))(this.fd, buffers, position);
      }
      readFile(options) {
        return (0, util_1.promisify)(this.fs, "readFile")(this.fd, options);
      }
      stat(options) {
        return (0, util_1.promisify)(this.fs, "fstat")(this.fd, options);
      }
      sync() {
        return (0, util_1.promisify)(this.fs, "fsync")(this.fd);
      }
      truncate(len) {
        return (0, util_1.promisify)(this.fs, "ftruncate")(this.fd, len);
      }
      utimes(atime, mtime) {
        return (0, util_1.promisify)(this.fs, "futimes")(this.fd, atime, mtime);
      }
      async write(buffer, offset, length, position) {
        const useInternalPosition = typeof position !== "number";
        const writePosition = useInternalPosition ? this.position : position;
        const result = await (0, util_1.promisify)(this.fs, "write", (bytesWritten) => ({ bytesWritten, buffer }))(this.fd, buffer, offset, length, writePosition);
        if (useInternalPosition) {
          this.position += result.bytesWritten;
        }
        return result;
      }
      writev(buffers, position) {
        return (0, util_1.promisify)(this.fs, "writev", (bytesWritten) => ({ bytesWritten, buffers }))(this.fd, buffers, position);
      }
      writeFile(data, options) {
        return (0, util_1.promisify)(this.fs, "writeFile")(this.fd, data, options);
      }
      // Implement Symbol.asyncDispose if available (ES2023+)
      async [Symbol.asyncDispose]() {
        await this.close();
      }
      ref() {
        this.refs++;
      }
      unref() {
        this.refs--;
        if (this.refs === 0) {
          this.fd = -1;
          if (this.closeResolve) {
            (0, util_1.promisify)(this.fs, "close")(this.fd).then(this.closeResolve, this.closeReject);
          }
        }
      }
    };
    __name(_FileHandle, "FileHandle");
    var FileHandle = _FileHandle;
    exports.FileHandle = FileHandle;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/FsPromises.js
var require_FsPromises = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/FsPromises.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FsPromises = void 0;
    var util_1 = require_util4();
    var constants_1 = require_constants();
    var _FSWatchAsyncIterator = class _FSWatchAsyncIterator {
      constructor(fs, path6, options = {}) {
        this.fs = fs;
        this.path = path6;
        this.options = options;
        this.eventQueue = [];
        this.resolveQueue = [];
        this.finished = false;
        this.maxQueue = options.maxQueue || 2048;
        this.overflow = options.overflow || "ignore";
        this.startWatching();
        if (options.signal) {
          if (options.signal.aborted) {
            this.finish();
            return;
          }
          options.signal.addEventListener("abort", () => {
            this.finish();
          });
        }
      }
      startWatching() {
        try {
          this.watcher = this.fs.watch(this.path, this.options, (eventType, filename) => {
            this.enqueueEvent({ eventType, filename });
          });
        } catch (error) {
          this.finish();
          throw error;
        }
      }
      enqueueEvent(event) {
        if (this.finished)
          return;
        if (this.eventQueue.length >= this.maxQueue) {
          if (this.overflow === "throw") {
            const error = new Error(`Watch queue overflow: more than ${this.maxQueue} events queued`);
            this.finish(error);
            return;
          } else {
            this.eventQueue.shift();
            console.warn(`Watch queue overflow: dropping event due to exceeding maxQueue of ${this.maxQueue}`);
          }
        }
        this.eventQueue.push(event);
        if (this.resolveQueue.length > 0) {
          const { resolve } = this.resolveQueue.shift();
          const nextEvent = this.eventQueue.shift();
          resolve({ value: nextEvent, done: false });
        }
      }
      finish(error) {
        if (this.finished)
          return;
        this.finished = true;
        if (this.watcher) {
          this.watcher.close();
          this.watcher = null;
        }
        while (this.resolveQueue.length > 0) {
          const { resolve, reject } = this.resolveQueue.shift();
          if (error) {
            reject(error);
          } else {
            resolve({ value: void 0, done: true });
          }
        }
      }
      async next() {
        if (this.finished) {
          return { value: void 0, done: true };
        }
        if (this.eventQueue.length > 0) {
          const event = this.eventQueue.shift();
          return { value: event, done: false };
        }
        return new Promise((resolve, reject) => {
          this.resolveQueue.push({ resolve, reject });
        });
      }
      async return() {
        this.finish();
        return { value: void 0, done: true };
      }
      async throw(error) {
        this.finish(error);
        throw error;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
    };
    __name(_FSWatchAsyncIterator, "FSWatchAsyncIterator");
    var FSWatchAsyncIterator = _FSWatchAsyncIterator;
    var _FsPromises = class _FsPromises {
      constructor(fs, FileHandle) {
        this.fs = fs;
        this.FileHandle = FileHandle;
        this.constants = constants_1.constants;
        this.cp = (0, util_1.promisify)(this.fs, "cp");
        this.opendir = (0, util_1.promisify)(this.fs, "opendir");
        this.statfs = (0, util_1.promisify)(this.fs, "statfs");
        this.lutimes = (0, util_1.promisify)(this.fs, "lutimes");
        this.glob = (0, util_1.promisify)(this.fs, "glob");
        this.access = (0, util_1.promisify)(this.fs, "access");
        this.chmod = (0, util_1.promisify)(this.fs, "chmod");
        this.chown = (0, util_1.promisify)(this.fs, "chown");
        this.copyFile = (0, util_1.promisify)(this.fs, "copyFile");
        this.lchmod = (0, util_1.promisify)(this.fs, "lchmod");
        this.lchown = (0, util_1.promisify)(this.fs, "lchown");
        this.link = (0, util_1.promisify)(this.fs, "link");
        this.lstat = (0, util_1.promisify)(this.fs, "lstat");
        this.mkdir = (0, util_1.promisify)(this.fs, "mkdir");
        this.mkdtemp = (0, util_1.promisify)(this.fs, "mkdtemp");
        this.readdir = (0, util_1.promisify)(this.fs, "readdir");
        this.readlink = (0, util_1.promisify)(this.fs, "readlink");
        this.realpath = (0, util_1.promisify)(this.fs, "realpath");
        this.rename = (0, util_1.promisify)(this.fs, "rename");
        this.rmdir = (0, util_1.promisify)(this.fs, "rmdir");
        this.rm = (0, util_1.promisify)(this.fs, "rm");
        this.stat = (0, util_1.promisify)(this.fs, "stat");
        this.symlink = (0, util_1.promisify)(this.fs, "symlink");
        this.truncate = (0, util_1.promisify)(this.fs, "truncate");
        this.unlink = (0, util_1.promisify)(this.fs, "unlink");
        this.utimes = (0, util_1.promisify)(this.fs, "utimes");
        this.readFile = (id, options) => {
          return (0, util_1.promisify)(this.fs, "readFile")(id instanceof this.FileHandle ? id.fd : id, options);
        };
        this.appendFile = (path6, data, options) => {
          return (0, util_1.promisify)(this.fs, "appendFile")(path6 instanceof this.FileHandle ? path6.fd : path6, data, options);
        };
        this.open = (path6, flags = "r", mode) => {
          return (0, util_1.promisify)(this.fs, "open", (fd) => new this.FileHandle(this.fs, fd))(path6, flags, mode);
        };
        this.writeFile = (id, data, options) => {
          const dataPromise = (0, util_1.isReadableStream)(data) ? (0, util_1.streamToBuffer)(data) : Promise.resolve(data);
          return dataPromise.then((data2) => (0, util_1.promisify)(this.fs, "writeFile")(id instanceof this.FileHandle ? id.fd : id, data2, options));
        };
        this.watch = (filename, options) => {
          const watchOptions = typeof options === "string" ? { encoding: options } : options || {};
          return new FSWatchAsyncIterator(this.fs, filename, watchOptions);
        };
      }
    };
    __name(_FsPromises, "FsPromises");
    var FsPromises = _FsPromises;
    exports.FsPromises = FsPromises;
  }
});

// ../../node_modules/.pnpm/tree-dump@1.1.0_tslib@2.8.1/node_modules/tree-dump/lib/printTree.js
var require_printTree = __commonJS({
  "../../node_modules/.pnpm/tree-dump@1.1.0_tslib@2.8.1/node_modules/tree-dump/lib/printTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printTree = void 0;
    var printTree = /* @__PURE__ */ __name((tab = "", children) => {
      let str = "";
      let last = children.length - 1;
      for (; last >= 0; last--)
        if (children[last])
          break;
      for (let i = 0; i <= last; i++) {
        const fn = children[i];
        if (!fn)
          continue;
        const isLast = i === last;
        const child = fn(tab + (isLast ? " " : "\u2502") + "  ");
        const branch = child ? isLast ? "\u2514\u2500" : "\u251C\u2500" : "\u2502";
        str += "\n" + tab + branch + (child ? " " + child : "");
      }
      return str;
    }, "printTree");
    exports.printTree = printTree;
  }
});

// ../../node_modules/.pnpm/tree-dump@1.1.0_tslib@2.8.1/node_modules/tree-dump/lib/printBinary.js
var require_printBinary = __commonJS({
  "../../node_modules/.pnpm/tree-dump@1.1.0_tslib@2.8.1/node_modules/tree-dump/lib/printBinary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printBinary = void 0;
    var printBinary = /* @__PURE__ */ __name((tab = "", children) => {
      const left = children[0], right = children[1];
      let str = "";
      if (left)
        str += "\n" + tab + "\u2190 " + left(tab + "  ");
      if (right)
        str += "\n" + tab + "\u2192 " + right(tab + "  ");
      return str;
    }, "printBinary");
    exports.printBinary = printBinary;
  }
});

// ../../node_modules/.pnpm/tree-dump@1.1.0_tslib@2.8.1/node_modules/tree-dump/lib/printJson.js
var require_printJson = __commonJS({
  "../../node_modules/.pnpm/tree-dump@1.1.0_tslib@2.8.1/node_modules/tree-dump/lib/printJson.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printJson = void 0;
    var printJson = /* @__PURE__ */ __name((tab = "", json, space = 2) => (JSON.stringify(json, null, space) || "nil").split("\n").join("\n" + tab), "printJson");
    exports.printJson = printJson;
  }
});

// ../../node_modules/.pnpm/tree-dump@1.1.0_tslib@2.8.1/node_modules/tree-dump/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/tree-dump@1.1.0_tslib@2.8.1/node_modules/tree-dump/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_printTree(), exports);
    tslib_1.__exportStar(require_printBinary(), exports);
    tslib_1.__exportStar(require_printJson(), exports);
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node-to-fsa/util.js
var require_util6 = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node-to-fsa/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newNotAllowedError = exports.newTypeMismatchError = exports.newNotFoundError = exports.assertCanWrite = exports.assertName = exports.basename = exports.ctx = void 0;
    var ctx = /* @__PURE__ */ __name((partial = {}) => {
      return {
        separator: "/",
        syncHandleAllowed: false,
        mode: "read",
        ...partial
      };
    }, "ctx");
    exports.ctx = ctx;
    var basename2 = /* @__PURE__ */ __name((path6, separator) => {
      if (path6[path6.length - 1] === separator)
        path6 = path6.slice(0, -1);
      const lastSlashIndex = path6.lastIndexOf(separator);
      return lastSlashIndex === -1 ? path6 : path6.slice(lastSlashIndex + 1);
    }, "basename");
    exports.basename = basename2;
    var nameRegex = /^(\.{1,2})$|^(.*([\/\\]).*)$/;
    var assertName = /* @__PURE__ */ __name((name, method, klass) => {
      const isInvalid = !name || nameRegex.test(name);
      if (isInvalid)
        throw new TypeError(`Failed to execute '${method}' on '${klass}': Name is not allowed.`);
    }, "assertName");
    exports.assertName = assertName;
    var assertCanWrite = /* @__PURE__ */ __name((mode) => {
      if (mode !== "readwrite")
        throw new DOMException("The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError");
    }, "assertCanWrite");
    exports.assertCanWrite = assertCanWrite;
    var newNotFoundError = /* @__PURE__ */ __name(() => new DOMException("A requested file or directory could not be found at the time an operation was processed.", "NotFoundError"), "newNotFoundError");
    exports.newNotFoundError = newNotFoundError;
    var newTypeMismatchError = /* @__PURE__ */ __name(() => new DOMException("The path supplied exists, but was not an entry of requested type.", "TypeMismatchError"), "newTypeMismatchError");
    exports.newTypeMismatchError = newTypeMismatchError;
    var newNotAllowedError = /* @__PURE__ */ __name(() => new DOMException("Permission not granted.", "NotAllowedError"), "newNotAllowedError");
    exports.newNotAllowedError = newNotAllowedError;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/print/index.js
var require_print = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/print/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toTreeSync = void 0;
    var tree_dump_1 = require_lib2();
    var util_1 = require_util6();
    var toTreeSync = /* @__PURE__ */ __name((fs, opts = {}) => {
      const separator = opts.separator || "/";
      let dir = opts.dir || separator;
      if (dir[dir.length - 1] !== separator)
        dir += separator;
      const tab = opts.tab || "";
      const depth = opts.depth ?? 10;
      let subtree = " (...)";
      if (depth > 0) {
        const list = fs.readdirSync(dir, { withFileTypes: true });
        subtree = (0, tree_dump_1.printTree)(tab, list.map((entry) => (tab2) => {
          if (entry.isDirectory()) {
            return (0, exports.toTreeSync)(fs, { dir: dir + entry.name, depth: depth - 1, tab: tab2 });
          } else if (entry.isSymbolicLink()) {
            return "" + entry.name + " \u2192 " + fs.readlinkSync(dir + entry.name);
          } else {
            return "" + entry.name;
          }
        }));
      }
      const base = (0, util_1.basename)(dir, separator) + separator;
      return base + subtree;
    }, "toTreeSync");
    exports.toTreeSync = toTreeSync;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/options.js
var require_options = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWriteFileOptions = exports.writeFileDefaults = exports.getRealpathOptsAndCb = exports.getRealpathOptions = exports.getStatfsOptsAndCb = exports.getStatfsOptions = exports.getStatOptsAndCb = exports.getStatOptions = exports.getAppendFileOptsAndCb = exports.getAppendFileOpts = exports.getOpendirOptsAndCb = exports.getOpendirOptions = exports.getReaddirOptsAndCb = exports.getReaddirOptions = exports.getReadFileOptions = exports.getRmOptsAndCb = exports.getRmdirOptions = exports.getDefaultOptsAndCb = exports.getDefaultOpts = exports.optsDefaults = exports.getMkdirOptions = void 0;
    exports.getOptions = getOptions;
    exports.optsGenerator = optsGenerator;
    exports.optsAndCbGenerator = optsAndCbGenerator;
    var constants_1 = require_constants2();
    var encoding_1 = require_encoding();
    var util_1 = require_util4();
    var mkdirDefaults = {
      mode: 511,
      recursive: false
    };
    var getMkdirOptions = /* @__PURE__ */ __name((options) => {
      if (typeof options === "number")
        return Object.assign({}, mkdirDefaults, { mode: options });
      return Object.assign({}, mkdirDefaults, options);
    }, "getMkdirOptions");
    exports.getMkdirOptions = getMkdirOptions;
    var ERRSTR_OPTS = /* @__PURE__ */ __name((tipeof) => `Expected options to be either an object or a string, but got ${tipeof} instead`, "ERRSTR_OPTS");
    function getOptions(defaults, options) {
      let opts;
      if (!options)
        return defaults;
      else {
        const tipeof = typeof options;
        switch (tipeof) {
          case "string":
            opts = Object.assign({}, defaults, { encoding: options });
            break;
          case "object":
            opts = Object.assign({}, defaults, options);
            break;
          default:
            throw TypeError(ERRSTR_OPTS(tipeof));
        }
      }
      if (opts.encoding !== "buffer")
        (0, encoding_1.assertEncoding)(opts.encoding);
      return opts;
    }
    __name(getOptions, "getOptions");
    function optsGenerator(defaults) {
      return (options) => getOptions(defaults, options);
    }
    __name(optsGenerator, "optsGenerator");
    function optsAndCbGenerator(getOpts) {
      return (options, callback) => typeof options === "function" ? [getOpts(), options] : [getOpts(options), (0, util_1.validateCallback)(callback)];
    }
    __name(optsAndCbGenerator, "optsAndCbGenerator");
    exports.optsDefaults = {
      encoding: "utf8"
    };
    exports.getDefaultOpts = optsGenerator(exports.optsDefaults);
    exports.getDefaultOptsAndCb = optsAndCbGenerator(exports.getDefaultOpts);
    var rmdirDefaults = {
      recursive: false
    };
    var getRmdirOptions = /* @__PURE__ */ __name((options) => {
      return Object.assign({}, rmdirDefaults, options);
    }, "getRmdirOptions");
    exports.getRmdirOptions = getRmdirOptions;
    var getRmOpts = optsGenerator(exports.optsDefaults);
    exports.getRmOptsAndCb = optsAndCbGenerator(getRmOpts);
    var readFileOptsDefaults = {
      flag: "r"
    };
    exports.getReadFileOptions = optsGenerator(readFileOptsDefaults);
    var readdirDefaults = {
      encoding: "utf8",
      recursive: false,
      withFileTypes: false
    };
    exports.getReaddirOptions = optsGenerator(readdirDefaults);
    exports.getReaddirOptsAndCb = optsAndCbGenerator(exports.getReaddirOptions);
    var opendirDefaults = {
      encoding: "utf8",
      bufferSize: 32,
      recursive: false
    };
    exports.getOpendirOptions = optsGenerator(opendirDefaults);
    exports.getOpendirOptsAndCb = optsAndCbGenerator(exports.getOpendirOptions);
    var appendFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: constants_1.FLAGS[constants_1.FLAGS.a]
    };
    exports.getAppendFileOpts = optsGenerator(appendFileDefaults);
    exports.getAppendFileOptsAndCb = optsAndCbGenerator(exports.getAppendFileOpts);
    var statDefaults = {
      bigint: false
    };
    var getStatOptions = /* @__PURE__ */ __name((options = {}) => Object.assign({}, statDefaults, options), "getStatOptions");
    exports.getStatOptions = getStatOptions;
    var getStatOptsAndCb = /* @__PURE__ */ __name((options, callback) => typeof options === "function" ? [(0, exports.getStatOptions)(), options] : [(0, exports.getStatOptions)(options), (0, util_1.validateCallback)(callback)], "getStatOptsAndCb");
    exports.getStatOptsAndCb = getStatOptsAndCb;
    var statfsDefaults = {
      bigint: false
    };
    var getStatfsOptions = /* @__PURE__ */ __name((options = {}) => Object.assign({}, statfsDefaults, options), "getStatfsOptions");
    exports.getStatfsOptions = getStatfsOptions;
    var getStatfsOptsAndCb = /* @__PURE__ */ __name((options, callback) => typeof options === "function" ? [(0, exports.getStatfsOptions)(), options] : [(0, exports.getStatfsOptions)(options), (0, util_1.validateCallback)(callback)], "getStatfsOptsAndCb");
    exports.getStatfsOptsAndCb = getStatfsOptsAndCb;
    var realpathDefaults = exports.optsDefaults;
    exports.getRealpathOptions = optsGenerator(realpathDefaults);
    exports.getRealpathOptsAndCb = optsAndCbGenerator(exports.getRealpathOptions);
    exports.writeFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: constants_1.FLAGS[constants_1.FLAGS.w]
    };
    exports.getWriteFileOptions = optsGenerator(exports.writeFileDefaults);
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/Dir.js
var require_Dir = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/Dir.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dir = void 0;
    var util_1 = require_util4();
    var Dirent_1 = require_Dirent();
    var errors = require_errors();
    var _Dir = class _Dir {
      constructor(link, options) {
        this.link = link;
        this.options = options;
        this.iteratorInfo = [];
        this.closed = false;
        this.operationQueue = null;
        this.path = link.getPath();
        this.iteratorInfo.push(link.children[Symbol.iterator]());
      }
      closeBase() {
      }
      readBase(iteratorInfo) {
        let done;
        let value;
        let name;
        let link;
        do {
          do {
            ({ done, value } = iteratorInfo[iteratorInfo.length - 1].next());
            if (!done) {
              [name, link] = value;
            } else {
              break;
            }
          } while (name === "." || name === "..");
          if (done) {
            iteratorInfo.pop();
            if (iteratorInfo.length === 0) {
              break;
            } else {
              done = false;
            }
          } else {
            if (this.options.recursive && link.children.size) {
              iteratorInfo.push(link.children[Symbol.iterator]());
            }
            return Dirent_1.default.build(link, this.options.encoding);
          }
        } while (!done);
        return null;
      }
      close(callback) {
        if (callback === void 0) {
          if (this.closed) {
            return Promise.reject(new errors.Error("ERR_DIR_CLOSED"));
          }
          return new Promise((resolve, reject) => {
            this.close((err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
          });
        }
        (0, util_1.validateCallback)(callback);
        if (this.closed) {
          process.nextTick(callback, new errors.Error("ERR_DIR_CLOSED"));
          return;
        }
        if (this.operationQueue !== null) {
          this.operationQueue.push(() => {
            this.close(callback);
          });
          return;
        }
        this.closed = true;
        try {
          this.closeBase();
          process.nextTick(callback);
        } catch (err) {
          process.nextTick(callback, err);
        }
      }
      closeSync() {
        if (this.closed) {
          throw new errors.Error("ERR_DIR_CLOSED");
        }
        if (this.operationQueue !== null) {
          throw new errors.Error("ERR_DIR_CONCURRENT_OPERATION");
        }
        this.closed = true;
        this.closeBase();
      }
      read(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.read((err, result) => {
              if (err)
                reject(err);
              else
                resolve(result ?? null);
            });
          });
        }
        (0, util_1.validateCallback)(callback);
        if (this.closed) {
          process.nextTick(callback, new errors.Error("ERR_DIR_CLOSED"));
          return;
        }
        if (this.operationQueue !== null) {
          this.operationQueue.push(() => {
            this.read(callback);
          });
          return;
        }
        this.operationQueue = [];
        try {
          const result = this.readBase(this.iteratorInfo);
          process.nextTick(() => {
            const queue = this.operationQueue;
            this.operationQueue = null;
            for (const op of queue)
              op();
            callback(null, result);
          });
        } catch (err) {
          process.nextTick(() => {
            const queue = this.operationQueue;
            this.operationQueue = null;
            for (const op of queue)
              op();
            callback(err);
          });
        }
      }
      readSync() {
        if (this.closed) {
          throw new errors.Error("ERR_DIR_CLOSED");
        }
        if (this.operationQueue !== null) {
          throw new errors.Error("ERR_DIR_CONCURRENT_OPERATION");
        }
        return this.readBase(this.iteratorInfo);
      }
      [Symbol.asyncIterator]() {
        return {
          next: /* @__PURE__ */ __name(async () => {
            try {
              const dirEnt = await this.read();
              if (dirEnt !== null) {
                return { done: false, value: dirEnt };
              } else {
                return { done: true, value: void 0 };
              }
            } catch (err) {
              throw err;
            }
          }, "next"),
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
    };
    __name(_Dir, "Dir");
    var Dir = _Dir;
    exports.Dir = Dir;
  }
});

// ../../node_modules/.pnpm/glob-to-regex.js@1.2.0_tslib@2.8.1/node_modules/glob-to-regex.js/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/.pnpm/glob-to-regex.js@1.2.0_tslib@2.8.1/node_modules/glob-to-regex.js/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toMatcher = exports.toRegex = void 0;
    var escapeRe = /* @__PURE__ */ __name((ch) => /[.^$+{}()|\\]/.test(ch) ? `\\${ch}` : ch, "escapeRe");
    var parseExtGlob = /* @__PURE__ */ __name((pattern, startIdx, prefix, options) => {
      let i = startIdx;
      const parts = [];
      let cur = "";
      let depth = 1;
      while (i < pattern.length && depth > 0) {
        const ch = pattern[i];
        if (ch === "(") {
          depth++;
          cur += ch;
          i++;
        } else if (ch === ")") {
          depth--;
          if (depth === 0) {
            parts.push(cur);
            i++;
            break;
          } else {
            cur += ch;
            i++;
          }
        } else if (ch === "|" && depth === 1) {
          parts.push(cur);
          cur = "";
          i++;
        } else {
          cur += ch;
          i++;
        }
      }
      if (depth !== 0)
        return;
      let alternatives = "";
      const length = parts.length;
      for (let j = 0; j < length; j++)
        alternatives += (alternatives ? "|" : "") + (0, exports.toRegex)(parts[j], options).source.replace(/^\^/, "").replace(/\$$/, "");
      switch (prefix) {
        case "?":
          return [`(?:${alternatives})?`, i];
        case "*":
          return [`(?:${alternatives})*`, i];
        case "+":
          return [`(?:${alternatives})+`, i];
        case "@":
          return [`(?:${alternatives})`, i];
        case "!":
          return [`(?!${alternatives})[^/]*`, i];
      }
      return;
    }, "parseExtGlob");
    var toRegex = /* @__PURE__ */ __name((pattern, options) => {
      let regexStr = "";
      let i = 0;
      const parseBraceGroup = /* @__PURE__ */ __name(() => {
        i++;
        const parts = [];
        let cur = "";
        let closed = false;
        while (i < pattern.length) {
          const ch = pattern[i];
          if (ch === "}") {
            parts.push(cur);
            i++;
            closed = true;
            break;
          }
          if (ch === ",") {
            parts.push(cur);
            cur = "";
            i++;
            continue;
          }
          cur += ch;
          i++;
        }
        if (!closed) {
          return "\\{" + escapeRe(cur);
        }
        const alt = parts.map((p) => (0, exports.toRegex)(p, options).source.replace(/^\^/, "").replace(/\$$/, "")).join("|");
        return `(?:${alt})`;
      }, "parseBraceGroup");
      const extglob = !!options?.extglob;
      while (i < pattern.length) {
        const char = pattern[i];
        if (extglob && pattern[i + 1] === "(") {
          if (char === "?" || char === "*" || char === "+" || char === "@" || char === "!") {
            const result = parseExtGlob(pattern, i + 2, char, options);
            if (result) {
              regexStr += result[0];
              i = result[1];
              continue;
            }
          }
        }
        switch (char) {
          case "*": {
            if (pattern[i + 1] === "*") {
              let j = i + 2;
              while (pattern[j] === "*")
                j++;
              if (pattern[j] === "/") {
                regexStr += "(?:.*/)?";
                i = j + 1;
              } else {
                regexStr += ".*";
                i = j;
              }
            } else {
              regexStr += "[^/]*";
              i++;
            }
            break;
          }
          case "?":
            regexStr += "[^/]";
            i++;
            break;
          case "[": {
            let cls = "[";
            i++;
            if (i < pattern.length && pattern[i] === "!") {
              cls += "^";
              i++;
            }
            if (i < pattern.length && pattern[i] === "]") {
              cls += "]";
              i++;
            }
            while (i < pattern.length && pattern[i] !== "]") {
              const ch = pattern[i];
              cls += ch === "\\" ? "\\\\" : ch;
              i++;
            }
            if (i < pattern.length && pattern[i] === "]") {
              cls += "]";
              i++;
            } else {
              regexStr += "\\[";
              continue;
            }
            regexStr += cls;
            break;
          }
          case "{": {
            regexStr += parseBraceGroup();
            break;
          }
          case "/":
            regexStr += "/";
            i++;
            break;
          case ".":
          case "^":
          case "$":
          case "+":
          case "(":
          case ")":
          case "|":
          case "\\":
            regexStr += `\\${char}`;
            i++;
            break;
          default:
            regexStr += char;
            i++;
            break;
        }
      }
      const flags = options?.nocase ? "i" : "";
      return new RegExp("^" + regexStr + "$", flags);
    }, "toRegex");
    exports.toRegex = toRegex;
    var isRegExp = /^\/(.{1,4096})\/([gimsuy]{0,6})$/;
    var toMatcher = /* @__PURE__ */ __name((pattern, options) => {
      const regexes = [];
      const patterns = Array.isArray(pattern) ? pattern : [pattern];
      for (const pat of patterns) {
        if (typeof pat === "string") {
          const match = isRegExp.exec(pat);
          if (match) {
            const [, expr, flags] = match;
            regexes.push(new RegExp(expr, flags));
          } else {
            regexes.push((0, exports.toRegex)(pat, options));
          }
        } else {
          regexes.push(pat);
        }
      }
      return regexes.length ? new Function("p", "return " + regexes.map((r) => r + ".test(p)").join("||")) : () => false;
    }, "toMatcher");
    exports.toMatcher = toMatcher;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/glob.js
var require_glob = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/glob.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globSync = globSync;
    var path_1 = require_path();
    var glob_to_regex_js_1 = require_lib3();
    var util_1 = require_util4();
    var pathJoin = path_1.posix.join;
    var pathRelative = path_1.posix.relative;
    var pathResolve = path_1.posix.resolve;
    function matchesPattern(path6, pattern) {
      const regex = (0, glob_to_regex_js_1.toRegex)(pattern);
      return regex.test(path6);
    }
    __name(matchesPattern, "matchesPattern");
    function isExcluded(path6, exclude) {
      if (!exclude)
        return false;
      if (typeof exclude === "function") {
        return exclude(path6);
      }
      const patterns = Array.isArray(exclude) ? exclude : [exclude];
      return patterns.some((pattern) => matchesPattern(path6, pattern));
    }
    __name(isExcluded, "isExcluded");
    function walkDirectory(fs, dir, patterns, options, currentDepth = 0) {
      const results = [];
      const maxDepth = options.maxdepth ?? Infinity;
      const baseCwd = options.cwd ? (0, util_1.pathToFilename)(options.cwd) : process.cwd();
      if (currentDepth > maxDepth) {
        return results;
      }
      try {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        for (const entry of entries) {
          const fullPath = pathJoin(dir, entry.name.toString());
          const relativePath = pathRelative(baseCwd, fullPath);
          if (isExcluded(relativePath, options.exclude)) {
            continue;
          }
          const matches = patterns.some((pattern) => matchesPattern(relativePath, pattern));
          if (matches) {
            results.push(relativePath);
          }
          if (entry.isDirectory() && currentDepth < maxDepth) {
            const subResults = walkDirectory(fs, fullPath, patterns, options, currentDepth + 1);
            results.push(...subResults);
          }
        }
      } catch (err) {
      }
      return results;
    }
    __name(walkDirectory, "walkDirectory");
    function globSync(fs, pattern, options = {}) {
      const cwd = options.cwd ? (0, util_1.pathToFilename)(options.cwd) : process.cwd();
      const resolvedCwd = pathResolve(cwd);
      const globOptions = {
        cwd: resolvedCwd,
        exclude: options.exclude,
        maxdepth: options.maxdepth,
        withFileTypes: options.withFileTypes || false
      };
      let results = [];
      if (path_1.posix.isAbsolute(pattern)) {
        const dir = path_1.posix.dirname(pattern);
        const patternBasename = path_1.posix.basename(pattern);
        const dirResults = walkDirectory(fs, dir, [patternBasename], { ...globOptions, cwd: dir });
        results.push(...dirResults.map((r) => path_1.posix.resolve(dir, r)));
      } else {
        const dirResults = walkDirectory(fs, resolvedCwd, [pattern], globOptions);
        results.push(...dirResults);
      }
      results = [...new Set(results)].sort();
      return results;
    }
    __name(globSync, "globSync");
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/volume.js
var require_volume = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/volume.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FSWatcher = exports.StatWatcher = exports.Volume = void 0;
    exports.pathToSteps = pathToSteps;
    exports.dataToStr = dataToStr;
    exports.toUnixTimestamp = toUnixTimestamp;
    var path_1 = require_path();
    var core_1 = require_core();
    var Stats_1 = require_Stats();
    var Dirent_1 = require_Dirent();
    var StatFs_1 = require_StatFs();
    var buffer_1 = require_buffer3();
    var queueMicrotask_1 = require_queueMicrotask();
    var setTimeoutUnref_1 = require_setTimeoutUnref();
    var stream_1 = require_stream();
    var constants_1 = require_constants();
    var events_1 = require_events2();
    var encoding_1 = require_encoding();
    var FileHandle_1 = require_FileHandle();
    var util_1 = require_util();
    var FsPromises_1 = require_FsPromises();
    var print_1 = require_print();
    var constants_2 = require_constants2();
    var errors = require_errors();
    var options_1 = require_options();
    var util_2 = require_util4();
    var Dir_1 = require_Dir();
    var util_3 = require_util2();
    var resolveCrossPlatform = path_1.resolve;
    var { O_SYMLINK, F_OK, R_OK, W_OK, X_OK, COPYFILE_EXCL, COPYFILE_FICLONE_FORCE } = constants_1.constants;
    var pathSep = path_1.posix ? path_1.posix.sep : path_1.sep;
    var pathRelative = path_1.posix ? path_1.posix.relative : path_1.relative;
    var pathJoin = path_1.posix ? path_1.posix.join : path_1.join;
    var pathDirname = path_1.posix ? path_1.posix.dirname : path_1.dirname;
    var pathNormalize = path_1.posix ? path_1.posix.normalize : path_1.normalize;
    var kMinPoolSpace = 128;
    function pathToSteps(path6) {
      return (0, util_3.filenameToSteps)((0, util_2.pathToFilename)(path6));
    }
    __name(pathToSteps, "pathToSteps");
    function dataToStr(data, encoding = encoding_1.ENCODING_UTF8) {
      if (buffer_1.Buffer.isBuffer(data))
        return data.toString(encoding);
      else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data).toString(encoding);
      else
        return String(data);
    }
    __name(dataToStr, "dataToStr");
    function toUnixTimestamp(time) {
      if (typeof time === "string" && +time == time) {
        return +time;
      }
      if (time instanceof Date) {
        return time.getTime() / 1e3;
      }
      if (isFinite(time)) {
        if (time < 0) {
          return Date.now() / 1e3;
        }
        return time;
      }
      throw new Error("Cannot parse time: " + time);
    }
    __name(toUnixTimestamp, "toUnixTimestamp");
    function validateUid(uid) {
      if (typeof uid !== "number")
        throw TypeError(constants_2.ERRSTR.UID);
    }
    __name(validateUid, "validateUid");
    function validateGid(gid) {
      if (typeof gid !== "number")
        throw TypeError(constants_2.ERRSTR.GID);
    }
    __name(validateGid, "validateGid");
    var _Volume = class _Volume {
      get promises() {
        if (this.promisesApi === null)
          throw new Error("Promise is not supported in this environment.");
        return this.promisesApi;
      }
      constructor(_core = new core_1.Superblock()) {
        this._core = _core;
        this.promisesApi = new FsPromises_1.FsPromises(this, FileHandle_1.FileHandle);
        this.openSync = (path6, flags, mode = 438) => {
          const modeNum = (0, util_2.modeToNumber)(mode);
          const fileName = (0, util_2.pathToFilename)(path6);
          const flagsNum = (0, util_2.flagsToNumber)(flags);
          return this._core.open(fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK));
        };
        this.open = (path6, flags, a, b) => {
          let mode = a;
          let callback = b;
          if (typeof a === "function") {
            mode = 438;
            callback = a;
          }
          mode = mode || 438;
          const modeNum = (0, util_2.modeToNumber)(mode);
          const fileName = (0, util_2.pathToFilename)(path6);
          const flagsNum = (0, util_2.flagsToNumber)(flags);
          this.wrapAsync(this._core.open, [fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK)], callback);
        };
        this.closeSync = (fd) => {
          this._core.close(fd);
        };
        this.close = (fd, callback) => {
          (0, util_3.validateFd)(fd);
          const file = this._core.getFileByFdOrThrow(fd, "close");
          this.wrapAsync(this._core.close, [file.fd], callback);
        };
        this.readSync = (fd, buffer, offset, length, position) => {
          (0, util_3.validateFd)(fd);
          return this._core.read(fd, buffer, offset, length, position);
        };
        this.read = (fd, buffer, offset, length, position, callback) => {
          (0, util_2.validateCallback)(callback);
          if (length === 0) {
            return (0, queueMicrotask_1.default)(() => {
              if (callback)
                callback(null, 0, buffer);
            });
          }
          Promise.resolve().then(() => {
            try {
              const bytes = this._core.read(fd, buffer, offset, length, position);
              callback(null, bytes, buffer);
            } catch (err) {
              callback(err);
            }
          });
        };
        this.readv = (fd, buffers, a, b) => {
          let position = a;
          let callback = b;
          if (typeof a === "function")
            [position, callback] = [null, a];
          (0, util_2.validateCallback)(callback);
          Promise.resolve().then(() => {
            try {
              const bytes = this._core.readv(fd, buffers, position);
              callback(null, bytes, buffers);
            } catch (err) {
              callback(err);
            }
          });
        };
        this.readvSync = (fd, buffers, position) => {
          (0, util_3.validateFd)(fd);
          return this._core.readv(fd, buffers, position ?? null);
        };
        this._readfile = (id, flagsNum, encoding) => {
          let result;
          const isUserFd = typeof id === "number";
          const userOwnsFd = isUserFd && (0, util_3.isFd)(id);
          let fd;
          if (userOwnsFd)
            fd = id;
          else {
            const filename = (0, util_2.pathToFilename)(id);
            const originalPath = String(id);
            const hasTrailingSlash = originalPath.length > 1 && originalPath.endsWith("/");
            const link = this._core.getResolvedLinkOrThrow(filename, "open");
            const node = link.getNode();
            if (node.isDirectory())
              throw (0, util_2.createError)("EISDIR", "open", link.getPath());
            if (hasTrailingSlash && node.isFile()) {
              throw (0, util_2.createError)("ENOTDIR", "open", originalPath);
            }
            fd = this.openSync(id, flagsNum);
          }
          try {
            result = (0, util_2.bufferToEncoding)(this._core.getFileByFdOrThrow(fd).getBuffer(), encoding);
          } finally {
            if (!userOwnsFd) {
              this.closeSync(fd);
            }
          }
          return result;
        };
        this.readFileSync = (file, options) => {
          const opts = (0, options_1.getReadFileOptions)(options);
          const flagsNum = (0, util_2.flagsToNumber)(opts.flag);
          return this._readfile(file, flagsNum, opts.encoding);
        };
        this.readFile = (id, a, b) => {
          const [opts, callback] = (0, options_1.optsAndCbGenerator)(options_1.getReadFileOptions)(a, b);
          const flagsNum = (0, util_2.flagsToNumber)(opts.flag);
          this.wrapAsync(this._readfile, [id, flagsNum, opts.encoding], callback);
        };
        this.writeSync = (fd, a, b, c, d) => {
          const [, buf, offset, length, position] = (0, util_2.getWriteSyncArgs)(fd, a, b, c, d);
          return this._write(fd, buf, offset, length, position);
        };
        this.write = (fd, a, b, c, d, e) => {
          const [, asStr, buf, offset, length, position, cb] = (0, util_2.getWriteArgs)(fd, a, b, c, d, e);
          Promise.resolve().then(() => {
            try {
              const bytes = this._write(fd, buf, offset, length, position);
              if (!asStr) {
                cb(null, bytes, buf);
              } else {
                cb(null, bytes, a);
              }
            } catch (err) {
              cb(err);
            }
          });
        };
        this.writev = (fd, buffers, a, b) => {
          let position = a;
          let callback = b;
          if (typeof a === "function")
            [position, callback] = [null, a];
          (0, util_2.validateCallback)(callback);
          Promise.resolve().then(() => {
            try {
              const bytes = this.writevBase(fd, buffers, position);
              callback(null, bytes, buffers);
            } catch (err) {
              callback(err);
            }
          });
        };
        this.writevSync = (fd, buffers, position) => {
          (0, util_3.validateFd)(fd);
          return this.writevBase(fd, buffers, position ?? null);
        };
        this.writeFileSync = (id, data, options) => {
          const opts = (0, options_1.getWriteFileOptions)(options);
          const flagsNum = (0, util_2.flagsToNumber)(opts.flag);
          const modeNum = (0, util_2.modeToNumber)(opts.mode);
          const buf = (0, util_3.dataToBuffer)(data, opts.encoding);
          this._core.writeFile(id, buf, flagsNum, modeNum);
        };
        this.writeFile = (id, data, a, b) => {
          let options = a;
          let callback = b;
          if (typeof a === "function")
            [options, callback] = [options_1.writeFileDefaults, a];
          const cb = (0, util_2.validateCallback)(callback);
          const opts = (0, options_1.getWriteFileOptions)(options);
          const flagsNum = (0, util_2.flagsToNumber)(opts.flag);
          const modeNum = (0, util_2.modeToNumber)(opts.mode);
          const buf = (0, util_3.dataToBuffer)(data, opts.encoding);
          this.wrapAsync(this._core.writeFile, [id, buf, flagsNum, modeNum], cb);
        };
        this.copyFileSync = (src, dest, flags) => {
          const srcFilename = (0, util_2.pathToFilename)(src);
          const destFilename = (0, util_2.pathToFilename)(dest);
          return this._copyFile(srcFilename, destFilename, (flags || 0) | 0);
        };
        this.copyFile = (src, dest, a, b) => {
          const srcFilename = (0, util_2.pathToFilename)(src);
          const destFilename = (0, util_2.pathToFilename)(dest);
          let flags;
          let callback;
          if (typeof a === "function")
            [flags, callback] = [0, a];
          else
            [flags, callback] = [a, b];
          (0, util_2.validateCallback)(callback);
          this.wrapAsync(this._copyFile, [srcFilename, destFilename, flags], callback);
        };
        this._cp = (src, dest, options) => {
          if (options.filter && !options.filter(src, dest))
            return;
          const srcStat = options.dereference ? this.statSync(src) : this.lstatSync(src);
          let destStat = null;
          try {
            destStat = this.lstatSync(dest);
          } catch (err) {
            if (err.code !== "ENOENT") {
              throw err;
            }
          }
          if (destStat && srcStat.ino === destStat.ino && srcStat.dev === destStat.dev)
            throw (0, util_2.createError)("EINVAL", "cp", src, dest);
          if (destStat) {
            if (srcStat.isDirectory() && !destStat.isDirectory())
              throw (0, util_2.createError)("EISDIR", "cp", src, dest);
            if (!srcStat.isDirectory() && destStat.isDirectory())
              throw (0, util_2.createError)("ENOTDIR", "cp", src, dest);
          }
          if (srcStat.isDirectory() && this.isSrcSubdir(src, dest))
            throw (0, util_2.createError)("EINVAL", "cp", src, dest);
          ENDURE_PARENT_DIR_EXISTS: {
            const parent = pathDirname(dest);
            if (!this.existsSync(parent))
              this.mkdirSync(parent, { recursive: true });
          }
          if (srcStat.isDirectory()) {
            if (!options.recursive)
              throw (0, util_2.createError)("EISDIR", "cp", src);
            this.cpDirSync(srcStat, destStat, src, dest, options);
          } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {
            this.cpFileSync(srcStat, destStat, src, dest, options);
          } else if (srcStat.isSymbolicLink() && !options.dereference) {
            this.cpSymlinkSync(destStat, src, dest, options);
          } else {
            throw (0, util_2.createError)("EINVAL", "cp", src);
          }
        };
        this.linkSync = (existingPath, newPath) => {
          const existingPathFilename = (0, util_2.pathToFilename)(existingPath);
          const newPathFilename = (0, util_2.pathToFilename)(newPath);
          this._core.link(existingPathFilename, newPathFilename);
        };
        this.link = (existingPath, newPath, callback) => {
          const existingPathFilename = (0, util_2.pathToFilename)(existingPath);
          const newPathFilename = (0, util_2.pathToFilename)(newPath);
          this.wrapAsync(this._core.link, [existingPathFilename, newPathFilename], callback);
        };
        this.unlinkSync = (path6) => {
          const filename = (0, util_2.pathToFilename)(path6);
          this._core.unlink(filename);
        };
        this.unlink = (path6, callback) => {
          const filename = (0, util_2.pathToFilename)(path6);
          this.wrapAsync(this._core.unlink, [filename], callback);
        };
        this.symlinkSync = (target, path6, type) => {
          const targetFilename = (0, util_2.pathToFilename)(target);
          const pathFilename = (0, util_2.pathToFilename)(path6);
          this._core.symlink(targetFilename, pathFilename);
        };
        this.symlink = (target, path6, a, b) => {
          const callback = (0, util_2.validateCallback)(typeof a === "function" ? a : b);
          const targetFilename = (0, util_2.pathToFilename)(target);
          const pathFilename = (0, util_2.pathToFilename)(path6);
          this.wrapAsync(this._core.symlink, [targetFilename, pathFilename], callback);
        };
        this._lstat = (filename, bigint = false, throwIfNoEntry = false) => {
          let link;
          try {
            link = this._core.getLinkOrThrow(filename, "lstat");
          } catch (err) {
            if (err.code === "ENOENT" && !throwIfNoEntry)
              return void 0;
            else
              throw err;
          }
          return Stats_1.default.build(link.getNode(), bigint);
        };
        this.lstatSync = (path6, options) => {
          const { throwIfNoEntry = true, bigint = false } = (0, options_1.getStatOptions)(options);
          return this._lstat((0, util_2.pathToFilename)(path6), bigint, throwIfNoEntry);
        };
        this.renameSync = (oldPath, newPath) => {
          const oldPathFilename = (0, util_2.pathToFilename)(oldPath);
          const newPathFilename = (0, util_2.pathToFilename)(newPath);
          this._core.rename(oldPathFilename, newPathFilename);
        };
        this.rename = (oldPath, newPath, callback) => {
          const oldPathFilename = (0, util_2.pathToFilename)(oldPath);
          const newPathFilename = (0, util_2.pathToFilename)(newPath);
          this.wrapAsync(this._core.rename, [oldPathFilename, newPathFilename], callback);
        };
        this.existsSync = (path6) => {
          try {
            return this._exists((0, util_2.pathToFilename)(path6));
          } catch (err) {
            return false;
          }
        };
        this.exists = (path6, callback) => {
          const filename = (0, util_2.pathToFilename)(path6);
          if (typeof callback !== "function")
            throw Error(constants_2.ERRSTR.CB);
          Promise.resolve().then(() => {
            try {
              callback(this._exists(filename));
            } catch (err) {
              callback(false);
            }
          });
        };
        this.accessSync = (path6, mode = F_OK) => {
          const filename = (0, util_2.pathToFilename)(path6);
          mode = mode | 0;
          this._access(filename, mode);
        };
        this.access = (path6, a, b) => {
          let mode = F_OK;
          let callback;
          if (typeof a !== "function")
            [mode, callback] = [a | 0, (0, util_2.validateCallback)(b)];
          else
            callback = a;
          const filename = (0, util_2.pathToFilename)(path6);
          this.wrapAsync(this._access, [filename, mode], callback);
        };
        this.appendFileSync = (id, data, options) => {
          const opts = (0, options_1.getAppendFileOpts)(options);
          if (!opts.flag || (0, util_3.isFd)(id))
            opts.flag = "a";
          this.writeFileSync(id, data, opts);
        };
        this.appendFile = (id, data, a, b) => {
          const [opts, callback] = (0, options_1.getAppendFileOptsAndCb)(a, b);
          if (!opts.flag || (0, util_3.isFd)(id))
            opts.flag = "a";
          this.writeFile(id, data, opts, callback);
        };
        this._readdir = (filename, options) => {
          const steps = (0, util_3.filenameToSteps)(filename);
          const link = this._core.getResolvedLinkOrThrow(filename, "scandir");
          const node = link.getNode();
          if (!node.isDirectory())
            throw (0, util_2.createError)("ENOTDIR", "scandir", filename);
          if (!node.canRead())
            throw (0, util_2.createError)("EACCES", "scandir", filename);
          const list = [];
          for (const name of link.children.keys()) {
            const child = link.getChild(name);
            if (!child || name === "." || name === "..")
              continue;
            list.push(Dirent_1.default.build(child, options.encoding));
            if (options.recursive && child.children.size) {
              const recurseOptions = { ...options, recursive: true, withFileTypes: true };
              const childList = this._readdir(child.getPath(), recurseOptions);
              list.push(...childList);
            }
          }
          if (!util_3.isWin && options.encoding !== "buffer")
            list.sort((a, b) => {
              if (a.name < b.name)
                return -1;
              if (a.name > b.name)
                return 1;
              return 0;
            });
          if (options.withFileTypes)
            return list;
          let filename2 = filename;
          if (util_3.isWin)
            filename2 = filename2.replace(/\\/g, "/");
          return list.map((dirent) => {
            if (options.recursive) {
              let fullPath = pathJoin(dirent.parentPath, dirent.name.toString());
              if (util_3.isWin) {
                fullPath = fullPath.replace(/\\/g, "/");
              }
              return fullPath.replace(filename2 + path_1.posix.sep, "");
            }
            return dirent.name;
          });
        };
        this.readdirSync = (path6, options) => {
          const opts = (0, options_1.getReaddirOptions)(options);
          const filename = (0, util_2.pathToFilename)(path6);
          return this._readdir(filename, opts);
        };
        this.readdir = (path6, a, b) => {
          const [options, callback] = (0, options_1.getReaddirOptsAndCb)(a, b);
          const filename = (0, util_2.pathToFilename)(path6);
          this.wrapAsync(this._readdir, [filename, options], callback);
        };
        this._readlink = (filename, encoding) => {
          const link = this._core.getLinkOrThrow(filename, "readlink");
          const node = link.getNode();
          if (!node.isSymlink())
            throw (0, util_2.createError)("EINVAL", "readlink", filename);
          return (0, encoding_1.strToEncoding)(node.symlink, encoding);
        };
        this.readlinkSync = (path6, options) => {
          const opts = (0, options_1.getDefaultOpts)(options);
          const filename = (0, util_2.pathToFilename)(path6);
          return this._readlink(filename, opts.encoding);
        };
        this.readlink = (path6, a, b) => {
          const [opts, callback] = (0, options_1.getDefaultOptsAndCb)(a, b);
          const filename = (0, util_2.pathToFilename)(path6);
          this.wrapAsync(this._readlink, [filename, opts.encoding], callback);
        };
        this._fsync = (fd) => {
          this._core.getFileByFdOrThrow(fd, "fsync");
        };
        this.fsyncSync = (fd) => {
          this._fsync(fd);
        };
        this.fsync = (fd, callback) => {
          this.wrapAsync(this._fsync, [fd], callback);
        };
        this._fdatasync = (fd) => {
          this._core.getFileByFdOrThrow(fd, "fdatasync");
        };
        this.fdatasyncSync = (fd) => {
          this._fdatasync(fd);
        };
        this.fdatasync = (fd, callback) => {
          this.wrapAsync(this._fdatasync, [fd], callback);
        };
        this._ftruncate = (fd, len) => {
          const file = this._core.getFileByFdOrThrow(fd, "ftruncate");
          file.truncate(len);
        };
        this.ftruncateSync = (fd, len) => {
          this._ftruncate(fd, len);
        };
        this.ftruncate = (fd, a, b) => {
          const len = typeof a === "number" ? a : 0;
          const callback = (0, util_2.validateCallback)(typeof a === "number" ? b : a);
          this.wrapAsync(this._ftruncate, [fd, len], callback);
        };
        this._truncate = (path6, len) => {
          const fd = this.openSync(path6, "r+");
          try {
            this.ftruncateSync(fd, len);
          } finally {
            this.closeSync(fd);
          }
        };
        this.truncateSync = (id, len) => {
          if ((0, util_3.isFd)(id))
            return this.ftruncateSync(id, len);
          this._truncate(id, len);
        };
        this.truncate = (id, a, b) => {
          const len = typeof a === "number" ? a : 0;
          const callback = (0, util_2.validateCallback)(typeof a === "number" ? b : a);
          if ((0, util_3.isFd)(id))
            return this.ftruncate(id, len, callback);
          this.wrapAsync(this._truncate, [id, len], callback);
        };
        this._futimes = (fd, atime, mtime) => {
          const file = this._core.getFileByFdOrThrow(fd, "futimes");
          const node = file.node;
          node.atime = new Date(atime * 1e3);
          node.mtime = new Date(mtime * 1e3);
        };
        this.futimesSync = (fd, atime, mtime) => {
          this._futimes(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
        };
        this.futimes = (fd, atime, mtime, callback) => {
          this.wrapAsync(this._futimes, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
        };
        this._utimes = (filename, atime, mtime, followSymlinks = true) => {
          const core = this._core;
          const link = followSymlinks ? core.getResolvedLinkOrThrow(filename, "utimes") : core.getLinkOrThrow(filename, "lutimes");
          const node = link.getNode();
          node.atime = new Date(atime * 1e3);
          node.mtime = new Date(mtime * 1e3);
        };
        this.utimesSync = (path6, atime, mtime) => {
          this._utimes((0, util_2.pathToFilename)(path6), toUnixTimestamp(atime), toUnixTimestamp(mtime), true);
        };
        this.utimes = (path6, atime, mtime, callback) => {
          this.wrapAsync(this._utimes, [(0, util_2.pathToFilename)(path6), toUnixTimestamp(atime), toUnixTimestamp(mtime), true], callback);
        };
        this.lutimesSync = (path6, atime, mtime) => {
          this._utimes((0, util_2.pathToFilename)(path6), toUnixTimestamp(atime), toUnixTimestamp(mtime), false);
        };
        this.lutimes = (path6, atime, mtime, callback) => {
          this.wrapAsync(this._utimes, [(0, util_2.pathToFilename)(path6), toUnixTimestamp(atime), toUnixTimestamp(mtime), false], callback);
        };
        this.mkdirSync = (path6, options) => {
          const opts = (0, options_1.getMkdirOptions)(options);
          const modeNum = (0, util_2.modeToNumber)(opts.mode, 511);
          const filename = (0, util_2.pathToFilename)(path6);
          if (opts.recursive)
            return this._core.mkdirp(filename, modeNum);
          this._core.mkdir(filename, modeNum);
        };
        this.mkdir = (path6, a, b) => {
          const opts = (0, options_1.getMkdirOptions)(a);
          const callback = (0, util_2.validateCallback)(typeof a === "function" ? a : b);
          const modeNum = (0, util_2.modeToNumber)(opts.mode, 511);
          const filename = (0, util_2.pathToFilename)(path6);
          if (opts.recursive)
            this.wrapAsync(this._core.mkdirp, [filename, modeNum], callback);
          else
            this.wrapAsync(this._core.mkdir, [filename, modeNum], callback);
        };
        this._mkdtemp = (prefix, encoding, retry = 5) => {
          const filename = prefix + (0, util_2.genRndStr6)();
          try {
            this._core.mkdir(
              filename,
              511
              /* MODE.DIR */
            );
            return (0, encoding_1.strToEncoding)(filename, encoding);
          } catch (err) {
            if (err.code === "EEXIST") {
              if (retry > 1)
                return this._mkdtemp(prefix, encoding, retry - 1);
              else
                throw Error("Could not create temp dir.");
            } else
              throw err;
          }
        };
        this.mkdtempSync = (prefix, options) => {
          const { encoding } = (0, options_1.getDefaultOpts)(options);
          if (!prefix || typeof prefix !== "string")
            throw new TypeError("filename prefix is required");
          (0, util_2.nullCheck)(prefix);
          return this._mkdtemp(prefix, encoding);
        };
        this.mkdtemp = (prefix, a, b) => {
          const [{ encoding }, callback] = (0, options_1.getDefaultOptsAndCb)(a, b);
          if (!prefix || typeof prefix !== "string")
            throw new TypeError("filename prefix is required");
          if (!(0, util_2.nullCheck)(prefix))
            return;
          this.wrapAsync(this._mkdtemp, [prefix, encoding], callback);
        };
        this.rmdirSync = (path6, options) => {
          const opts = (0, options_1.getRmdirOptions)(options);
          this._core.rmdir((0, util_2.pathToFilename)(path6), opts.recursive);
        };
        this.rmdir = (path6, a, b) => {
          const opts = (0, options_1.getRmdirOptions)(a);
          const callback = (0, util_2.validateCallback)(typeof a === "function" ? a : b);
          this.wrapAsync(this._core.rmdir, [(0, util_2.pathToFilename)(path6), opts.recursive], callback);
        };
        this.rmSync = (path6, options) => {
          this._core.rm((0, util_2.pathToFilename)(path6), options?.force, options?.recursive);
        };
        this.rm = (path6, a, b) => {
          const [opts, callback] = (0, options_1.getRmOptsAndCb)(a, b);
          this.wrapAsync(this._core.rm, [(0, util_2.pathToFilename)(path6), opts?.force, opts?.recursive], callback);
        };
        this._fchmod = (fd, modeNum) => {
          const file = this._core.getFileByFdOrThrow(fd, "fchmod");
          file.chmod(modeNum);
        };
        this.fchmodSync = (fd, mode) => {
          this._fchmod(fd, (0, util_2.modeToNumber)(mode));
        };
        this.fchmod = (fd, mode, callback) => {
          this.wrapAsync(this._fchmod, [fd, (0, util_2.modeToNumber)(mode)], callback);
        };
        this._chmod = (filename, modeNum, followSymlinks = true) => {
          const link = followSymlinks ? this._core.getResolvedLinkOrThrow(filename, "chmod") : this._core.getLinkOrThrow(filename, "chmod");
          const node = link.getNode();
          node.chmod(modeNum);
        };
        this.chmodSync = (path6, mode) => {
          const modeNum = (0, util_2.modeToNumber)(mode);
          const filename = (0, util_2.pathToFilename)(path6);
          this._chmod(filename, modeNum, true);
        };
        this.chmod = (path6, mode, callback) => {
          const modeNum = (0, util_2.modeToNumber)(mode);
          const filename = (0, util_2.pathToFilename)(path6);
          this.wrapAsync(this._chmod, [filename, modeNum], callback);
        };
        this._lchmod = (filename, modeNum) => {
          this._chmod(filename, modeNum, false);
        };
        this.lchmodSync = (path6, mode) => {
          const modeNum = (0, util_2.modeToNumber)(mode);
          const filename = (0, util_2.pathToFilename)(path6);
          this._lchmod(filename, modeNum);
        };
        this.lchmod = (path6, mode, callback) => {
          const modeNum = (0, util_2.modeToNumber)(mode);
          const filename = (0, util_2.pathToFilename)(path6);
          this.wrapAsync(this._lchmod, [filename, modeNum], callback);
        };
        this._fchown = (fd, uid, gid) => {
          this._core.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
        };
        this.fchownSync = (fd, uid, gid) => {
          validateUid(uid);
          validateGid(gid);
          this._fchown(fd, uid, gid);
        };
        this.fchown = (fd, uid, gid, callback) => {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(this._fchown, [fd, uid, gid], callback);
        };
        this._chown = (filename, uid, gid) => {
          const link = this._core.getResolvedLinkOrThrow(filename, "chown");
          const node = link.getNode();
          node.chown(uid, gid);
        };
        this.chownSync = (path6, uid, gid) => {
          validateUid(uid);
          validateGid(gid);
          this._chown((0, util_2.pathToFilename)(path6), uid, gid);
        };
        this.chown = (path6, uid, gid, callback) => {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(this._chown, [(0, util_2.pathToFilename)(path6), uid, gid], callback);
        };
        this._lchown = (filename, uid, gid) => {
          this._core.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
        };
        this.lchownSync = (path6, uid, gid) => {
          validateUid(uid);
          validateGid(gid);
          this._lchown((0, util_2.pathToFilename)(path6), uid, gid);
        };
        this.lchown = (path6, uid, gid, callback) => {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(this._lchown, [(0, util_2.pathToFilename)(path6), uid, gid], callback);
        };
        this.statWatchers = {};
        this.cpSync = (src, dest, options) => {
          const srcFilename = (0, util_2.pathToFilename)(src);
          const destFilename = (0, util_2.pathToFilename)(dest);
          const opts_ = {
            dereference: options?.dereference ?? false,
            errorOnExist: options?.errorOnExist ?? false,
            filter: options?.filter,
            force: options?.force ?? true,
            mode: options?.mode ?? 0,
            preserveTimestamps: options?.preserveTimestamps ?? false,
            recursive: options?.recursive ?? false,
            verbatimSymlinks: options?.verbatimSymlinks ?? false
          };
          return this._cp(srcFilename, destFilename, opts_);
        };
        this.cp = (src, dest, a, b) => {
          const srcFilename = (0, util_2.pathToFilename)(src);
          const destFilename = (0, util_2.pathToFilename)(dest);
          let options;
          let callback;
          if (typeof a === "function")
            [options, callback] = [{}, a];
          else
            [options, callback] = [a || {}, b];
          (0, util_2.validateCallback)(callback);
          const opts_ = {
            dereference: options?.dereference ?? false,
            errorOnExist: options?.errorOnExist ?? false,
            filter: options?.filter,
            force: options?.force ?? true,
            mode: options?.mode ?? 0,
            preserveTimestamps: options?.preserveTimestamps ?? false,
            recursive: options?.recursive ?? false,
            verbatimSymlinks: options?.verbatimSymlinks ?? false
          };
          this.wrapAsync(this._cp, [srcFilename, destFilename, opts_], callback);
        };
        this.openAsBlob = async (path6, options) => {
          const filename = (0, util_2.pathToFilename)(path6);
          let link;
          try {
            link = this._core.getResolvedLinkOrThrow(filename, "open");
          } catch (error) {
            if (error && typeof error === "object" && error.code === "ENOENT") {
              const nodeError = new errors.TypeError("ERR_INVALID_ARG_VALUE");
              throw nodeError;
            }
            throw error;
          }
          const node = link.getNode();
          const buffer = node.getBuffer();
          const type = options?.type || "";
          return new Blob([buffer], { type });
        };
        this.glob = (pattern, ...args) => {
          const [options, callback] = args.length === 1 ? [{}, args[0]] : [args[0], args[1]];
          this.wrapAsync(this._globSync, [pattern, options || {}], callback);
        };
        this.globSync = (pattern, options = {}) => {
          return this._globSync(pattern, options);
        };
        this._globSync = (pattern, options = {}) => {
          const { globSync } = require_glob();
          return globSync(this, pattern, options);
        };
        this._opendir = (filename, options) => {
          const link = this._core.getResolvedLinkOrThrow(filename, "scandir");
          const node = link.getNode();
          if (!node.isDirectory())
            throw (0, util_2.createError)("ENOTDIR", "scandir", filename);
          return new Dir_1.Dir(link, options);
        };
        this.opendirSync = (path6, options) => {
          const opts = (0, options_1.getOpendirOptions)(options);
          const filename = (0, util_2.pathToFilename)(path6);
          return this._opendir(filename, opts);
        };
        this.opendir = (path6, a, b) => {
          const [options, callback] = (0, options_1.getOpendirOptsAndCb)(a, b);
          const filename = (0, util_2.pathToFilename)(path6);
          this.wrapAsync(this._opendir, [filename, options], callback);
        };
        const self2 = this;
        this.StatWatcher = class extends StatWatcher {
          constructor() {
            super(self2);
          }
        };
        const _ReadStream = FsReadStream;
        this.ReadStream = class extends _ReadStream {
          constructor(...args) {
            super(self2, ...args);
          }
        };
        const _WriteStream = FsWriteStream;
        this.WriteStream = class extends _WriteStream {
          constructor(...args) {
            super(self2, ...args);
          }
        };
        this.FSWatcher = class extends FSWatcher {
          constructor() {
            super(self2);
          }
        };
        const _realpath = /* @__PURE__ */ __name((filename, encoding) => {
          const realLink = this._core.getResolvedLinkOrThrow(filename, "realpath");
          return (0, encoding_1.strToEncoding)(realLink.getPath() || "/", encoding);
        }, "_realpath");
        const realpathImpl = /* @__PURE__ */ __name((path6, a, b) => {
          const [opts, callback] = (0, options_1.getRealpathOptsAndCb)(a, b);
          const pathFilename = (0, util_2.pathToFilename)(path6);
          self2.wrapAsync(_realpath, [pathFilename, opts.encoding], callback);
        }, "realpathImpl");
        const realpathSyncImpl = /* @__PURE__ */ __name((path6, options) => _realpath((0, util_2.pathToFilename)(path6), (0, options_1.getRealpathOptions)(options).encoding), "realpathSyncImpl");
        this.realpath = realpathImpl;
        this.realpath.native = realpathImpl;
        this.realpathSync = realpathSyncImpl;
        this.realpathSync.native = realpathSyncImpl;
      }
      wrapAsync(method, args, callback) {
        (0, util_2.validateCallback)(callback);
        Promise.resolve().then(() => {
          let result;
          try {
            result = method.apply(this, args);
          } catch (err) {
            callback(err);
            return;
          }
          callback(null, result);
        });
      }
      toTree(opts = { separator: path_1.sep }) {
        return (0, print_1.toTreeSync)(this, opts);
      }
      reset() {
        this._core.reset();
      }
      toJSON(paths, json = {}, isRelative = false, asBuffer = false) {
        return this._core.toJSON(paths, json, isRelative, asBuffer);
      }
      fromJSON(json, cwd) {
        return this._core.fromJSON(json, cwd);
      }
      fromNestedJSON(json, cwd) {
        return this._core.fromNestedJSON(json, cwd);
      }
      // Legacy interface
      mountSync(mountpoint, json) {
        this._core.fromJSON(json, mountpoint);
      }
      _write(fd, buf, offset, length, position) {
        const file = this._core.getFileByFdOrThrow(fd, "write");
        if (file.node.isSymlink()) {
          throw (0, util_2.createError)("EBADF", "write", file.link.getPath());
        }
        return file.write(buf, offset, length, position === -1 || typeof position !== "number" ? void 0 : position);
      }
      writevBase(fd, buffers, position) {
        const file = this._core.getFileByFdOrThrow(fd);
        let p = position ?? void 0;
        if (p === -1) {
          p = void 0;
        }
        let bytesWritten = 0;
        for (const buffer of buffers) {
          const nodeBuf = buffer_1.Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
          const bytes = file.write(nodeBuf, 0, nodeBuf.byteLength, p);
          p = void 0;
          bytesWritten += bytes;
          if (bytes < nodeBuf.byteLength)
            break;
        }
        return bytesWritten;
      }
      _copyFile(src, dest, flags) {
        const buf = this.readFileSync(src);
        if (flags & COPYFILE_EXCL && this.existsSync(dest))
          throw (0, util_2.createError)("EEXIST", "copyFile", src, dest);
        if (flags & COPYFILE_FICLONE_FORCE)
          throw (0, util_2.createError)("ENOSYS", "copyFile", src, dest);
        this._core.writeFile(
          dest,
          buf,
          constants_2.FLAGS.w,
          438
          /* MODE.DEFAULT */
        );
      }
      isSrcSubdir(src, dest) {
        try {
          const normalizedSrc = pathNormalize(src.startsWith("/") ? src : "/" + src);
          const normalizedDest = pathNormalize(dest.startsWith("/") ? dest : "/" + dest);
          if (normalizedSrc === normalizedDest)
            return true;
          const relativePath = pathRelative(normalizedSrc, normalizedDest);
          return relativePath === "" || !relativePath.startsWith("..") && !(0, path_1.isAbsolute)(relativePath);
        } catch (error) {
          return false;
        }
      }
      cpFileSync(srcStat, destStat, src, dest, options) {
        if (destStat) {
          if (options.errorOnExist)
            throw (0, util_2.createError)("EEXIST", "cp", dest);
          if (!options.force)
            return;
          this.unlinkSync(dest);
        }
        this.copyFileSync(src, dest, options.mode);
        if (options.preserveTimestamps)
          this.utimesSync(dest, srcStat.atime, srcStat.mtime);
        this.chmodSync(dest, Number(srcStat.mode));
      }
      cpDirSync(srcStat, destStat, src, dest, options) {
        if (!destStat) {
          this.mkdirSync(dest);
        }
        const entries = this.readdirSync(src);
        for (const entry of entries) {
          const srcItem = pathJoin(src, String(entry));
          const destItem = pathJoin(dest, String(entry));
          if (options.filter && !options.filter(srcItem, destItem)) {
            continue;
          }
          this._cp(srcItem, destItem, options);
        }
        this.chmodSync(dest, Number(srcStat.mode));
      }
      cpSymlinkSync(destStat, src, dest, options) {
        let linkTarget = String(this.readlinkSync(src));
        if (!options.verbatimSymlinks && !(0, path_1.isAbsolute)(linkTarget))
          linkTarget = resolveCrossPlatform(pathDirname(src), linkTarget);
        if (destStat)
          this.unlinkSync(dest);
        this.symlinkSync(linkTarget, dest);
      }
      lstat(path6, a, b) {
        const [{ throwIfNoEntry = true, bigint = false }, callback] = (0, options_1.getStatOptsAndCb)(a, b);
        this.wrapAsync(this._lstat, [(0, util_2.pathToFilename)(path6), bigint, throwIfNoEntry], callback);
      }
      _stat(filename, bigint = false, throwIfNoEntry = true) {
        let link;
        try {
          link = this._core.getResolvedLinkOrThrow(filename, "stat");
        } catch (err) {
          if (err.code === "ENOENT" && !throwIfNoEntry)
            return void 0;
          else
            throw err;
        }
        return Stats_1.default.build(link.getNode(), bigint);
      }
      statSync(path6, options) {
        const { bigint = true, throwIfNoEntry = true } = (0, options_1.getStatOptions)(options);
        return this._stat((0, util_2.pathToFilename)(path6), bigint, throwIfNoEntry);
      }
      stat(path6, a, b) {
        const [{ bigint = false, throwIfNoEntry = true }, callback] = (0, options_1.getStatOptsAndCb)(a, b);
        this.wrapAsync(this._stat, [(0, util_2.pathToFilename)(path6), bigint, throwIfNoEntry], callback);
      }
      fstatBase(fd, bigint = false) {
        const file = this._core.getFileByFd(fd);
        if (!file)
          throw (0, util_2.createError)("EBADF", "fstat");
        return Stats_1.default.build(file.node, bigint);
      }
      fstatSync(fd, options) {
        return this.fstatBase(fd, (0, options_1.getStatOptions)(options).bigint);
      }
      fstat(fd, a, b) {
        const [opts, callback] = (0, options_1.getStatOptsAndCb)(a, b);
        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
      }
      _exists(filename) {
        return !!this._stat(filename);
      }
      _access(filename, mode) {
        const link = this._core.getLinkOrThrow(filename, "access");
        const node = link.getNode();
        if (mode === F_OK) {
          return;
        }
        if (mode & R_OK && !node.canRead()) {
          throw (0, util_2.createError)("EACCES", "access", filename);
        }
        if (mode & W_OK && !node.canWrite()) {
          throw (0, util_2.createError)("EACCES", "access", filename);
        }
        if (mode & X_OK && !node.canExecute()) {
          throw (0, util_2.createError)("EACCES", "access", filename);
        }
      }
      watchFile(path6, a, b) {
        const filename = (0, util_2.pathToFilename)(path6);
        let options = a;
        let listener = b;
        if (typeof options === "function") {
          listener = a;
          options = null;
        }
        if (typeof listener !== "function") {
          throw Error('"watchFile()" requires a listener function');
        }
        let interval = 5007;
        let persistent = true;
        if (options && typeof options === "object") {
          if (typeof options.interval === "number")
            interval = options.interval;
          if (typeof options.persistent === "boolean")
            persistent = options.persistent;
        }
        let watcher = this.statWatchers[filename];
        if (!watcher) {
          watcher = new this.StatWatcher();
          watcher.start(filename, persistent, interval);
          this.statWatchers[filename] = watcher;
        }
        watcher.addListener("change", listener);
        return watcher;
      }
      unwatchFile(path6, listener) {
        const filename = (0, util_2.pathToFilename)(path6);
        const watcher = this.statWatchers[filename];
        if (!watcher)
          return;
        if (typeof listener === "function") {
          watcher.removeListener("change", listener);
        } else {
          watcher.removeAllListeners("change");
        }
        if (watcher.listenerCount("change") === 0) {
          watcher.stop();
          delete this.statWatchers[filename];
        }
      }
      createReadStream(path6, options) {
        return new this.ReadStream(path6, options);
      }
      createWriteStream(path6, options) {
        return new this.WriteStream(path6, options);
      }
      // watch(path: PathLike): FSWatcher;
      // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;
      watch(path6, options, listener) {
        const filename = (0, util_2.pathToFilename)(path6);
        let givenOptions = options;
        if (typeof options === "function") {
          listener = options;
          givenOptions = null;
        }
        let { persistent, recursive, encoding } = (0, options_1.getDefaultOpts)(givenOptions);
        if (persistent === void 0)
          persistent = true;
        if (recursive === void 0)
          recursive = false;
        const watcher = new this.FSWatcher();
        watcher.start(filename, persistent, recursive, encoding);
        if (listener) {
          watcher.addListener("change", listener);
        }
        return watcher;
      }
      _statfs(filename, bigint = false) {
        this._core.getResolvedLinkOrThrow(filename, "statfs");
        return StatFs_1.default.build(this._core, bigint);
      }
      statfsSync(path6, options) {
        const { bigint = false } = (0, options_1.getStatfsOptions)(options);
        return this._statfs((0, util_2.pathToFilename)(path6), bigint);
      }
      statfs(path6, a, b) {
        const [{ bigint = false }, callback] = (0, options_1.getStatfsOptsAndCb)(a, b);
        this.wrapAsync(this._statfs, [(0, util_2.pathToFilename)(path6), bigint], callback);
      }
    };
    __name(_Volume, "Volume");
    var Volume5 = _Volume;
    exports.Volume = Volume5;
    Volume5.fromJSON = (json, cwd) => new Volume5(core_1.Superblock.fromJSON(json, cwd));
    Volume5.fromNestedJSON = (json, cwd) => new Volume5(core_1.Superblock.fromNestedJSON(json, cwd));
    function emitStop(self2) {
      self2.emit("stop");
    }
    __name(emitStop, "emitStop");
    var _StatWatcher = class _StatWatcher extends events_1.EventEmitter {
      constructor(vol) {
        super();
        this.onInterval = () => {
          try {
            const stats = this.vol.statSync(this.filename);
            if (this.hasChanged(stats)) {
              this.emit("change", stats, this.prev);
              this.prev = stats;
            }
          } finally {
            this.loop();
          }
        };
        this.vol = vol;
      }
      loop() {
        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
      }
      hasChanged(stats) {
        if (stats.mtimeMs > this.prev.mtimeMs)
          return true;
        if (stats.nlink !== this.prev.nlink)
          return true;
        return false;
      }
      start(path6, persistent = true, interval = 5007) {
        this.filename = (0, util_2.pathToFilename)(path6);
        this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : globalThis) : setTimeoutUnref_1.default;
        this.interval = interval;
        this.prev = this.vol.statSync(this.filename);
        this.loop();
      }
      stop() {
        clearTimeout(this.timeoutRef);
        (0, queueMicrotask_1.default)(() => {
          emitStop.call(this, this);
        });
      }
    };
    __name(_StatWatcher, "StatWatcher");
    var StatWatcher = _StatWatcher;
    exports.StatWatcher = StatWatcher;
    var pool;
    function allocNewPool(poolSize) {
      pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
      pool.used = 0;
    }
    __name(allocNewPool, "allocNewPool");
    (0, util_1.inherits)(FsReadStream, stream_1.Readable);
    exports.ReadStream = FsReadStream;
    function FsReadStream(vol, path6, options) {
      if (!(this instanceof FsReadStream))
        return new FsReadStream(vol, path6, options);
      this._vol = vol;
      options = Object.assign({}, (0, options_1.getOptions)(options, {}));
      if (options.highWaterMark === void 0)
        options.highWaterMark = 64 * 1024;
      stream_1.Readable.call(this, options);
      this.path = (0, util_2.pathToFilename)(path6);
      this.fd = options.fd === void 0 ? null : typeof options.fd !== "number" ? options.fd.fd : options.fd;
      this.flags = options.flags === void 0 ? "r" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.end = options.end;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = void 0;
      this.bytesRead = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw new TypeError('"end" option must be a Number');
        }
        if (this.start > this.end) {
          throw new Error('"start" option must be <= "end" option');
        }
        this.pos = this.start;
      }
      if (typeof this.fd !== "number")
        this.open();
      this.on("end", function() {
        if (this.autoClose) {
          if (this.destroy)
            this.destroy();
        }
      });
    }
    __name(FsReadStream, "FsReadStream");
    FsReadStream.prototype.open = function() {
      var self2 = this;
      this._vol.open(this.path, this.flags, this.mode, (er, fd) => {
        if (er) {
          if (self2.autoClose) {
            if (self2.destroy)
              self2.destroy();
          }
          self2.emit("error", er);
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2.read();
      });
    };
    FsReadStream.prototype._read = function(n) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._read(n);
        });
      }
      if (this.destroyed)
        return;
      if (!pool || pool.length - pool.used < kMinPoolSpace) {
        allocNewPool(this._readableState.highWaterMark);
      }
      var thisPool = pool;
      var toRead = Math.min(pool.length - pool.used, n);
      var start = pool.used;
      if (this.pos !== void 0)
        toRead = Math.min(this.end - this.pos + 1, toRead);
      if (toRead <= 0)
        return this.push(null);
      var self2 = this;
      this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
      if (this.pos !== void 0)
        this.pos += toRead;
      pool.used += toRead;
      function onread(er, bytesRead) {
        if (er) {
          if (self2.autoClose && self2.destroy) {
            self2.destroy();
          }
          self2.emit("error", er);
        } else {
          var b = null;
          if (bytesRead > 0) {
            self2.bytesRead += bytesRead;
            b = thisPool.slice(start, start + bytesRead);
          }
          self2.push(b);
        }
      }
      __name(onread, "onread");
    };
    FsReadStream.prototype._destroy = function(err, cb) {
      this.close((err2) => {
        cb(err || err2);
      });
    };
    FsReadStream.prototype.close = function(cb) {
      if (cb)
        this.once("close", cb);
      if (this.closed || typeof this.fd !== "number") {
        if (typeof this.fd !== "number") {
          this.once("open", closeOnOpen);
          return;
        }
        return (0, queueMicrotask_1.default)(() => this.emit("close"));
      }
      if (typeof this._readableState?.closed === "boolean") {
        this._readableState.closed = true;
      } else {
        this.closed = true;
      }
      this._vol.close(this.fd, (er) => {
        if (er)
          this.emit("error", er);
        else
          this.emit("close");
      });
      this.fd = null;
    };
    function closeOnOpen(fd) {
      this.close();
    }
    __name(closeOnOpen, "closeOnOpen");
    (0, util_1.inherits)(FsWriteStream, stream_1.Writable);
    exports.WriteStream = FsWriteStream;
    function FsWriteStream(vol, path6, options) {
      if (!(this instanceof FsWriteStream))
        return new FsWriteStream(vol, path6, options);
      this._vol = vol;
      options = Object.assign({}, (0, options_1.getOptions)(options, {}));
      stream_1.Writable.call(this, options);
      this.path = (0, util_2.pathToFilename)(path6);
      this.fd = options.fd === void 0 ? null : typeof options.fd !== "number" ? options.fd.fd : options.fd;
      this.flags = options.flags === void 0 ? "w" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
      this.pos = void 0;
      this.bytesWritten = 0;
      this.pending = true;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.start < 0) {
          throw new Error('"start" must be >= zero');
        }
        this.pos = this.start;
      }
      if (options.encoding)
        this.setDefaultEncoding(options.encoding);
      if (typeof this.fd !== "number")
        this.open();
      this.once("finish", function() {
        if (this.autoClose) {
          this.close();
        }
      });
    }
    __name(FsWriteStream, "FsWriteStream");
    FsWriteStream.prototype.open = function() {
      this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
        if (er) {
          if (this.autoClose && this.destroy) {
            this.destroy();
          }
          this.emit("error", er);
          return;
        }
        this.fd = fd;
        this.pending = false;
        this.emit("open", fd);
      }.bind(this));
    };
    FsWriteStream.prototype._write = function(data, encoding, cb) {
      if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array))
        return this.emit("error", new Error("Invalid data"));
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      }
      var self2 = this;
      this._vol.write(this.fd, data, 0, data.length, this.pos, (er, bytes) => {
        if (er) {
          if (self2.autoClose && self2.destroy) {
            self2.destroy();
          }
          return cb(er);
        }
        self2.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0)
        this.pos += data.length;
    };
    FsWriteStream.prototype._writev = function(data, cb) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._writev(data, cb);
        });
      }
      const self2 = this;
      const len = data.length;
      const chunks = new Array(len);
      var size = 0;
      for (var i = 0; i < len; i++) {
        var chunk = data[i].chunk;
        chunks[i] = chunk;
        size += chunk.length;
      }
      const buf = buffer_1.Buffer.concat(chunks);
      this._vol.write(this.fd, buf, 0, buf.length, this.pos, (er, bytes) => {
        if (er) {
          if (self2.destroy)
            self2.destroy();
          return cb(er);
        }
        self2.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0)
        this.pos += size;
    };
    FsWriteStream.prototype.close = function(cb) {
      if (cb)
        this.once("close", cb);
      if (this.closed || typeof this.fd !== "number") {
        if (typeof this.fd !== "number") {
          this.once("open", closeOnOpen);
          return;
        }
        return (0, queueMicrotask_1.default)(() => this.emit("close"));
      }
      if (typeof this._writableState?.closed === "boolean") {
        this._writableState.closed = true;
      } else {
        this.closed = true;
      }
      this._vol.close(this.fd, (er) => {
        if (er)
          this.emit("error", er);
        else
          this.emit("close");
      });
      this.fd = null;
    };
    FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
    FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
    var _FSWatcher = class _FSWatcher extends events_1.EventEmitter {
      constructor(vol) {
        super();
        this._filename = "";
        this._filenameEncoded = "";
        this._recursive = false;
        this._encoding = encoding_1.ENCODING_UTF8;
        this._listenerRemovers = /* @__PURE__ */ new Map();
        this._onParentChild = (link) => {
          if (link.getName() === this._getName()) {
            this._emit("rename");
          }
        };
        this._emit = (type) => {
          this.emit("change", type, this._filenameEncoded);
        };
        this._persist = () => {
          this._timer = setTimeout(this._persist, 1e6);
        };
        this._vol = vol;
      }
      _getName() {
        return this._steps[this._steps.length - 1];
      }
      start(path6, persistent = true, recursive = false, encoding = encoding_1.ENCODING_UTF8) {
        this._filename = (0, util_2.pathToFilename)(path6);
        this._steps = (0, util_3.filenameToSteps)(this._filename);
        this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
        this._recursive = recursive;
        this._encoding = encoding;
        try {
          this._link = this._vol._core.getLinkOrThrow(this._filename, "FSWatcher");
        } catch (err) {
          const error = new Error(`watch ${this._filename} ${err.code}`);
          error.code = err.code;
          error.errno = err.code;
          throw error;
        }
        const watchLinkNodeChanged = /* @__PURE__ */ __name((link) => {
          const filepath = link.getPath();
          const node = link.getNode();
          const onNodeChange = /* @__PURE__ */ __name(() => {
            let filename = pathRelative(this._filename, filepath);
            if (!filename)
              filename = this._getName();
            return this.emit("change", "change", filename);
          }, "onNodeChange");
          const unsub = node.changes.listen(([type]) => {
            if (type === "modify")
              onNodeChange();
          });
          const removers = this._listenerRemovers.get(node.ino) ?? [];
          removers.push(() => unsub());
          this._listenerRemovers.set(node.ino, removers);
        }, "watchLinkNodeChanged");
        const watchLinkChildrenChanged = /* @__PURE__ */ __name((link) => {
          const node = link.getNode();
          const onLinkChildAdd = /* @__PURE__ */ __name((l) => {
            this.emit("change", "rename", pathRelative(this._filename, l.getPath()));
            watchLinkNodeChanged(l);
            watchLinkChildrenChanged(l);
          }, "onLinkChildAdd");
          const onLinkChildDelete = /* @__PURE__ */ __name((l) => {
            const removeLinkNodeListeners = /* @__PURE__ */ __name((curLink) => {
              const ino = curLink.getNode().ino;
              const removers2 = this._listenerRemovers.get(ino);
              if (removers2) {
                removers2.forEach((r) => r());
                this._listenerRemovers.delete(ino);
              }
              for (const [name, childLink] of curLink.children.entries()) {
                if (childLink && name !== "." && name !== "..") {
                  removeLinkNodeListeners(childLink);
                }
              }
            }, "removeLinkNodeListeners");
            removeLinkNodeListeners(l);
            this.emit("change", "rename", pathRelative(this._filename, l.getPath()));
          }, "onLinkChildDelete");
          for (const [name, childLink] of link.children.entries()) {
            if (childLink && name !== "." && name !== "..") {
              watchLinkNodeChanged(childLink);
            }
          }
          const unsubscribeLinkChanges = link.changes.listen(([type, link2]) => {
            if (type === "child:add")
              onLinkChildAdd(link2);
            else if (type === "child:del")
              onLinkChildDelete(link2);
          });
          const removers = this._listenerRemovers.get(node.ino) ?? [];
          removers.push(() => {
            unsubscribeLinkChanges();
          });
          if (recursive) {
            for (const [name, childLink] of link.children.entries()) {
              if (childLink && name !== "." && name !== "..") {
                watchLinkChildrenChanged(childLink);
              }
            }
          }
        }, "watchLinkChildrenChanged");
        watchLinkNodeChanged(this._link);
        watchLinkChildrenChanged(this._link);
        const parent = this._link.parent;
        if (parent) {
          parent.changes.listen(([type, link]) => {
            if (type === "child:del")
              this._onParentChild(link);
          });
        }
        if (persistent)
          this._persist();
      }
      close() {
        clearTimeout(this._timer);
        this._listenerRemovers.forEach((removers) => {
          removers.forEach((r) => r());
        });
        this._listenerRemovers.clear();
        this._parentChangesUnsub?.();
      }
    };
    __name(_FSWatcher, "FSWatcher");
    var FSWatcher = _FSWatcher;
    exports.FSWatcher = FSWatcher;
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/lists/fsSynchronousApiList.js
var require_fsSynchronousApiList = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/lists/fsSynchronousApiList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fsSynchronousApiList = void 0;
    exports.fsSynchronousApiList = [
      "accessSync",
      "appendFileSync",
      "chmodSync",
      "chownSync",
      "closeSync",
      "copyFileSync",
      "existsSync",
      "fchmodSync",
      "fchownSync",
      "fdatasyncSync",
      "fstatSync",
      "fsyncSync",
      "ftruncateSync",
      "futimesSync",
      "lchmodSync",
      "lchownSync",
      "linkSync",
      "lstatSync",
      "mkdirSync",
      "mkdtempSync",
      "openSync",
      "opendirSync",
      "readdirSync",
      "readFileSync",
      "readlinkSync",
      "readSync",
      "readvSync",
      "realpathSync",
      "renameSync",
      "rmdirSync",
      "rmSync",
      "statSync",
      "symlinkSync",
      "truncateSync",
      "unlinkSync",
      "utimesSync",
      "lutimesSync",
      "writeFileSync",
      "writeSync",
      "writevSync"
      // 'cpSync',
      // 'statfsSync',
    ];
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/lists/fsCallbackApiList.js
var require_fsCallbackApiList = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/node/lists/fsCallbackApiList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fsCallbackApiList = void 0;
    exports.fsCallbackApiList = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "cp",
      "createReadStream",
      "createWriteStream",
      "exists",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "openAsBlob",
      "opendir",
      "read",
      "readv",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "statfs",
      "symlink",
      "truncate",
      "unlink",
      "unwatchFile",
      "utimes",
      "lutimes",
      "watch",
      "watchFile",
      "write",
      "writev",
      "writeFile"
    ];
  }
});

// ../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/.pnpm/memfs@4.49.0/node_modules/memfs/lib/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.memfs = exports.fs = exports.vol = exports.Volume = void 0;
    exports.createFsFromVolume = createFsFromVolume5;
    var Stats_1 = require_Stats();
    var Dirent_1 = require_Dirent();
    var volume_1 = require_volume();
    Object.defineProperty(exports, "Volume", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return volume_1.Volume;
    }, "get") });
    var constants_1 = require_constants();
    var fsSynchronousApiList_1 = require_fsSynchronousApiList();
    var fsCallbackApiList_1 = require_fsCallbackApiList();
    var { F_OK, R_OK, W_OK, X_OK } = constants_1.constants;
    exports.vol = new volume_1.Volume();
    function createFsFromVolume5(vol) {
      const fs = { F_OK, R_OK, W_OK, X_OK, constants: constants_1.constants, Stats: Stats_1.default, Dirent: Dirent_1.default };
      for (const method of fsSynchronousApiList_1.fsSynchronousApiList)
        if (typeof vol[method] === "function")
          fs[method] = vol[method].bind(vol);
      for (const method of fsCallbackApiList_1.fsCallbackApiList)
        if (typeof vol[method] === "function")
          fs[method] = vol[method].bind(vol);
      fs.StatWatcher = vol.StatWatcher;
      fs.FSWatcher = vol.FSWatcher;
      fs.WriteStream = vol.WriteStream;
      fs.ReadStream = vol.ReadStream;
      fs.promises = vol.promises;
      if (typeof vol.realpath === "function") {
        fs.realpath = vol.realpath.bind(vol);
        if (typeof vol.realpath.native === "function") {
          fs.realpath.native = vol.realpath.native.bind(vol);
        }
      }
      if (typeof vol.realpathSync === "function") {
        fs.realpathSync = vol.realpathSync.bind(vol);
        if (typeof vol.realpathSync.native === "function") {
          fs.realpathSync.native = vol.realpathSync.native.bind(vol);
        }
      }
      fs._toUnixTimestamp = volume_1.toUnixTimestamp;
      fs.__vol = vol;
      return fs;
    }
    __name(createFsFromVolume5, "createFsFromVolume");
    exports.fs = createFsFromVolume5(exports.vol);
    var memfs2 = /* @__PURE__ */ __name((json = {}, cwd = "/") => {
      const vol = volume_1.Volume.fromNestedJSON(json, cwd);
      const fs = createFsFromVolume5(vol);
      return { fs, vol };
    }, "memfs");
    exports.memfs = memfs2;
    module.exports = { ...module.exports, ...exports.fs };
    module.exports.semantic = true;
  }
});

// ../../node_modules/.pnpm/ignore@7.0.5/node_modules/ignore/index.js
var require_ignore = __commonJS({
  "../../node_modules/.pnpm/ignore@7.0.5/node_modules/ignore/index.js"(exports, module) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    __name(makeArray, "makeArray");
    var UNDEFINED = void 0;
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.{0,2}\/|^\.{1,2}$/;
    var REGEX_TEST_TRAILING_SLASH = /\/$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define2 = /* @__PURE__ */ __name((object, key, value) => {
      Object.defineProperty(object, key, { value });
      return value;
    }, "define");
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = /* @__PURE__ */ __name(() => false, "RETURN_FALSE");
    var sanitizeRange = /* @__PURE__ */ __name((range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    ), "sanitizeRange");
    var cleanRangeBackSlash = /* @__PURE__ */ __name((slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    }, "cleanRangeBackSlash");
    var REPLACERS = [
      [
        // Remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
      ],
      // Replace (\ ) with ' '
      // (\ ) -> ' '
      // (\\ ) -> '\\ '
      // (\\\ ) -> '\\ '
      [
        /(\\+?)\s/g,
        (_, m1) => {
          const { length } = m1;
          return m1.slice(0, length - length % 2) + SPACE;
        }
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        /* @__PURE__ */ __name(function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }, "startingReplacer")
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index2, str) => index2 + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ]
    ];
    var REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\/)?\\\*$/;
    var MODE_IGNORE = "regex";
    var MODE_CHECK_IGNORE = "checkRegex";
    var UNDERSCORE = "_";
    var TRAILING_WILD_CARD_REPLACERS = {
      [MODE_IGNORE](_, p1) {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      },
      [MODE_CHECK_IGNORE](_, p1) {
        const prefix = p1 ? `${p1}[^/]*` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    };
    var makeRegexPrefix = /* @__PURE__ */ __name((pattern) => REPLACERS.reduce(
      (prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)),
      pattern
    ), "makeRegexPrefix");
    var isString = /* @__PURE__ */ __name((subject) => typeof subject === "string", "isString");
    var checkPattern = /* @__PURE__ */ __name((pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0, "checkPattern");
    var splitPattern = /* @__PURE__ */ __name((pattern) => pattern.split(REGEX_SPLITALL_CRLF).filter(Boolean), "splitPattern");
    var _IgnoreRule = class _IgnoreRule {
      constructor(pattern, mark, body, ignoreCase, negative, prefix) {
        this.pattern = pattern;
        this.mark = mark;
        this.negative = negative;
        define2(this, "body", body);
        define2(this, "ignoreCase", ignoreCase);
        define2(this, "regexPrefix", prefix);
      }
      get regex() {
        const key = UNDERSCORE + MODE_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_IGNORE, key);
      }
      get checkRegex() {
        const key = UNDERSCORE + MODE_CHECK_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_CHECK_IGNORE, key);
      }
      _make(mode, key) {
        const str = this.regexPrefix.replace(
          REGEX_REPLACE_TRAILING_WILDCARD,
          // It does not need to bind pattern
          TRAILING_WILD_CARD_REPLACERS[mode]
        );
        const regex = this.ignoreCase ? new RegExp(str, "i") : new RegExp(str);
        return define2(this, key, regex);
      }
    };
    __name(_IgnoreRule, "IgnoreRule");
    var IgnoreRule = _IgnoreRule;
    var createRule = /* @__PURE__ */ __name(({
      pattern,
      mark
    }, ignoreCase) => {
      let negative = false;
      let body = pattern;
      if (body.indexOf("!") === 0) {
        negative = true;
        body = body.substr(1);
      }
      body = body.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regexPrefix = makeRegexPrefix(body);
      return new IgnoreRule(
        pattern,
        mark,
        body,
        ignoreCase,
        negative,
        regexPrefix
      );
    }, "createRule");
    var _RuleManager = class _RuleManager {
      constructor(ignoreCase) {
        this._ignoreCase = ignoreCase;
        this._rules = [];
      }
      _add(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules._rules);
          this._added = true;
          return;
        }
        if (isString(pattern)) {
          pattern = {
            pattern
          };
        }
        if (checkPattern(pattern.pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._add, this);
        return this._added;
      }
      // Test one single path without recursively checking parent directories
      //
      // - checkUnignored `boolean` whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`
      // @returns {TestResult} true if a file is ignored
      test(path6, checkUnignored, mode) {
        let ignored = false;
        let unignored = false;
        let matchedRule;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule[mode].test(path6);
          if (!matched) {
            return;
          }
          ignored = !negative;
          unignored = negative;
          matchedRule = negative ? UNDEFINED : rule;
        });
        const ret = {
          ignored,
          unignored
        };
        if (matchedRule) {
          ret.rule = matchedRule;
        }
        return ret;
      }
    };
    __name(_RuleManager, "RuleManager");
    var RuleManager = _RuleManager;
    var throwError = /* @__PURE__ */ __name((message, Ctor) => {
      throw new Ctor(message);
    }, "throwError");
    var checkPath = /* @__PURE__ */ __name((path6, originalPath, doThrow) => {
      if (!isString(path6)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path6) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path6)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    }, "checkPath");
    var isNotRelative = /* @__PURE__ */ __name((path6) => REGEX_TEST_INVALID_PATH.test(path6), "isNotRelative");
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var _Ignore = class _Ignore {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = new RuleManager(ignoreCase);
        this._strictPathCheck = !allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      add(pattern) {
        if (this._rules.add(pattern)) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path6 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path6,
          originalPath,
          this._strictPathCheck ? throwError : RETURN_FALSE
        );
        return this._t(path6, cache, checkUnignored, slices);
      }
      checkIgnore(path6) {
        if (!REGEX_TEST_TRAILING_SLASH.test(path6)) {
          return this.test(path6);
        }
        const slices = path6.split(SLASH).filter(Boolean);
        slices.pop();
        if (slices.length) {
          const parent = this._t(
            slices.join(SLASH) + SLASH,
            this._testCache,
            true,
            slices
          );
          if (parent.ignored) {
            return parent;
          }
        }
        return this._rules.test(path6, false, MODE_CHECK_IGNORE);
      }
      _t(path6, cache, checkUnignored, slices) {
        if (path6 in cache) {
          return cache[path6];
        }
        if (!slices) {
          slices = path6.split(SLASH).filter(Boolean);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path6] = this._rules.test(path6, checkUnignored, MODE_IGNORE);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path6] = parent.ignored ? parent : this._rules.test(path6, checkUnignored, MODE_IGNORE);
      }
      ignores(path6) {
        return this._test(path6, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path6) => !this.ignores(path6);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path6) {
        return this._test(path6, this._testCache, true);
      }
    };
    __name(_Ignore, "Ignore");
    var Ignore = _Ignore;
    var factory = /* @__PURE__ */ __name((options) => new Ignore(options), "factory");
    var isPathValid = /* @__PURE__ */ __name((path6) => checkPath(path6 && checkPath.convert(path6), path6, RETURN_FALSE), "isPathValid");
    var setupWindows = /* @__PURE__ */ __name(() => {
      const makePosix = /* @__PURE__ */ __name((str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/"), "makePosix");
      checkPath.convert = makePosix;
      const REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path6) => REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path6) || isNotRelative(path6);
    }, "setupWindows");
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && process.platform === "win32"
    ) {
      setupWindows();
    }
    module.exports = factory;
    factory.default = factory;
    module.exports.isPathValid = isPathValid;
    define2(module.exports, Symbol.for("setupWindows"), setupWindows);
  }
});

// ../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/lib/index.js"(exports, module) {
    "use strict";
    var AsyncLock = /* @__PURE__ */ __name(function(opts) {
      opts = opts || {};
      this.Promise = opts.Promise || Promise;
      this.queues = /* @__PURE__ */ Object.create(null);
      this.domainReentrant = opts.domainReentrant || false;
      if (this.domainReentrant) {
        if (typeof process === "undefined" || typeof process.domain === "undefined") {
          throw new Error(
            "Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill."
          );
        }
        this.domains = /* @__PURE__ */ Object.create(null);
      }
      this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;
      this.maxOccupationTime = opts.maxOccupationTime || AsyncLock.DEFAULT_MAX_OCCUPATION_TIME;
      this.maxExecutionTime = opts.maxExecutionTime || AsyncLock.DEFAULT_MAX_EXECUTION_TIME;
      if (opts.maxPending === Infinity || Number.isInteger(opts.maxPending) && opts.maxPending >= 0) {
        this.maxPending = opts.maxPending;
      } else {
        this.maxPending = AsyncLock.DEFAULT_MAX_PENDING;
      }
    }, "AsyncLock");
    AsyncLock.DEFAULT_TIMEOUT = 0;
    AsyncLock.DEFAULT_MAX_OCCUPATION_TIME = 0;
    AsyncLock.DEFAULT_MAX_EXECUTION_TIME = 0;
    AsyncLock.DEFAULT_MAX_PENDING = 1e3;
    AsyncLock.prototype.acquire = function(key, fn, cb, opts) {
      if (Array.isArray(key)) {
        return this._acquireBatch(key, fn, cb, opts);
      }
      if (typeof fn !== "function") {
        throw new Error("You must pass a function to execute");
      }
      var deferredResolve = null;
      var deferredReject = null;
      var deferred = null;
      if (typeof cb !== "function") {
        opts = cb;
        cb = null;
        deferred = new this.Promise(function(resolve, reject) {
          deferredResolve = resolve;
          deferredReject = reject;
        });
      }
      opts = opts || {};
      var resolved = false;
      var timer = null;
      var occupationTimer = null;
      var executionTimer = null;
      var self2 = this;
      var done = /* @__PURE__ */ __name(function(locked, err, ret) {
        if (occupationTimer) {
          clearTimeout(occupationTimer);
          occupationTimer = null;
        }
        if (executionTimer) {
          clearTimeout(executionTimer);
          executionTimer = null;
        }
        if (locked) {
          if (!!self2.queues[key] && self2.queues[key].length === 0) {
            delete self2.queues[key];
          }
          if (self2.domainReentrant) {
            delete self2.domains[key];
          }
        }
        if (!resolved) {
          if (!deferred) {
            if (typeof cb === "function") {
              cb(err, ret);
            }
          } else {
            if (err) {
              deferredReject(err);
            } else {
              deferredResolve(ret);
            }
          }
          resolved = true;
        }
        if (locked) {
          if (!!self2.queues[key] && self2.queues[key].length > 0) {
            self2.queues[key].shift()();
          }
        }
      }, "done");
      var exec = /* @__PURE__ */ __name(function(locked) {
        if (resolved) {
          return done(locked);
        }
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        if (self2.domainReentrant && locked) {
          self2.domains[key] = process.domain;
        }
        var maxExecutionTime = opts.maxExecutionTime || self2.maxExecutionTime;
        if (maxExecutionTime) {
          executionTimer = setTimeout(function() {
            if (!!self2.queues[key]) {
              done(locked, new Error("Maximum execution time is exceeded " + key));
            }
          }, maxExecutionTime);
        }
        if (fn.length === 1) {
          var called = false;
          try {
            fn(function(err, ret) {
              if (!called) {
                called = true;
                done(locked, err, ret);
              }
            });
          } catch (err) {
            if (!called) {
              called = true;
              done(locked, err);
            }
          }
        } else {
          self2._promiseTry(function() {
            return fn();
          }).then(function(ret) {
            done(locked, void 0, ret);
          }, function(error) {
            done(locked, error);
          });
        }
      }, "exec");
      if (self2.domainReentrant && !!process.domain) {
        exec = process.domain.bind(exec);
      }
      var maxPending = opts.maxPending || self2.maxPending;
      if (!self2.queues[key]) {
        self2.queues[key] = [];
        exec(true);
      } else if (self2.domainReentrant && !!process.domain && process.domain === self2.domains[key]) {
        exec(false);
      } else if (self2.queues[key].length >= maxPending) {
        done(false, new Error("Too many pending tasks in queue " + key));
      } else {
        var taskFn = /* @__PURE__ */ __name(function() {
          exec(true);
        }, "taskFn");
        if (opts.skipQueue) {
          self2.queues[key].unshift(taskFn);
        } else {
          self2.queues[key].push(taskFn);
        }
        var timeout = opts.timeout || self2.timeout;
        if (timeout) {
          timer = setTimeout(function() {
            timer = null;
            done(false, new Error("async-lock timed out in queue " + key));
          }, timeout);
        }
      }
      var maxOccupationTime = opts.maxOccupationTime || self2.maxOccupationTime;
      if (maxOccupationTime) {
        occupationTimer = setTimeout(function() {
          if (!!self2.queues[key]) {
            done(false, new Error("Maximum occupation time is exceeded in queue " + key));
          }
        }, maxOccupationTime);
      }
      if (deferred) {
        return deferred;
      }
    };
    AsyncLock.prototype._acquireBatch = function(keys, fn, cb, opts) {
      if (typeof cb !== "function") {
        opts = cb;
        cb = null;
      }
      var self2 = this;
      var getFn = /* @__PURE__ */ __name(function(key, fn2) {
        return function(cb2) {
          self2.acquire(key, fn2, cb2, opts);
        };
      }, "getFn");
      var fnx = keys.reduceRight(function(prev, key) {
        return getFn(key, prev);
      }, fn);
      if (typeof cb === "function") {
        fnx(cb);
      } else {
        return new this.Promise(function(resolve, reject) {
          if (fnx.length === 1) {
            fnx(function(err, ret) {
              if (err) {
                reject(err);
              } else {
                resolve(ret);
              }
            });
          } else {
            resolve(fnx());
          }
        });
      }
    };
    AsyncLock.prototype.isBusy = function(key) {
      if (!key) {
        return Object.keys(this.queues).length > 0;
      } else {
        return !!this.queues[key];
      }
    };
    AsyncLock.prototype._promiseTry = function(fn) {
      try {
        return this.Promise.resolve(fn());
      } catch (e) {
        return this.Promise.reject(e);
      }
    };
    module.exports = AsyncLock;
  }
});

// ../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/index.js
var require_async_lock = __commonJS({
  "../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib5();
  }
});

// ../../node_modules/.pnpm/isarray@2.0.5/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../../node_modules/.pnpm/isarray@2.0.5/node_modules/isarray/index.js"(exports, module) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../../node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "../../node_modules/.pnpm/is-callable@1.2.7/node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: /* @__PURE__ */ __name(function() {
            throw isCallableMarker;
          }, "get")
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = /* @__PURE__ */ __name(function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    }, "isES6ClassFunction");
    var tryFunctionObject = /* @__PURE__ */ __name(function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    }, "tryFunctionToStr");
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = /* @__PURE__ */ __name(function isDocumentDotAll() {
      return false;
    }, "isDocumentDotAll");
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = /* @__PURE__ */ __name(function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        }, "isDocumentDotAll");
      }
    }
    var all;
    module.exports = reflectApply ? /* @__PURE__ */ __name(function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    }, "isCallable") : /* @__PURE__ */ __name(function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    }, "isCallable");
  }
});

// ../../node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js
var require_for_each = __commonJS({
  "../../node_modules/.pnpm/for-each@0.3.5/node_modules/for-each/index.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = /* @__PURE__ */ __name(function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    }, "forEachArray");
    var forEachString = /* @__PURE__ */ __name(function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    }, "forEachString");
    var forEachObject = /* @__PURE__ */ __name(function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    }, "forEachObject");
    function isArray(x) {
      return toStr.call(x) === "[object Array]";
    }
    __name(isArray, "isArray");
    module.exports = /* @__PURE__ */ __name(function forEach(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (isArray(list)) {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    }, "forEach");
  }
});

// ../../node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "../../node_modules/.pnpm/possible-typed-array-names@1.1.0/node_modules/possible-typed-array-names/index.js"(exports, module) {
    "use strict";
    module.exports = [
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// ../../node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "../../node_modules/.pnpm/available-typed-arrays@1.0.7/node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    module.exports = /* @__PURE__ */ __name(function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    }, "availableTypedArrays");
  }
});

// ../../node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "../../node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = /* @__PURE__ */ __name(function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    }, "defineDataProperty");
  }
});

// ../../node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../../node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = /* @__PURE__ */ __name(function hasPropertyDescriptors2() {
      return !!$defineProperty;
    }, "hasPropertyDescriptors");
    hasPropertyDescriptors.hasArrayLengthDefineBug = /* @__PURE__ */ __name(function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    }, "hasArrayLengthDefineBug");
    module.exports = hasPropertyDescriptors;
  }
});

// ../../node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "../../node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = /* @__PURE__ */ __name(function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    }, "setFunctionLength");
  }
});

// ../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "../../node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module.exports = /* @__PURE__ */ __name(function applyBind() {
      return actualApply(bind, $apply, arguments);
    }, "applyBind");
  }
});

// ../../node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../../node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module.exports = /* @__PURE__ */ __name(function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    }, "callBind");
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// ../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../../node_modules/.pnpm/has-tostringtag@1.0.2/node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = /* @__PURE__ */ __name(function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    }, "hasToStringTagShams");
  }
});

// ../../node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "../../node_modules/.pnpm/which-typed-array@1.1.19/node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var gOPD = require_gopd();
    var getProto = require_get_proto();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var $indexOf = callBound("Array.prototype.indexOf", true) || /* @__PURE__ */ __name(function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    }, "indexOf");
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getProto) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
          var proto = getProto(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor && proto) {
            var superProto = getProto(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache[
            /** @type {`$${import('.').TypedArrayName}`} */
            "$" + typedArray
          ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
          // @ts-expect-error TODO FIXME
          callBind(fn);
        }
      });
    }
    var tryTypedArrays = /* @__PURE__ */ __name(function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = /** @type {import('.').TypedArrayName} */
                $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    }, "tryAllTypedArrays");
    var trySlices = /* @__PURE__ */ __name(function tryAllSlices(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = /** @type {import('.').TypedArrayName} */
              $slice(name, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    }, "tryAllSlices");
    module.exports = /* @__PURE__ */ __name(function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    }, "whichTypedArray");
  }
});

// ../../node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "../../node_modules/.pnpm/is-typed-array@1.1.15/node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    var whichTypedArray = require_which_typed_array();
    module.exports = /* @__PURE__ */ __name(function isTypedArray(value) {
      return !!whichTypedArray(value);
    }, "isTypedArray");
  }
});

// ../../node_modules/.pnpm/typed-array-buffer@1.0.3/node_modules/typed-array-buffer/index.js
var require_typed_array_buffer = __commonJS({
  "../../node_modules/.pnpm/typed-array-buffer@1.0.3/node_modules/typed-array-buffer/index.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var callBound = require_call_bound();
    var $typedArrayBuffer = callBound("TypedArray.prototype.buffer", true);
    var isTypedArray = require_is_typed_array();
    module.exports = $typedArrayBuffer || /* @__PURE__ */ __name(function typedArrayBuffer(x) {
      if (!isTypedArray(x)) {
        throw new $TypeError("Not a Typed Array");
      }
      return x.buffer;
    }, "typedArrayBuffer");
  }
});

// ../../node_modules/.pnpm/to-buffer@1.2.2/node_modules/to-buffer/index.js
var require_to_buffer = __commonJS({
  "../../node_modules/.pnpm/to-buffer@1.2.2/node_modules/to-buffer/index.js"(exports, module) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var isArray = require_isarray();
    var typedArrayBuffer = require_typed_array_buffer();
    var isView = ArrayBuffer.isView || /* @__PURE__ */ __name(function isView2(obj) {
      try {
        typedArrayBuffer(obj);
        return true;
      } catch (e) {
        return false;
      }
    }, "isView");
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    var useFromArrayBuffer = useArrayBuffer && (Buffer3.prototype instanceof Uint8Array || Buffer3.TYPED_ARRAY_SUPPORT);
    module.exports = /* @__PURE__ */ __name(function toBuffer(data, encoding) {
      if (Buffer3.isBuffer(data)) {
        if (data.constructor && !("isBuffer" in data)) {
          return Buffer3.from(data);
        }
        return data;
      }
      if (typeof data === "string") {
        return Buffer3.from(data, encoding);
      }
      if (useArrayBuffer && isView(data)) {
        if (data.byteLength === 0) {
          return Buffer3.alloc(0);
        }
        if (useFromArrayBuffer) {
          var res = Buffer3.from(data.buffer, data.byteOffset, data.byteLength);
          if (res.byteLength === data.byteLength) {
            return res;
          }
        }
        var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        var result = Buffer3.from(uint8);
        if (result.length === data.byteLength) {
          return result;
        }
      }
      if (useUint8Array && data instanceof Uint8Array) {
        return Buffer3.from(data);
      }
      var isArr = isArray(data);
      if (isArr) {
        for (var i = 0; i < data.length; i += 1) {
          var x = data[i];
          if (typeof x !== "number" || x < 0 || x > 255 || ~~x !== x) {
            throw new RangeError("Array items must be numbers in the range 0-255.");
          }
        }
      }
      if (isArr || Buffer3.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
        return Buffer3.from(data);
      }
      throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
    }, "toBuffer");
  }
});

// ../../node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "../../node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/hash.js"(exports, module) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer();
    function Hash(blockSize, finalSize) {
      this._block = Buffer3.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    __name(Hash, "Hash");
    Hash.prototype.update = function(data, enc) {
      data = toBuffer(data, enc || "utf8");
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// ../../node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "../../node_modules/.pnpm/sha.js@2.4.12/node_modules/sha.js/sha1.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer3 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    __name(Sha1, "Sha1");
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    __name(rotl1, "rotl1");
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    __name(rotl5, "rotl5");
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    __name(rotl30, "rotl30");
    function ft(s, b, c, d) {
      if (s === 0) {
        return b & c | ~b & d;
      }
      if (s === 2) {
        return b & c | b & d | c & d;
      }
      return b ^ c ^ d;
    }
    __name(ft, "ft");
    Sha1.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer3.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha1;
  }
});

// ../../node_modules/.pnpm/crc-32@1.2.2/node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "../../node_modules/.pnpm/crc-32@1.2.2/node_modules/crc-32/crc32.js"(exports) {
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.2";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      __name(signed_crc_table, "signed_crc_table");
      var T0 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n) table[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256) v = table[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
      }
      __name(slice_by_16_tables, "slice_by_16_tables");
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = bstr.length; i < L; ) C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
        return ~C;
      }
      __name(crc32_bstr, "crc32_bstr");
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for (; i < L; ) C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
        L += 15;
        while (i < L) C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
        return ~C;
      }
      __name(crc32_buf, "crc32_buf");
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T0[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      __name(crc32_str, "crc32_str");
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    __name(_has, "_has");
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: /* @__PURE__ */ __name(function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      }, "arraySet"),
      // Join array of chunks to single array.
      flattenChunks: /* @__PURE__ */ __name(function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }, "flattenChunks")
    };
    var fnUntyped = {
      arraySet: /* @__PURE__ */ __name(function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      }, "arraySet"),
      // Join array of chunks to single array.
      flattenChunks: /* @__PURE__ */ __name(function(chunks) {
        return [].concat.apply([], chunks);
      }, "flattenChunks")
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    __name(zero, "zero");
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    __name(StaticTreeDesc, "StaticTreeDesc");
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    __name(TreeDesc, "TreeDesc");
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    __name(d_code, "d_code");
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    __name(put_short, "put_short");
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    __name(send_bits, "send_bits");
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    __name(send_code, "send_code");
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    __name(bi_reverse, "bi_reverse");
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    __name(bi_flush, "bi_flush");
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    __name(gen_bitlen, "gen_bitlen");
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    __name(gen_codes, "gen_codes");
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    __name(tr_static_init, "tr_static_init");
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    __name(init_block, "init_block");
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    __name(bi_windup, "bi_windup");
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    __name(copy_block, "copy_block");
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    __name(smaller, "smaller");
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    __name(pqdownheap, "pqdownheap");
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    __name(compress_block, "compress_block");
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    __name(build_tree, "build_tree");
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    __name(scan_tree, "scan_tree");
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    __name(send_tree, "send_tree");
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    __name(build_bl_tree, "build_bl_tree");
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    __name(send_all_trees, "send_all_trees");
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    __name(detect_data_type, "detect_data_type");
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    __name(_tr_init, "_tr_init");
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    __name(_tr_stored_block, "_tr_stored_block");
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    __name(_tr_align, "_tr_align");
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    __name(_tr_flush_block, "_tr_flush_block");
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    __name(_tr_tally, "_tr_tally");
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    __name(adler32, "adler32");
    module.exports = adler32;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    __name(makeTable, "makeTable");
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    __name(crc32, "crc32");
    module.exports = crc32;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    __name(err, "err");
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    __name(rank, "rank");
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    __name(zero, "zero");
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    __name(flush_pending, "flush_pending");
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    __name(flush_block_only, "flush_block_only");
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    __name(put_byte, "put_byte");
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    __name(putShortMSB, "putShortMSB");
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    __name(read_buf, "read_buf");
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    __name(longest_match, "longest_match");
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    __name(fill_window, "fill_window");
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    __name(deflate_stored, "deflate_stored");
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    __name(deflate_fast, "deflate_fast");
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    __name(deflate_slow, "deflate_slow");
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    __name(deflate_rle, "deflate_rle");
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    __name(deflate_huff, "deflate_huff");
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    __name(Config, "Config");
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    __name(lm_init, "lm_init");
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    __name(DeflateState, "DeflateState");
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    __name(deflateResetKeep, "deflateResetKeep");
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    __name(deflateReset, "deflateReset");
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    __name(deflateSetHeader, "deflateSetHeader");
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    __name(deflateInit2, "deflateInit2");
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    __name(deflateInit, "deflateInit");
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    __name(deflate, "deflate");
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    __name(deflateEnd, "deflateEnd");
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    __name(deflateSetDictionary, "deflateSetDictionary");
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    __name(buf2binstring, "buf2binstring");
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    __name(ZStream, "ZStream");
    module.exports = ZStream;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate)) return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    __name(Deflate, "Deflate");
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    __name(deflate, "deflate");
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    __name(deflateRaw, "deflateRaw");
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    __name(gzip, "gzip");
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module.exports = /* @__PURE__ */ __name(function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    }, "inflate_fast");
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = /* @__PURE__ */ __name(function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    }, "inflate_table");
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    __name(zswap32, "zswap32");
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    __name(InflateState, "InflateState");
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    __name(inflateResetKeep, "inflateResetKeep");
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    __name(inflateReset, "inflateReset");
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    __name(inflateReset2, "inflateReset2");
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    __name(inflateInit2, "inflateInit2");
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    __name(inflateInit, "inflateInit");
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    __name(fixedtables, "fixedtables");
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    __name(updatewindow, "updatewindow");
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            /* falls through */
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            /* falls through */
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            /* falls through */
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            /* falls through */
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            /* falls through */
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            /* falls through */
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            /* falls through */
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            /* falls through */
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            /* falls through */
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case COPY_:
              state.mode = COPY;
            /* falls through */
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            /* falls through */
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            /* falls through */
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case LEN_:
              state.mode = LEN;
            /* falls through */
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            /* falls through */
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            /* falls through */
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            /* falls through */
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            /* falls through */
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            /* falls through */
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            /* falls through */
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            /* falls through */
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    __name(inflate, "inflate");
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    __name(inflateEnd, "inflateEnd");
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    __name(inflateGetHeader, "inflateGetHeader");
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    __name(inflateSetDictionary, "inflateSetDictionary");
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js
var require_constants3 = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    __name(GZheader, "GZheader");
    module.exports = GZheader;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants3();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate)) return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    __name(Inflate, "Inflate");
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    __name(inflate, "inflate");
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    __name(inflateRaw, "inflateRaw");
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js
var require_pako = __commonJS({
  "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js"(exports, module) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants3();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module.exports = pako;
  }
});

// ../../node_modules/.pnpm/pify@4.0.1/node_modules/pify/index.js
var require_pify = __commonJS({
  "../../node_modules/.pnpm/pify@4.0.1/node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = /* @__PURE__ */ __name((fn, options) => function(...args) {
      const P = options.promiseModule;
      return new P((resolve, reject) => {
        if (options.multiArgs) {
          args.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          args.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          args.push(resolve);
        }
        fn.apply(this, args);
      });
    }, "processFn");
    module.exports = (input, options) => {
      options = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, options);
      const objType = typeof input;
      if (!(input !== null && (objType === "object" || objType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objType}\``);
      }
      const filter = /* @__PURE__ */ __name((key) => {
        const match = /* @__PURE__ */ __name((pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key), "match");
        return options.include ? options.include.some(match) : !options.exclude.some(match);
      }, "filter");
      let ret;
      if (objType === "function") {
        ret = /* @__PURE__ */ __name(function(...args) {
          return options.excludeMain ? input(...args) : processFn(input, options).apply(this, args);
        }, "ret");
      } else {
        ret = Object.create(Object.getPrototypeOf(input));
      }
      for (const key in input) {
        const property = input[key];
        ret[key] = typeof property === "function" && filter(key) ? processFn(property, options) : property;
      }
      return ret;
    };
  }
});

// ../../node_modules/.pnpm/ignore@5.3.2/node_modules/ignore/index.js
var require_ignore2 = __commonJS({
  "../../node_modules/.pnpm/ignore@5.3.2/node_modules/ignore/index.js"(exports, module) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    __name(makeArray, "makeArray");
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define2 = /* @__PURE__ */ __name((object, key, value) => Object.defineProperty(object, key, { value }), "define");
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = /* @__PURE__ */ __name(() => false, "RETURN_FALSE");
    var sanitizeRange = /* @__PURE__ */ __name((range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    ), "sanitizeRange");
    var cleanRangeBackSlash = /* @__PURE__ */ __name((slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    }, "cleanRangeBackSlash");
    var REPLACERS = [
      [
        // remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
      ],
      // replace (\ ) with ' '
      // (\ ) -> ' '
      // (\\ ) -> '\\ '
      // (\\\ ) -> '\\ '
      [
        /(\\+?)\s/g,
        (_, m1) => {
          const { length } = m1;
          return m1.slice(0, length - length % 2) + SPACE;
        }
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        /* @__PURE__ */ __name(function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }, "startingReplacer")
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index2, str) => index2 + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = /* @__PURE__ */ __name((pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    }, "makeRegex");
    var isString = /* @__PURE__ */ __name((subject) => typeof subject === "string", "isString");
    var checkPattern = /* @__PURE__ */ __name((pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0, "checkPattern");
    var splitPattern = /* @__PURE__ */ __name((pattern) => pattern.split(REGEX_SPLITALL_CRLF), "splitPattern");
    var _IgnoreRule = class _IgnoreRule {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    __name(_IgnoreRule, "IgnoreRule");
    var IgnoreRule = _IgnoreRule;
    var createRule = /* @__PURE__ */ __name((pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    }, "createRule");
    var throwError = /* @__PURE__ */ __name((message, Ctor) => {
      throw new Ctor(message);
    }, "throwError");
    var checkPath = /* @__PURE__ */ __name((path6, originalPath, doThrow) => {
      if (!isString(path6)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path6) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path6)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    }, "checkPath");
    var isNotRelative = /* @__PURE__ */ __name((path6) => REGEX_TEST_INVALID_PATH.test(path6), "isNotRelative");
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var _Ignore = class _Ignore {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path6, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path6);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path6 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path6,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path6, cache, checkUnignored, slices);
      }
      _t(path6, cache, checkUnignored, slices) {
        if (path6 in cache) {
          return cache[path6];
        }
        if (!slices) {
          slices = path6.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path6] = this._testOne(path6, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path6] = parent.ignored ? parent : this._testOne(path6, checkUnignored);
      }
      ignores(path6) {
        return this._test(path6, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path6) => !this.ignores(path6);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path6) {
        return this._test(path6, this._testCache, true);
      }
    };
    __name(_Ignore, "Ignore");
    var Ignore = _Ignore;
    var factory = /* @__PURE__ */ __name((options) => new Ignore(options), "factory");
    var isPathValid = /* @__PURE__ */ __name((path6) => checkPath(path6 && checkPath.convert(path6), path6, RETURN_FALSE), "isPathValid");
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = /* @__PURE__ */ __name((str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/"), "makePosix");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path6) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path6) || isNotRelative(path6);
    }
  }
});

// ../../node_modules/.pnpm/clean-git-ref@2.0.1/node_modules/clean-git-ref/lib/index.js
var require_lib6 = __commonJS({
  "../../node_modules/.pnpm/clean-git-ref@2.0.1/node_modules/clean-git-ref/lib/index.js"(exports, module) {
    "use strict";
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    __name(escapeRegExp, "escapeRegExp");
    function replaceAll(str, search, replacement) {
      search = search instanceof RegExp ? search : new RegExp(escapeRegExp(search), "g");
      return str.replace(search, replacement);
    }
    __name(replaceAll, "replaceAll");
    var CleanGitRef = {
      clean: /* @__PURE__ */ __name(function clean(value) {
        if (typeof value !== "string") {
          throw new Error("Expected a string, received: " + value);
        }
        value = replaceAll(value, "./", "/");
        value = replaceAll(value, "..", ".");
        value = replaceAll(value, " ", "-");
        value = replaceAll(value, /^[~^:?*\\\-]/g, "");
        value = replaceAll(value, /[~^:?*\\]/g, "-");
        value = replaceAll(value, /[~^:?*\\\-]$/g, "");
        value = replaceAll(value, "@{", "-");
        value = replaceAll(value, /\.$/g, "");
        value = replaceAll(value, /\/$/g, "");
        value = replaceAll(value, /\.lock$/g, "");
        return value;
      }, "clean")
    };
    module.exports = CleanGitRef;
  }
});

// ../../node_modules/.pnpm/is-git-ref-name-valid@1.0.0/node_modules/is-git-ref-name-valid/index.js
var require_is_git_ref_name_valid = __commonJS({
  "../../node_modules/.pnpm/is-git-ref-name-valid@1.0.0/node_modules/is-git-ref-name-valid/index.js"(exports, module) {
    "use strict";
    var bad = /(^|[/.])([/.]|$)|^@$|@{|[\x00-\x20\x7f~^:?*[\\]|\.lock(\/|$)/;
    module.exports = /* @__PURE__ */ __name(function validRef(name, onelevel) {
      if (typeof name !== "string") {
        throw new TypeError("Reference name must be a string");
      }
      return !bad.test(name) && (!!onelevel || name.includes("/"));
    }, "validRef");
  }
});

// ../../node_modules/.pnpm/diff3@0.0.3/node_modules/diff3/onp.js
var require_onp = __commonJS({
  "../../node_modules/.pnpm/diff3@0.0.3/node_modules/diff3/onp.js"(exports, module) {
    module.exports = function(a_, b_) {
      var a = a_, b = b_, m = a.length, n = b.length, reverse = false, ed = null, offset = m + 1, path6 = [], pathposi = [], ses = [], lcs = "", SES_DELETE = -1, SES_COMMON = 0, SES_ADD = 1;
      var tmp1, tmp2;
      var init = /* @__PURE__ */ __name(function() {
        if (m >= n) {
          tmp1 = a;
          tmp2 = m;
          a = b;
          b = tmp1;
          m = n;
          n = tmp2;
          reverse = true;
          offset = m + 1;
        }
      }, "init");
      var P = /* @__PURE__ */ __name(function(x, y, k) {
        return {
          "x": x,
          "y": y,
          "k": k
        };
      }, "P");
      var seselem = /* @__PURE__ */ __name(function(elem, t) {
        return {
          "elem": elem,
          "t": t
        };
      }, "seselem");
      var snake = /* @__PURE__ */ __name(function(k, p, pp) {
        var r, x, y;
        if (p > pp) {
          r = path6[k - 1 + offset];
        } else {
          r = path6[k + 1 + offset];
        }
        y = Math.max(p, pp);
        x = y - k;
        while (x < m && y < n && a[x] === b[y]) {
          ++x;
          ++y;
        }
        path6[k + offset] = pathposi.length;
        pathposi[pathposi.length] = new P(x, y, r);
        return y;
      }, "snake");
      var recordseq = /* @__PURE__ */ __name(function(epc) {
        var x_idx, y_idx, px_idx, py_idx, i;
        x_idx = y_idx = 1;
        px_idx = py_idx = 0;
        for (i = epc.length - 1; i >= 0; --i) {
          while (px_idx < epc[i].x || py_idx < epc[i].y) {
            if (epc[i].y - epc[i].x > py_idx - px_idx) {
              if (reverse) {
                ses[ses.length] = new seselem(b[py_idx], SES_DELETE);
              } else {
                ses[ses.length] = new seselem(b[py_idx], SES_ADD);
              }
              ++y_idx;
              ++py_idx;
            } else if (epc[i].y - epc[i].x < py_idx - px_idx) {
              if (reverse) {
                ses[ses.length] = new seselem(a[px_idx], SES_ADD);
              } else {
                ses[ses.length] = new seselem(a[px_idx], SES_DELETE);
              }
              ++x_idx;
              ++px_idx;
            } else {
              ses[ses.length] = new seselem(a[px_idx], SES_COMMON);
              lcs += a[px_idx];
              ++x_idx;
              ++y_idx;
              ++px_idx;
              ++py_idx;
            }
          }
        }
      }, "recordseq");
      init();
      return {
        SES_DELETE: -1,
        SES_COMMON: 0,
        SES_ADD: 1,
        editdistance: /* @__PURE__ */ __name(function() {
          return ed;
        }, "editdistance"),
        getlcs: /* @__PURE__ */ __name(function() {
          return lcs;
        }, "getlcs"),
        getses: /* @__PURE__ */ __name(function() {
          return ses;
        }, "getses"),
        compose: /* @__PURE__ */ __name(function() {
          var delta, size, fp, p, r, epc, i, k;
          delta = n - m;
          size = m + n + 3;
          fp = {};
          for (i = 0; i < size; ++i) {
            fp[i] = -1;
            path6[i] = -1;
          }
          p = -1;
          do {
            ++p;
            for (k = -p; k <= delta - 1; ++k) {
              fp[k + offset] = snake(k, fp[k - 1 + offset] + 1, fp[k + 1 + offset]);
            }
            for (k = delta + p; k >= delta + 1; --k) {
              fp[k + offset] = snake(k, fp[k - 1 + offset] + 1, fp[k + 1 + offset]);
            }
            fp[delta + offset] = snake(delta, fp[delta - 1 + offset] + 1, fp[delta + 1 + offset]);
          } while (fp[delta + offset] !== n);
          ed = delta + 2 * p;
          r = path6[delta + offset];
          epc = [];
          while (r !== -1) {
            epc[epc.length] = new P(pathposi[r].x, pathposi[r].y, null);
            r = pathposi[r].k;
          }
          recordseq(epc);
        }, "compose")
      };
    };
  }
});

// ../../node_modules/.pnpm/diff3@0.0.3/node_modules/diff3/diff3.js
var require_diff3 = __commonJS({
  "../../node_modules/.pnpm/diff3@0.0.3/node_modules/diff3/diff3.js"(exports, module) {
    var onp = require_onp();
    function longestCommonSubsequence(file1, file2) {
      var diff = new onp(file1, file2);
      diff.compose();
      var ses = diff.getses();
      var root;
      var prev;
      var file1RevIdx = file1.length - 1, file2RevIdx = file2.length - 1;
      for (var i = ses.length - 1; i >= 0; --i) {
        if (ses[i].t === diff.SES_COMMON) {
          if (prev) {
            prev.chain = {
              file1index: file1RevIdx,
              file2index: file2RevIdx,
              chain: null
            };
            prev = prev.chain;
          } else {
            root = {
              file1index: file1RevIdx,
              file2index: file2RevIdx,
              chain: null
            };
            prev = root;
          }
          file1RevIdx--;
          file2RevIdx--;
        } else if (ses[i].t === diff.SES_DELETE) {
          file1RevIdx--;
        } else if (ses[i].t === diff.SES_ADD) {
          file2RevIdx--;
        }
      }
      var tail = {
        file1index: -1,
        file2index: -1,
        chain: null
      };
      if (!prev) {
        return tail;
      }
      prev.chain = tail;
      return root;
    }
    __name(longestCommonSubsequence, "longestCommonSubsequence");
    function diffIndices(file1, file2) {
      var result = [];
      var tail1 = file1.length;
      var tail2 = file2.length;
      for (var candidate = longestCommonSubsequence(file1, file2); candidate !== null; candidate = candidate.chain) {
        var mismatchLength1 = tail1 - candidate.file1index - 1;
        var mismatchLength2 = tail2 - candidate.file2index - 1;
        tail1 = candidate.file1index;
        tail2 = candidate.file2index;
        if (mismatchLength1 || mismatchLength2) {
          result.push({
            file1: [tail1 + 1, mismatchLength1],
            file2: [tail2 + 1, mismatchLength2]
          });
        }
      }
      result.reverse();
      return result;
    }
    __name(diffIndices, "diffIndices");
    function diff3MergeIndices(a, o, b) {
      var i;
      var m1 = diffIndices(o, a);
      var m2 = diffIndices(o, b);
      var hunks = [];
      function addHunk(h, side2) {
        hunks.push([h.file1[0], side2, h.file1[1], h.file2[0], h.file2[1]]);
      }
      __name(addHunk, "addHunk");
      for (i = 0; i < m1.length; i++) {
        addHunk(m1[i], 0);
      }
      for (i = 0; i < m2.length; i++) {
        addHunk(m2[i], 2);
      }
      hunks.sort(function(x, y) {
        return x[0] - y[0];
      });
      var result = [];
      var commonOffset = 0;
      function copyCommon(targetOffset) {
        if (targetOffset > commonOffset) {
          result.push([1, commonOffset, targetOffset - commonOffset]);
          commonOffset = targetOffset;
        }
      }
      __name(copyCommon, "copyCommon");
      for (var hunkIndex = 0; hunkIndex < hunks.length; hunkIndex++) {
        var firstHunkIndex = hunkIndex;
        var hunk = hunks[hunkIndex];
        var regionLhs = hunk[0];
        var regionRhs = regionLhs + hunk[2];
        while (hunkIndex < hunks.length - 1) {
          var maybeOverlapping = hunks[hunkIndex + 1];
          var maybeLhs = maybeOverlapping[0];
          if (maybeLhs > regionRhs) break;
          regionRhs = Math.max(regionRhs, maybeLhs + maybeOverlapping[2]);
          hunkIndex++;
        }
        copyCommon(regionLhs);
        if (firstHunkIndex == hunkIndex) {
          if (hunk[4] > 0) {
            result.push([hunk[1], hunk[3], hunk[4]]);
          }
        } else {
          var regions = {
            0: [a.length, -1, o.length, -1],
            2: [b.length, -1, o.length, -1]
          };
          for (i = firstHunkIndex; i <= hunkIndex; i++) {
            hunk = hunks[i];
            var side = hunk[1];
            var r = regions[side];
            var oLhs = hunk[0];
            var oRhs = oLhs + hunk[2];
            var abLhs = hunk[3];
            var abRhs = abLhs + hunk[4];
            r[0] = Math.min(abLhs, r[0]);
            r[1] = Math.max(abRhs, r[1]);
            r[2] = Math.min(oLhs, r[2]);
            r[3] = Math.max(oRhs, r[3]);
          }
          var aLhs = regions[0][0] + (regionLhs - regions[0][2]);
          var aRhs = regions[0][1] + (regionRhs - regions[0][3]);
          var bLhs = regions[2][0] + (regionLhs - regions[2][2]);
          var bRhs = regions[2][1] + (regionRhs - regions[2][3]);
          result.push([
            -1,
            aLhs,
            aRhs - aLhs,
            regionLhs,
            regionRhs - regionLhs,
            bLhs,
            bRhs - bLhs
          ]);
        }
        commonOffset = regionRhs;
      }
      copyCommon(o.length);
      return result;
    }
    __name(diff3MergeIndices, "diff3MergeIndices");
    function diff3Merge(a, o, b) {
      var result = [];
      var files = [a, o, b];
      var indices = diff3MergeIndices(a, o, b);
      var okLines = [];
      function flushOk() {
        if (okLines.length) {
          result.push({
            ok: okLines
          });
        }
        okLines = [];
      }
      __name(flushOk, "flushOk");
      function pushOk(xs) {
        for (var j = 0; j < xs.length; j++) {
          okLines.push(xs[j]);
        }
      }
      __name(pushOk, "pushOk");
      function isTrueConflict(rec) {
        if (rec[2] != rec[6]) return true;
        var aoff = rec[1];
        var boff = rec[5];
        for (var j = 0; j < rec[2]; j++) {
          if (a[j + aoff] != b[j + boff]) return true;
        }
        return false;
      }
      __name(isTrueConflict, "isTrueConflict");
      for (var i = 0; i < indices.length; i++) {
        var x = indices[i];
        var side = x[0];
        if (side == -1) {
          if (!isTrueConflict(x)) {
            pushOk(files[0].slice(x[1], x[1] + x[2]));
          } else {
            flushOk();
            result.push({
              conflict: {
                a: a.slice(x[1], x[1] + x[2]),
                aIndex: x[1],
                o: o.slice(x[3], x[3] + x[4]),
                oIndex: x[3],
                b: b.slice(x[5], x[5] + x[6]),
                bIndex: x[5]
              }
            });
          }
        } else {
          pushOk(files[side].slice(x[1], x[1] + x[2]));
        }
      }
      flushOk();
      return result;
    }
    __name(diff3Merge, "diff3Merge");
    module.exports = diff3Merge;
  }
});

// ../../node_modules/.pnpm/isomorphic-git@1.34.0/node_modules/isomorphic-git/index.cjs
var require_isomorphic_git = __commonJS({
  "../../node_modules/.pnpm/isomorphic-git@1.34.0/node_modules/isomorphic-git/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    __name(_interopDefault, "_interopDefault");
    var AsyncLock = _interopDefault(require_async_lock());
    var Hash = _interopDefault(require_sha1());
    var pathBrowserify = require_path_browserify();
    var crc32 = _interopDefault(require_crc32());
    var pako = _interopDefault(require_pako());
    var pify = _interopDefault(require_pify());
    var ignore3 = _interopDefault(require_ignore2());
    var cleanGitRef = _interopDefault(require_lib6());
    var validRef = _interopDefault(require_is_git_ref_name_valid());
    var diff3Merge = _interopDefault(require_diff3());
    var _BaseError = class _BaseError extends Error {
      constructor(message) {
        super(message);
        this.caller = "";
      }
      toJSON() {
        return {
          code: this.code,
          data: this.data,
          caller: this.caller,
          message: this.message,
          stack: this.stack
        };
      }
      fromJSON(json) {
        const e = new _BaseError(json.message);
        e.code = json.code;
        e.data = json.data;
        e.caller = json.caller;
        e.stack = json.stack;
        return e;
      }
      get isIsomorphicGitError() {
        return true;
      }
    };
    __name(_BaseError, "BaseError");
    var BaseError = _BaseError;
    var _UnmergedPathsError = class _UnmergedPathsError extends BaseError {
      /**
       * @param {Array<string>} filepaths
       */
      constructor(filepaths) {
        super(
          `Modifying the index is not possible because you have unmerged files: ${filepaths.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`
        );
        this.code = this.name = _UnmergedPathsError.code;
        this.data = { filepaths };
      }
    };
    __name(_UnmergedPathsError, "UnmergedPathsError");
    var UnmergedPathsError = _UnmergedPathsError;
    UnmergedPathsError.code = "UnmergedPathsError";
    var _InternalError = class _InternalError extends BaseError {
      /**
       * @param {string} message
       */
      constructor(message) {
        super(
          `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`
        );
        this.code = this.name = _InternalError.code;
        this.data = { message };
      }
    };
    __name(_InternalError, "InternalError");
    var InternalError = _InternalError;
    InternalError.code = "InternalError";
    var _UnsafeFilepathError = class _UnsafeFilepathError extends BaseError {
      /**
       * @param {string} filepath
       */
      constructor(filepath) {
        super(`The filepath "${filepath}" contains unsafe character sequences`);
        this.code = this.name = _UnsafeFilepathError.code;
        this.data = { filepath };
      }
    };
    __name(_UnsafeFilepathError, "UnsafeFilepathError");
    var UnsafeFilepathError = _UnsafeFilepathError;
    UnsafeFilepathError.code = "UnsafeFilepathError";
    var _BufferCursor = class _BufferCursor {
      constructor(buffer) {
        this.buffer = buffer;
        this._start = 0;
      }
      eof() {
        return this._start >= this.buffer.length;
      }
      tell() {
        return this._start;
      }
      seek(n) {
        this._start = n;
      }
      slice(n) {
        const r = this.buffer.slice(this._start, this._start + n);
        this._start += n;
        return r;
      }
      toString(enc, length) {
        const r = this.buffer.toString(enc, this._start, this._start + length);
        this._start += length;
        return r;
      }
      write(value, length, enc) {
        const r = this.buffer.write(value, this._start, length, enc);
        this._start += length;
        return r;
      }
      copy(source, start, end) {
        const r = source.copy(this.buffer, this._start, start, end);
        this._start += r;
        return r;
      }
      readUInt8() {
        const r = this.buffer.readUInt8(this._start);
        this._start += 1;
        return r;
      }
      writeUInt8(value) {
        const r = this.buffer.writeUInt8(value, this._start);
        this._start += 1;
        return r;
      }
      readUInt16BE() {
        const r = this.buffer.readUInt16BE(this._start);
        this._start += 2;
        return r;
      }
      writeUInt16BE(value) {
        const r = this.buffer.writeUInt16BE(value, this._start);
        this._start += 2;
        return r;
      }
      readUInt32BE() {
        const r = this.buffer.readUInt32BE(this._start);
        this._start += 4;
        return r;
      }
      writeUInt32BE(value) {
        const r = this.buffer.writeUInt32BE(value, this._start);
        this._start += 4;
        return r;
      }
    };
    __name(_BufferCursor, "BufferCursor");
    var BufferCursor = _BufferCursor;
    function compareStrings(a, b) {
      return -(a < b) || +(a > b);
    }
    __name(compareStrings, "compareStrings");
    function comparePath(a, b) {
      return compareStrings(a.path, b.path);
    }
    __name(comparePath, "comparePath");
    function normalizeMode(mode) {
      let type = mode > 0 ? mode >> 12 : 0;
      if (type !== 4 && type !== 8 && type !== 10 && type !== 14) {
        type = 8;
      }
      let permissions = mode & 511;
      if (permissions & 73) {
        permissions = 493;
      } else {
        permissions = 420;
      }
      if (type !== 8) permissions = 0;
      return (type << 12) + permissions;
    }
    __name(normalizeMode, "normalizeMode");
    var MAX_UINT32 = 2 ** 32;
    function SecondsNanoseconds(givenSeconds, givenNanoseconds, milliseconds, date) {
      if (givenSeconds !== void 0 && givenNanoseconds !== void 0) {
        return [givenSeconds, givenNanoseconds];
      }
      if (milliseconds === void 0) {
        milliseconds = date.valueOf();
      }
      const seconds = Math.floor(milliseconds / 1e3);
      const nanoseconds = (milliseconds - seconds * 1e3) * 1e6;
      return [seconds, nanoseconds];
    }
    __name(SecondsNanoseconds, "SecondsNanoseconds");
    function normalizeStats(e) {
      const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(
        e.ctimeSeconds,
        e.ctimeNanoseconds,
        e.ctimeMs,
        e.ctime
      );
      const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(
        e.mtimeSeconds,
        e.mtimeNanoseconds,
        e.mtimeMs,
        e.mtime
      );
      return {
        ctimeSeconds: ctimeSeconds % MAX_UINT32,
        ctimeNanoseconds: ctimeNanoseconds % MAX_UINT32,
        mtimeSeconds: mtimeSeconds % MAX_UINT32,
        mtimeNanoseconds: mtimeNanoseconds % MAX_UINT32,
        dev: e.dev % MAX_UINT32,
        ino: e.ino % MAX_UINT32,
        mode: normalizeMode(e.mode % MAX_UINT32),
        uid: e.uid % MAX_UINT32,
        gid: e.gid % MAX_UINT32,
        // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
        // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
        size: e.size > -1 ? e.size % MAX_UINT32 : 0
      };
    }
    __name(normalizeStats, "normalizeStats");
    function toHex(buffer) {
      let hex = "";
      for (const byte of new Uint8Array(buffer)) {
        if (byte < 16) hex += "0";
        hex += byte.toString(16);
      }
      return hex;
    }
    __name(toHex, "toHex");
    var supportsSubtleSHA1 = null;
    async function shasum(buffer) {
      if (supportsSubtleSHA1 === null) {
        supportsSubtleSHA1 = await testSubtleSHA1();
      }
      return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer);
    }
    __name(shasum, "shasum");
    function shasumSync(buffer) {
      return new Hash().update(buffer).digest("hex");
    }
    __name(shasumSync, "shasumSync");
    async function subtleSHA1(buffer) {
      const hash = await crypto.subtle.digest("SHA-1", buffer);
      return toHex(hash);
    }
    __name(subtleSHA1, "subtleSHA1");
    async function testSubtleSHA1() {
      try {
        const hash = await subtleSHA1(new Uint8Array([]));
        return hash === "da39a3ee5e6b4b0d3255bfef95601890afd80709";
      } catch (_) {
      }
      return false;
    }
    __name(testSubtleSHA1, "testSubtleSHA1");
    function parseCacheEntryFlags(bits) {
      return {
        assumeValid: Boolean(bits & 32768),
        extended: Boolean(bits & 16384),
        stage: (bits & 12288) >> 12,
        nameLength: bits & 4095
      };
    }
    __name(parseCacheEntryFlags, "parseCacheEntryFlags");
    function renderCacheEntryFlags(entry) {
      const flags = entry.flags;
      flags.extended = false;
      flags.nameLength = Math.min(Buffer.from(entry.path).length, 4095);
      return (flags.assumeValid ? 32768 : 0) + (flags.extended ? 16384 : 0) + ((flags.stage & 3) << 12) + (flags.nameLength & 4095);
    }
    __name(renderCacheEntryFlags, "renderCacheEntryFlags");
    var _GitIndex = class _GitIndex {
      /*::
       _entries: Map<string, CacheEntry>
       _dirty: boolean // Used to determine if index needs to be saved to filesystem
       */
      constructor(entries, unmergedPaths) {
        this._dirty = false;
        this._unmergedPaths = unmergedPaths || /* @__PURE__ */ new Set();
        this._entries = entries || /* @__PURE__ */ new Map();
      }
      _addEntry(entry) {
        if (entry.flags.stage === 0) {
          entry.stages = [entry];
          this._entries.set(entry.path, entry);
          this._unmergedPaths.delete(entry.path);
        } else {
          let existingEntry = this._entries.get(entry.path);
          if (!existingEntry) {
            this._entries.set(entry.path, entry);
            existingEntry = entry;
          }
          existingEntry.stages[entry.flags.stage] = entry;
          this._unmergedPaths.add(entry.path);
        }
      }
      static async from(buffer) {
        if (Buffer.isBuffer(buffer)) {
          return _GitIndex.fromBuffer(buffer);
        } else if (buffer === null) {
          return new _GitIndex(null);
        } else {
          throw new InternalError("invalid type passed to GitIndex.from");
        }
      }
      static async fromBuffer(buffer) {
        if (buffer.length === 0) {
          throw new InternalError("Index file is empty (.git/index)");
        }
        const index3 = new _GitIndex();
        const reader = new BufferCursor(buffer);
        const magic = reader.toString("utf8", 4);
        if (magic !== "DIRC") {
          throw new InternalError(`Invalid dircache magic file number: ${magic}`);
        }
        const shaComputed = await shasum(buffer.slice(0, -20));
        const shaClaimed = buffer.slice(-20).toString("hex");
        if (shaClaimed !== shaComputed) {
          throw new InternalError(
            `Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`
          );
        }
        const version2 = reader.readUInt32BE();
        if (version2 !== 2) {
          throw new InternalError(`Unsupported dircache version: ${version2}`);
        }
        const numEntries = reader.readUInt32BE();
        let i = 0;
        while (!reader.eof() && i < numEntries) {
          const entry = {};
          entry.ctimeSeconds = reader.readUInt32BE();
          entry.ctimeNanoseconds = reader.readUInt32BE();
          entry.mtimeSeconds = reader.readUInt32BE();
          entry.mtimeNanoseconds = reader.readUInt32BE();
          entry.dev = reader.readUInt32BE();
          entry.ino = reader.readUInt32BE();
          entry.mode = reader.readUInt32BE();
          entry.uid = reader.readUInt32BE();
          entry.gid = reader.readUInt32BE();
          entry.size = reader.readUInt32BE();
          entry.oid = reader.slice(20).toString("hex");
          const flags = reader.readUInt16BE();
          entry.flags = parseCacheEntryFlags(flags);
          const pathlength = buffer.indexOf(0, reader.tell() + 1) - reader.tell();
          if (pathlength < 1) {
            throw new InternalError(`Got a path length of: ${pathlength}`);
          }
          entry.path = reader.toString("utf8", pathlength);
          if (entry.path.includes("..\\") || entry.path.includes("../")) {
            throw new UnsafeFilepathError(entry.path);
          }
          let padding = 8 - (reader.tell() - 12) % 8;
          if (padding === 0) padding = 8;
          while (padding--) {
            const tmp = reader.readUInt8();
            if (tmp !== 0) {
              throw new InternalError(
                `Expected 1-8 null characters but got '${tmp}' after ${entry.path}`
              );
            } else if (reader.eof()) {
              throw new InternalError("Unexpected end of file");
            }
          }
          entry.stages = [];
          index3._addEntry(entry);
          i++;
        }
        return index3;
      }
      get unmergedPaths() {
        return [...this._unmergedPaths];
      }
      get entries() {
        return [...this._entries.values()].sort(comparePath);
      }
      get entriesMap() {
        return this._entries;
      }
      get entriesFlat() {
        return [...this.entries].flatMap((entry) => {
          return entry.stages.length > 1 ? entry.stages.filter((x) => x) : entry;
        });
      }
      *[Symbol.iterator]() {
        for (const entry of this.entries) {
          yield entry;
        }
      }
      insert({ filepath, stats, oid, stage = 0 }) {
        if (!stats) {
          stats = {
            ctimeSeconds: 0,
            ctimeNanoseconds: 0,
            mtimeSeconds: 0,
            mtimeNanoseconds: 0,
            dev: 0,
            ino: 0,
            mode: 0,
            uid: 0,
            gid: 0,
            size: 0
          };
        }
        stats = normalizeStats(stats);
        const bfilepath = Buffer.from(filepath);
        const entry = {
          ctimeSeconds: stats.ctimeSeconds,
          ctimeNanoseconds: stats.ctimeNanoseconds,
          mtimeSeconds: stats.mtimeSeconds,
          mtimeNanoseconds: stats.mtimeNanoseconds,
          dev: stats.dev,
          ino: stats.ino,
          // We provide a fallback value for `mode` here because not all fs
          // implementations assign it, but we use it in GitTree.
          // '100644' is for a "regular non-executable file"
          mode: stats.mode || 33188,
          uid: stats.uid,
          gid: stats.gid,
          size: stats.size,
          path: filepath,
          oid,
          flags: {
            assumeValid: false,
            extended: false,
            stage,
            nameLength: bfilepath.length < 4095 ? bfilepath.length : 4095
          },
          stages: []
        };
        this._addEntry(entry);
        this._dirty = true;
      }
      delete({ filepath }) {
        if (this._entries.has(filepath)) {
          this._entries.delete(filepath);
        } else {
          for (const key of this._entries.keys()) {
            if (key.startsWith(filepath + "/")) {
              this._entries.delete(key);
            }
          }
        }
        if (this._unmergedPaths.has(filepath)) {
          this._unmergedPaths.delete(filepath);
        }
        this._dirty = true;
      }
      clear() {
        this._entries.clear();
        this._dirty = true;
      }
      has({ filepath }) {
        return this._entries.has(filepath);
      }
      render() {
        return this.entries.map((entry) => `${entry.mode.toString(8)} ${entry.oid}    ${entry.path}`).join("\n");
      }
      static async _entryToBuffer(entry) {
        const bpath = Buffer.from(entry.path);
        const length = Math.ceil((62 + bpath.length + 1) / 8) * 8;
        const written = Buffer.alloc(length);
        const writer = new BufferCursor(written);
        const stat = normalizeStats(entry);
        writer.writeUInt32BE(stat.ctimeSeconds);
        writer.writeUInt32BE(stat.ctimeNanoseconds);
        writer.writeUInt32BE(stat.mtimeSeconds);
        writer.writeUInt32BE(stat.mtimeNanoseconds);
        writer.writeUInt32BE(stat.dev);
        writer.writeUInt32BE(stat.ino);
        writer.writeUInt32BE(stat.mode);
        writer.writeUInt32BE(stat.uid);
        writer.writeUInt32BE(stat.gid);
        writer.writeUInt32BE(stat.size);
        writer.write(entry.oid, 20, "hex");
        writer.writeUInt16BE(renderCacheEntryFlags(entry));
        writer.write(entry.path, bpath.length, "utf8");
        return written;
      }
      async toObject() {
        const header = Buffer.alloc(12);
        const writer = new BufferCursor(header);
        writer.write("DIRC", 4, "utf8");
        writer.writeUInt32BE(2);
        writer.writeUInt32BE(this.entriesFlat.length);
        let entryBuffers = [];
        for (const entry of this.entries) {
          entryBuffers.push(_GitIndex._entryToBuffer(entry));
          if (entry.stages.length > 1) {
            for (const stage of entry.stages) {
              if (stage && stage !== entry) {
                entryBuffers.push(_GitIndex._entryToBuffer(stage));
              }
            }
          }
        }
        entryBuffers = await Promise.all(entryBuffers);
        const body = Buffer.concat(entryBuffers);
        const main = Buffer.concat([header, body]);
        const sum = await shasum(main);
        return Buffer.concat([main, Buffer.from(sum, "hex")]);
      }
    };
    __name(_GitIndex, "GitIndex");
    var GitIndex = _GitIndex;
    function compareStats(entry, stats, filemode = true, trustino = true) {
      const e = normalizeStats(entry);
      const s = normalizeStats(stats);
      const staleness = filemode && e.mode !== s.mode || e.mtimeSeconds !== s.mtimeSeconds || e.ctimeSeconds !== s.ctimeSeconds || e.uid !== s.uid || e.gid !== s.gid || trustino && e.ino !== s.ino || e.size !== s.size;
      return staleness;
    }
    __name(compareStats, "compareStats");
    var lock = null;
    var IndexCache = Symbol("IndexCache");
    function createCache() {
      return {
        map: /* @__PURE__ */ new Map(),
        stats: /* @__PURE__ */ new Map()
      };
    }
    __name(createCache, "createCache");
    async function updateCachedIndexFile(fs, filepath, cache) {
      const [stat, rawIndexFile] = await Promise.all([
        fs.lstat(filepath),
        fs.read(filepath)
      ]);
      const index3 = await GitIndex.from(rawIndexFile);
      cache.map.set(filepath, index3);
      cache.stats.set(filepath, stat);
    }
    __name(updateCachedIndexFile, "updateCachedIndexFile");
    async function isIndexStale(fs, filepath, cache) {
      const savedStats = cache.stats.get(filepath);
      if (savedStats === void 0) return true;
      if (savedStats === null) return false;
      const currStats = await fs.lstat(filepath);
      if (currStats === null) return false;
      return compareStats(savedStats, currStats);
    }
    __name(isIndexStale, "isIndexStale");
    var _GitIndexManager = class _GitIndexManager {
      /**
       * Manages access to the Git index file, ensuring thread-safe operations and caching.
       *
       * @param {object} opts - Options for acquiring the Git index.
       * @param {FSClient} opts.fs - A file system implementation.
       * @param {string} opts.gitdir - The path to the `.git` directory.
       * @param {object} opts.cache - A shared cache object for storing index data.
       * @param {boolean} [opts.allowUnmerged=true] - Whether to allow unmerged paths in the index.
       * @param {function(GitIndex): any} closure - A function to execute with the Git index.
       * @returns {Promise<any>} The result of the closure function.
       * @throws {UnmergedPathsError} If unmerged paths exist and `allowUnmerged` is `false`.
       */
      static async acquire({ fs, gitdir, cache, allowUnmerged = true }, closure) {
        if (!cache[IndexCache]) {
          cache[IndexCache] = createCache();
        }
        const filepath = `${gitdir}/index`;
        if (lock === null) lock = new AsyncLock({ maxPending: Infinity });
        let result;
        let unmergedPaths = [];
        await lock.acquire(filepath, async () => {
          const theIndexCache = cache[IndexCache];
          if (await isIndexStale(fs, filepath, theIndexCache)) {
            await updateCachedIndexFile(fs, filepath, theIndexCache);
          }
          const index3 = theIndexCache.map.get(filepath);
          unmergedPaths = index3.unmergedPaths;
          if (unmergedPaths.length && !allowUnmerged)
            throw new UnmergedPathsError(unmergedPaths);
          result = await closure(index3);
          if (index3._dirty) {
            const buffer = await index3.toObject();
            await fs.write(filepath, buffer);
            theIndexCache.stats.set(filepath, await fs.lstat(filepath));
            index3._dirty = false;
          }
        });
        return result;
      }
    };
    __name(_GitIndexManager, "GitIndexManager");
    var GitIndexManager = _GitIndexManager;
    function basename2(path6) {
      const last = Math.max(path6.lastIndexOf("/"), path6.lastIndexOf("\\"));
      if (last > -1) {
        path6 = path6.slice(last + 1);
      }
      return path6;
    }
    __name(basename2, "basename");
    function dirname5(path6) {
      const last = Math.max(path6.lastIndexOf("/"), path6.lastIndexOf("\\"));
      if (last === -1) return ".";
      if (last === 0) return "/";
      return path6.slice(0, last);
    }
    __name(dirname5, "dirname");
    function flatFileListToDirectoryStructure(files) {
      const inodes = /* @__PURE__ */ new Map();
      const mkdir = /* @__PURE__ */ __name(function(name) {
        if (!inodes.has(name)) {
          const dir = {
            type: "tree",
            fullpath: name,
            basename: basename2(name),
            metadata: {},
            children: []
          };
          inodes.set(name, dir);
          dir.parent = mkdir(dirname5(name));
          if (dir.parent && dir.parent !== dir) dir.parent.children.push(dir);
        }
        return inodes.get(name);
      }, "mkdir");
      const mkfile = /* @__PURE__ */ __name(function(name, metadata) {
        if (!inodes.has(name)) {
          const file = {
            type: "blob",
            fullpath: name,
            basename: basename2(name),
            metadata,
            // This recursively generates any missing parent folders.
            parent: mkdir(dirname5(name)),
            children: []
          };
          if (file.parent) file.parent.children.push(file);
          inodes.set(name, file);
        }
        return inodes.get(name);
      }, "mkfile");
      mkdir(".");
      for (const file of files) {
        mkfile(file.path, file);
      }
      return inodes;
    }
    __name(flatFileListToDirectoryStructure, "flatFileListToDirectoryStructure");
    function mode2type(mode) {
      switch (mode) {
        case 16384:
          return "tree";
        case 33188:
          return "blob";
        case 33261:
          return "blob";
        case 40960:
          return "blob";
        case 57344:
          return "commit";
      }
      throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString(8)}`);
    }
    __name(mode2type, "mode2type");
    var _GitWalkerIndex = class _GitWalkerIndex {
      constructor({ fs, gitdir, cache }) {
        var _a;
        this.treePromise = GitIndexManager.acquire(
          { fs, gitdir, cache },
          async function(index3) {
            return flatFileListToDirectoryStructure(index3.entries);
          }
        );
        const walker = this;
        this.ConstructEntry = (_a = class {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        }, __name(_a, "StageEntry"), _a);
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const tree = await this.treePromise;
        const inode = tree.get(filepath);
        if (!inode) return null;
        if (inode.type === "blob") return null;
        if (inode.type !== "tree") {
          throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`);
        }
        const names = inode.children.map((inode2) => inode2.fullpath);
        names.sort(compareStrings);
        return names;
      }
      async type(entry) {
        if (entry._type === false) {
          await entry.stat();
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          await entry.stat();
        }
        return entry._mode;
      }
      async stat(entry) {
        if (entry._stat === false) {
          const tree = await this.treePromise;
          const inode = tree.get(entry._fullpath);
          if (!inode) {
            throw new Error(
              `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
            );
          }
          const stats = inode.type === "tree" ? {} : normalizeStats(inode.metadata);
          entry._type = inode.type === "tree" ? "tree" : mode2type(stats.mode);
          entry._mode = stats.mode;
          if (inode.type === "tree") {
            entry._stat = void 0;
          } else {
            entry._stat = stats;
          }
        }
        return entry._stat;
      }
      async content(_entry) {
      }
      async oid(entry) {
        if (entry._oid === false) {
          const tree = await this.treePromise;
          const inode = tree.get(entry._fullpath);
          entry._oid = inode.metadata.oid;
        }
        return entry._oid;
      }
    };
    __name(_GitWalkerIndex, "GitWalkerIndex");
    var GitWalkerIndex = _GitWalkerIndex;
    var GitWalkSymbol = Symbol("GitWalkSymbol");
    function STAGE() {
      const o = /* @__PURE__ */ Object.create(null);
      Object.defineProperty(o, GitWalkSymbol, {
        value: /* @__PURE__ */ __name(function({ fs, gitdir, cache }) {
          return new GitWalkerIndex({ fs, gitdir, cache });
        }, "value")
      });
      Object.freeze(o);
      return o;
    }
    __name(STAGE, "STAGE");
    var _NotFoundError = class _NotFoundError extends BaseError {
      /**
       * @param {string} what
       */
      constructor(what) {
        super(`Could not find ${what}.`);
        this.code = this.name = _NotFoundError.code;
        this.data = { what };
      }
    };
    __name(_NotFoundError, "NotFoundError");
    var NotFoundError = _NotFoundError;
    NotFoundError.code = "NotFoundError";
    var _ObjectTypeError = class _ObjectTypeError extends BaseError {
      /**
       * @param {string} oid
       * @param {'blob'|'commit'|'tag'|'tree'} actual
       * @param {'blob'|'commit'|'tag'|'tree'} expected
       * @param {string} [filepath]
       */
      constructor(oid, actual, expected, filepath) {
        super(
          `Object ${oid} ${filepath ? `at ${filepath}` : ""}was anticipated to be a ${expected} but it is a ${actual}.`
        );
        this.code = this.name = _ObjectTypeError.code;
        this.data = { oid, actual, expected, filepath };
      }
    };
    __name(_ObjectTypeError, "ObjectTypeError");
    var ObjectTypeError = _ObjectTypeError;
    ObjectTypeError.code = "ObjectTypeError";
    var _InvalidOidError = class _InvalidOidError extends BaseError {
      /**
       * @param {string} value
       */
      constructor(value) {
        super(`Expected a 40-char hex object id but saw "${value}".`);
        this.code = this.name = _InvalidOidError.code;
        this.data = { value };
      }
    };
    __name(_InvalidOidError, "InvalidOidError");
    var InvalidOidError = _InvalidOidError;
    InvalidOidError.code = "InvalidOidError";
    var _NoRefspecError = class _NoRefspecError extends BaseError {
      /**
       * @param {string} remote
       */
      constructor(remote) {
        super(`Could not find a fetch refspec for remote "${remote}". Make sure the config file has an entry like the following:
[remote "${remote}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`);
        this.code = this.name = _NoRefspecError.code;
        this.data = { remote };
      }
    };
    __name(_NoRefspecError, "NoRefspecError");
    var NoRefspecError = _NoRefspecError;
    NoRefspecError.code = "NoRefspecError";
    var _GitPackedRefs = class _GitPackedRefs {
      constructor(text) {
        this.refs = /* @__PURE__ */ new Map();
        this.parsedConfig = [];
        if (text) {
          let key = null;
          this.parsedConfig = text.trim().split("\n").map((line) => {
            if (/^\s*#/.test(line)) {
              return { line, comment: true };
            }
            const i = line.indexOf(" ");
            if (line.startsWith("^")) {
              const value = line.slice(1);
              this.refs.set(key + "^{}", value);
              return { line, ref: key, peeled: value };
            } else {
              const value = line.slice(0, i);
              key = line.slice(i + 1);
              this.refs.set(key, value);
              return { line, ref: key, oid: value };
            }
          });
        }
        return this;
      }
      static from(text) {
        return new _GitPackedRefs(text);
      }
      delete(ref) {
        this.parsedConfig = this.parsedConfig.filter((entry) => entry.ref !== ref);
        this.refs.delete(ref);
      }
      toString() {
        return this.parsedConfig.map(({ line }) => line).join("\n") + "\n";
      }
    };
    __name(_GitPackedRefs, "GitPackedRefs");
    var GitPackedRefs = _GitPackedRefs;
    var _GitRefSpec = class _GitRefSpec {
      constructor({ remotePath, localPath, force, matchPrefix }) {
        Object.assign(this, {
          remotePath,
          localPath,
          force,
          matchPrefix
        });
      }
      static from(refspec) {
        const [
          forceMatch,
          remotePath,
          remoteGlobMatch,
          localPath,
          localGlobMatch
        ] = refspec.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1);
        const force = forceMatch === "+";
        const remoteIsGlob = remoteGlobMatch === "*";
        const localIsGlob = localGlobMatch === "*";
        if (remoteIsGlob !== localIsGlob) {
          throw new InternalError("Invalid refspec");
        }
        return new _GitRefSpec({
          remotePath,
          localPath,
          force,
          matchPrefix: remoteIsGlob
        });
      }
      translate(remoteBranch) {
        if (this.matchPrefix) {
          if (remoteBranch.startsWith(this.remotePath)) {
            return this.localPath + remoteBranch.replace(this.remotePath, "");
          }
        } else {
          if (remoteBranch === this.remotePath) return this.localPath;
        }
        return null;
      }
      reverseTranslate(localBranch) {
        if (this.matchPrefix) {
          if (localBranch.startsWith(this.localPath)) {
            return this.remotePath + localBranch.replace(this.localPath, "");
          }
        } else {
          if (localBranch === this.localPath) return this.remotePath;
        }
        return null;
      }
    };
    __name(_GitRefSpec, "GitRefSpec");
    var GitRefSpec = _GitRefSpec;
    var _GitRefSpecSet = class _GitRefSpecSet {
      constructor(rules = []) {
        this.rules = rules;
      }
      static from(refspecs) {
        const rules = [];
        for (const refspec of refspecs) {
          rules.push(GitRefSpec.from(refspec));
        }
        return new _GitRefSpecSet(rules);
      }
      add(refspec) {
        const rule = GitRefSpec.from(refspec);
        this.rules.push(rule);
      }
      translate(remoteRefs) {
        const result = [];
        for (const rule of this.rules) {
          for (const remoteRef of remoteRefs) {
            const localRef = rule.translate(remoteRef);
            if (localRef) {
              result.push([remoteRef, localRef]);
            }
          }
        }
        return result;
      }
      translateOne(remoteRef) {
        let result = null;
        for (const rule of this.rules) {
          const localRef = rule.translate(remoteRef);
          if (localRef) {
            result = localRef;
          }
        }
        return result;
      }
      localNamespaces() {
        return this.rules.filter((rule) => rule.matchPrefix).map((rule) => rule.localPath.replace(/\/$/, ""));
      }
    };
    __name(_GitRefSpecSet, "GitRefSpecSet");
    var GitRefSpecSet = _GitRefSpecSet;
    function compareRefNames(a, b) {
      const _a = a.replace(/\^\{\}$/, "");
      const _b = b.replace(/\^\{\}$/, "");
      const tmp = -(_a < _b) || +(_a > _b);
      if (tmp === 0) {
        return a.endsWith("^{}") ? 1 : -1;
      }
      return tmp;
    }
    __name(compareRefNames, "compareRefNames");
    var num = /* @__PURE__ */ __name((val) => {
      if (typeof val === "number") {
        return val;
      }
      val = val.toLowerCase();
      let n = parseInt(val);
      if (val.endsWith("k")) n *= 1024;
      if (val.endsWith("m")) n *= 1024 * 1024;
      if (val.endsWith("g")) n *= 1024 * 1024 * 1024;
      return n;
    }, "num");
    var bool = /* @__PURE__ */ __name((val) => {
      if (typeof val === "boolean") {
        return val;
      }
      val = val.trim().toLowerCase();
      if (val === "true" || val === "yes" || val === "on") return true;
      if (val === "false" || val === "no" || val === "off") return false;
      throw Error(
        `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`
      );
    }, "bool");
    var schema = {
      core: {
        filemode: bool,
        bare: bool,
        logallrefupdates: bool,
        symlinks: bool,
        ignorecase: bool,
        bigFileThreshold: num
      }
    };
    var SECTION_LINE_REGEX = /^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/;
    var SECTION_REGEX = /^[A-Za-z0-9-.]+$/;
    var VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/;
    var VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]*$/;
    var VARIABLE_VALUE_COMMENT_REGEX = /^(.*?)( *[#;].*)$/;
    var extractSectionLine = /* @__PURE__ */ __name((line) => {
      const matches = SECTION_LINE_REGEX.exec(line);
      if (matches != null) {
        const [section, subsection] = matches.slice(1);
        return [section, subsection];
      }
      return null;
    }, "extractSectionLine");
    var extractVariableLine = /* @__PURE__ */ __name((line) => {
      const matches = VARIABLE_LINE_REGEX.exec(line);
      if (matches != null) {
        const [name, rawValue = "true"] = matches.slice(1);
        const valueWithoutComments = removeComments(rawValue);
        const valueWithoutQuotes = removeQuotes(valueWithoutComments);
        return [name, valueWithoutQuotes];
      }
      return null;
    }, "extractVariableLine");
    var removeComments = /* @__PURE__ */ __name((rawValue) => {
      const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);
      if (commentMatches == null) {
        return rawValue;
      }
      const [valueWithoutComment, comment] = commentMatches.slice(1);
      if (hasOddNumberOfQuotes(valueWithoutComment) && hasOddNumberOfQuotes(comment)) {
        return `${valueWithoutComment}${comment}`;
      }
      return valueWithoutComment;
    }, "removeComments");
    var hasOddNumberOfQuotes = /* @__PURE__ */ __name((text) => {
      const numberOfQuotes = (text.match(/(?:^|[^\\])"/g) || []).length;
      return numberOfQuotes % 2 !== 0;
    }, "hasOddNumberOfQuotes");
    var removeQuotes = /* @__PURE__ */ __name((text) => {
      return text.split("").reduce((newText, c, idx, text2) => {
        const isQuote = c === '"' && text2[idx - 1] !== "\\";
        const isEscapeForQuote = c === "\\" && text2[idx + 1] === '"';
        if (isQuote || isEscapeForQuote) {
          return newText;
        }
        return newText + c;
      }, "");
    }, "removeQuotes");
    var lower = /* @__PURE__ */ __name((text) => {
      return text != null ? text.toLowerCase() : null;
    }, "lower");
    var getPath = /* @__PURE__ */ __name((section, subsection, name) => {
      return [lower(section), subsection, lower(name)].filter((a) => a != null).join(".");
    }, "getPath");
    var normalizePath = /* @__PURE__ */ __name((path6) => {
      const pathSegments = path6.split(".");
      const section = pathSegments.shift();
      const name = pathSegments.pop();
      const subsection = pathSegments.length ? pathSegments.join(".") : void 0;
      return {
        section,
        subsection,
        name,
        path: getPath(section, subsection, name),
        sectionPath: getPath(section, subsection, null),
        isSection: !!section
      };
    }, "normalizePath");
    var findLastIndex = /* @__PURE__ */ __name((array, callback) => {
      return array.reduce((lastIndex, item, index3) => {
        return callback(item) ? index3 : lastIndex;
      }, -1);
    }, "findLastIndex");
    var _GitConfig = class _GitConfig {
      constructor(text) {
        let section = null;
        let subsection = null;
        this.parsedConfig = text ? text.split("\n").map((line) => {
          let name = null;
          let value = null;
          const trimmedLine = line.trim();
          const extractedSection = extractSectionLine(trimmedLine);
          const isSection = extractedSection != null;
          if (isSection) {
            ;
            [section, subsection] = extractedSection;
          } else {
            const extractedVariable = extractVariableLine(trimmedLine);
            const isVariable = extractedVariable != null;
            if (isVariable) {
              ;
              [name, value] = extractedVariable;
            }
          }
          const path6 = getPath(section, subsection, name);
          return { line, isSection, section, subsection, name, value, path: path6 };
        }) : [];
      }
      static from(text) {
        return new _GitConfig(text);
      }
      async get(path6, getall = false) {
        const normalizedPath = normalizePath(path6).path;
        const allValues = this.parsedConfig.filter((config) => config.path === normalizedPath).map(({ section, name, value }) => {
          const fn = schema[section] && schema[section][name];
          return fn ? fn(value) : value;
        });
        return getall ? allValues : allValues.pop();
      }
      async getall(path6) {
        return this.get(path6, true);
      }
      async getSubsections(section) {
        return this.parsedConfig.filter((config) => config.isSection && config.section === section).map((config) => config.subsection);
      }
      async deleteSection(section, subsection) {
        this.parsedConfig = this.parsedConfig.filter(
          (config) => !(config.section === section && config.subsection === subsection)
        );
      }
      async append(path6, value) {
        return this.set(path6, value, true);
      }
      async set(path6, value, append = false) {
        const {
          section,
          subsection,
          name,
          path: normalizedPath,
          sectionPath,
          isSection
        } = normalizePath(path6);
        const configIndex = findLastIndex(
          this.parsedConfig,
          (config) => config.path === normalizedPath
        );
        if (value == null) {
          if (configIndex !== -1) {
            this.parsedConfig.splice(configIndex, 1);
          }
        } else {
          if (configIndex !== -1) {
            const config = this.parsedConfig[configIndex];
            const modifiedConfig = Object.assign({}, config, {
              name,
              value,
              modified: true
            });
            if (append) {
              this.parsedConfig.splice(configIndex + 1, 0, modifiedConfig);
            } else {
              this.parsedConfig[configIndex] = modifiedConfig;
            }
          } else {
            const sectionIndex = this.parsedConfig.findIndex(
              (config) => config.path === sectionPath
            );
            const newConfig = {
              section,
              subsection,
              name,
              value,
              modified: true,
              path: normalizedPath
            };
            if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {
              if (sectionIndex >= 0) {
                this.parsedConfig.splice(sectionIndex + 1, 0, newConfig);
              } else {
                const newSection = {
                  isSection,
                  section,
                  subsection,
                  modified: true,
                  path: sectionPath
                };
                this.parsedConfig.push(newSection, newConfig);
              }
            }
          }
        }
      }
      toString() {
        return this.parsedConfig.map(({ line, section, subsection, name, value, modified: modified2 = false }) => {
          if (!modified2) {
            return line;
          }
          if (name != null && value != null) {
            if (typeof value === "string" && /[#;]/.test(value)) {
              return `	${name} = "${value}"`;
            }
            return `	${name} = ${value}`;
          }
          if (subsection != null) {
            return `[${section} "${subsection}"]`;
          }
          return `[${section}]`;
        }).join("\n");
      }
    };
    __name(_GitConfig, "GitConfig");
    var GitConfig = _GitConfig;
    var _GitConfigManager = class _GitConfigManager {
      /**
       * Reads the Git configuration file from the specified `.git` directory.
       *
       * @param {object} opts - Options for reading the Git configuration.
       * @param {FSClient} opts.fs - A file system implementation.
       * @param {string} opts.gitdir - The path to the `.git` directory.
       * @returns {Promise<GitConfig>} A `GitConfig` object representing the parsed configuration.
       */
      static async get({ fs, gitdir }) {
        const text = await fs.read(`${gitdir}/config`, { encoding: "utf8" });
        return GitConfig.from(text);
      }
      /**
       * Saves the provided Git configuration to the specified `.git` directory.
       *
       * @param {object} opts - Options for saving the Git configuration.
       * @param {FSClient} opts.fs - A file system implementation.
       * @param {string} opts.gitdir - The path to the `.git` directory.
       * @param {GitConfig} opts.config - The `GitConfig` object to save.
       * @returns {Promise<void>} Resolves when the configuration has been successfully saved.
       */
      static async save({ fs, gitdir, config }) {
        await fs.write(`${gitdir}/config`, config.toString(), {
          encoding: "utf8"
        });
      }
    };
    __name(_GitConfigManager, "GitConfigManager");
    var GitConfigManager = _GitConfigManager;
    var refpaths = /* @__PURE__ */ __name((ref) => [
      `${ref}`,
      `refs/${ref}`,
      `refs/tags/${ref}`,
      `refs/heads/${ref}`,
      `refs/remotes/${ref}`,
      `refs/remotes/${ref}/HEAD`
    ], "refpaths");
    var GIT_FILES = ["config", "description", "index", "shallow", "commondir"];
    var lock$1;
    async function acquireLock(ref, callback) {
      if (lock$1 === void 0) lock$1 = new AsyncLock();
      return lock$1.acquire(ref, callback);
    }
    __name(acquireLock, "acquireLock");
    var _GitRefManager = class _GitRefManager {
      /**
       * Updates remote refs based on the provided refspecs and options.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string} args.remote - The name of the remote.
       * @param {Map<string, string>} args.refs - A map of refs to their object IDs.
       * @param {Map<string, string>} args.symrefs - A map of symbolic refs.
       * @param {boolean} args.tags - Whether to fetch tags.
       * @param {string[]} [args.refspecs = undefined] - The refspecs to use.
       * @param {boolean} [args.prune = false] - Whether to prune stale refs.
       * @param {boolean} [args.pruneTags = false] - Whether to prune tags.
       * @returns {Promise<Object>} - An object containing pruned refs.
       */
      static async updateRemoteRefs({
        fs,
        gitdir,
        remote,
        refs,
        symrefs,
        tags,
        refspecs = void 0,
        prune = false,
        pruneTags = false
      }) {
        for (const value of refs.values()) {
          if (!value.match(/[0-9a-f]{40}/)) {
            throw new InvalidOidError(value);
          }
        }
        const config = await GitConfigManager.get({ fs, gitdir });
        if (!refspecs) {
          refspecs = await config.getall(`remote.${remote}.fetch`);
          if (refspecs.length === 0) {
            throw new NoRefspecError(remote);
          }
          refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);
        }
        const refspec = GitRefSpecSet.from(refspecs);
        const actualRefsToWrite = /* @__PURE__ */ new Map();
        if (pruneTags) {
          const tags2 = await _GitRefManager.listRefs({
            fs,
            gitdir,
            filepath: "refs/tags"
          });
          await _GitRefManager.deleteRefs({
            fs,
            gitdir,
            refs: tags2.map((tag2) => `refs/tags/${tag2}`)
          });
        }
        if (tags) {
          for (const serverRef of refs.keys()) {
            if (serverRef.startsWith("refs/tags") && !serverRef.endsWith("^{}")) {
              if (!await _GitRefManager.exists({ fs, gitdir, ref: serverRef })) {
                const oid = refs.get(serverRef);
                actualRefsToWrite.set(serverRef, oid);
              }
            }
          }
        }
        const refTranslations = refspec.translate([...refs.keys()]);
        for (const [serverRef, translatedRef] of refTranslations) {
          const value = refs.get(serverRef);
          actualRefsToWrite.set(translatedRef, value);
        }
        const symrefTranslations = refspec.translate([...symrefs.keys()]);
        for (const [serverRef, translatedRef] of symrefTranslations) {
          const value = symrefs.get(serverRef);
          const symtarget = refspec.translateOne(value);
          if (symtarget) {
            actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);
          }
        }
        const pruned = [];
        if (prune) {
          for (const filepath of refspec.localNamespaces()) {
            const refs2 = (await _GitRefManager.listRefs({
              fs,
              gitdir,
              filepath
            })).map((file) => `${filepath}/${file}`);
            for (const ref of refs2) {
              if (!actualRefsToWrite.has(ref)) {
                pruned.push(ref);
              }
            }
          }
          if (pruned.length > 0) {
            await _GitRefManager.deleteRefs({ fs, gitdir, refs: pruned });
          }
        }
        for (const [key, value] of actualRefsToWrite) {
          await acquireLock(
            key,
            async () => fs.write(pathBrowserify.join(gitdir, key), `${value.trim()}
`, "utf8")
          );
        }
        return { pruned };
      }
      /**
       * Writes a ref to the file system.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string} args.ref - The ref to write.
       * @param {string} args.value - The object ID to write.
       * @returns {Promise<void>}
       */
      // TODO: make this less crude?
      static async writeRef({ fs, gitdir, ref, value }) {
        if (!value.match(/[0-9a-f]{40}/)) {
          throw new InvalidOidError(value);
        }
        await acquireLock(
          ref,
          async () => fs.write(pathBrowserify.join(gitdir, ref), `${value.trim()}
`, "utf8")
        );
      }
      /**
       * Writes a symbolic ref to the file system.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string} args.ref - The ref to write.
       * @param {string} args.value - The target ref.
       * @returns {Promise<void>}
       */
      static async writeSymbolicRef({ fs, gitdir, ref, value }) {
        await acquireLock(
          ref,
          async () => fs.write(pathBrowserify.join(gitdir, ref), `ref: ${value.trim()}
`, "utf8")
        );
      }
      /**
       * Deletes a single ref.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string} args.ref - The ref to delete.
       * @returns {Promise<void>}
       */
      static async deleteRef({ fs, gitdir, ref }) {
        return _GitRefManager.deleteRefs({ fs, gitdir, refs: [ref] });
      }
      /**
       * Deletes multiple refs.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string[]} args.refs - The refs to delete.
       * @returns {Promise<void>}
       */
      static async deleteRefs({ fs, gitdir, refs }) {
        await Promise.all(refs.map((ref) => fs.rm(pathBrowserify.join(gitdir, ref))));
        let text = await acquireLock(
          "packed-refs",
          async () => fs.read(`${gitdir}/packed-refs`, { encoding: "utf8" })
        );
        const packed = GitPackedRefs.from(text);
        const beforeSize = packed.refs.size;
        for (const ref of refs) {
          if (packed.refs.has(ref)) {
            packed.delete(ref);
          }
        }
        if (packed.refs.size < beforeSize) {
          text = packed.toString();
          await acquireLock(
            "packed-refs",
            async () => fs.write(`${gitdir}/packed-refs`, text, { encoding: "utf8" })
          );
        }
      }
      /**
       * Resolves a ref to its object ID.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string} args.ref - The ref to resolve.
       * @param {number} [args.depth = undefined] - The maximum depth to resolve symbolic refs.
       * @returns {Promise<string>} - The resolved object ID.
       */
      static async resolve({ fs, gitdir, ref, depth = void 0 }) {
        if (depth !== void 0) {
          depth--;
          if (depth === -1) {
            return ref;
          }
        }
        if (ref.startsWith("ref: ")) {
          ref = ref.slice("ref: ".length);
          return _GitRefManager.resolve({ fs, gitdir, ref, depth });
        }
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return ref;
        }
        const packedMap = await _GitRefManager.packedRefs({ fs, gitdir });
        const allpaths = refpaths(ref).filter((p) => !GIT_FILES.includes(p));
        for (const ref2 of allpaths) {
          const sha = await acquireLock(
            ref2,
            async () => await fs.read(`${gitdir}/${ref2}`, { encoding: "utf8" }) || packedMap.get(ref2)
          );
          if (sha) {
            return _GitRefManager.resolve({ fs, gitdir, ref: sha.trim(), depth });
          }
        }
        throw new NotFoundError(ref);
      }
      /**
       * Checks if a ref exists.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string} args.ref - The ref to check.
       * @returns {Promise<boolean>} - True if the ref exists, false otherwise.
       */
      static async exists({ fs, gitdir, ref }) {
        try {
          await _GitRefManager.expand({ fs, gitdir, ref });
          return true;
        } catch (err) {
          return false;
        }
      }
      /**
       * Expands a ref to its full name.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string} args.ref - The ref to expand.
       * @returns {Promise<string>} - The full ref name.
       */
      static async expand({ fs, gitdir, ref }) {
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return ref;
        }
        const packedMap = await _GitRefManager.packedRefs({ fs, gitdir });
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          const refExists = await acquireLock(
            ref2,
            async () => fs.exists(`${gitdir}/${ref2}`)
          );
          if (refExists) return ref2;
          if (packedMap.has(ref2)) return ref2;
        }
        throw new NotFoundError(ref);
      }
      /**
       * Expands a ref against a provided map.
       *
       * @param {Object} args
       * @param {string} args.ref - The ref to expand.
       * @param {Map<string, string>} args.map - The map of refs.
       * @returns {Promise<string>} - The expanded ref.
       */
      static async expandAgainstMap({ ref, map }) {
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          if (await map.has(ref2)) return ref2;
        }
        throw new NotFoundError(ref);
      }
      /**
       * Resolves a ref against a provided map.
       *
       * @param {Object} args
       * @param {string} args.ref - The ref to resolve.
       * @param {string} [args.fullref = args.ref] - The full ref name.
       * @param {number} [args.depth = undefined] - The maximum depth to resolve symbolic refs.
       * @param {Map<string, string>} args.map - The map of refs.
       * @returns {Object} - An object containing the full ref and its object ID.
       */
      static resolveAgainstMap({ ref, fullref = ref, depth = void 0, map }) {
        if (depth !== void 0) {
          depth--;
          if (depth === -1) {
            return { fullref, oid: ref };
          }
        }
        if (ref.startsWith("ref: ")) {
          ref = ref.slice("ref: ".length);
          return _GitRefManager.resolveAgainstMap({ ref, fullref, depth, map });
        }
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return { fullref, oid: ref };
        }
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          const sha = map.get(ref2);
          if (sha) {
            return _GitRefManager.resolveAgainstMap({
              ref: sha.trim(),
              fullref: ref2,
              depth,
              map
            });
          }
        }
        throw new NotFoundError(ref);
      }
      /**
       * Reads the packed refs file and returns a map of refs.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
       * @returns {Promise<Map<string, string>>} - A map of packed refs.
       */
      static async packedRefs({ fs, gitdir }) {
        const text = await acquireLock(
          "packed-refs",
          async () => fs.read(`${gitdir}/packed-refs`, { encoding: "utf8" })
        );
        const packed = GitPackedRefs.from(text);
        return packed.refs;
      }
      /**
       * Lists all refs matching a given filepath prefix.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string} args.filepath - The filepath prefix to match.
       * @returns {Promise<string[]>} - A sorted list of refs.
       */
      static async listRefs({ fs, gitdir, filepath }) {
        const packedMap = _GitRefManager.packedRefs({ fs, gitdir });
        let files = null;
        try {
          files = await fs.readdirDeep(`${gitdir}/${filepath}`);
          files = files.map((x) => x.replace(`${gitdir}/${filepath}/`, ""));
        } catch (err) {
          files = [];
        }
        for (let key of (await packedMap).keys()) {
          if (key.startsWith(filepath)) {
            key = key.replace(filepath + "/", "");
            if (!files.includes(key)) {
              files.push(key);
            }
          }
        }
        files.sort(compareRefNames);
        return files;
      }
      /**
       * Lists all branches, optionally filtered by remote.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string} [args.remote] - The remote to filter branches by.
       * @returns {Promise<string[]>} - A list of branch names.
       */
      static async listBranches({ fs, gitdir, remote }) {
        if (remote) {
          return _GitRefManager.listRefs({
            fs,
            gitdir,
            filepath: `refs/remotes/${remote}`
          });
        } else {
          return _GitRefManager.listRefs({ fs, gitdir, filepath: `refs/heads` });
        }
      }
      /**
       * Lists all tags.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
       * @returns {Promise<string[]>} - A list of tag names.
       */
      static async listTags({ fs, gitdir }) {
        const tags = await _GitRefManager.listRefs({
          fs,
          gitdir,
          filepath: `refs/tags`
        });
        return tags.filter((x) => !x.endsWith("^{}"));
      }
    };
    __name(_GitRefManager, "GitRefManager");
    var GitRefManager = _GitRefManager;
    function compareTreeEntryPath(a, b) {
      return compareStrings(appendSlashIfDir(a), appendSlashIfDir(b));
    }
    __name(compareTreeEntryPath, "compareTreeEntryPath");
    function appendSlashIfDir(entry) {
      return entry.mode === "040000" ? entry.path + "/" : entry.path;
    }
    __name(appendSlashIfDir, "appendSlashIfDir");
    function mode2type$1(mode) {
      switch (mode) {
        case "040000":
          return "tree";
        case "100644":
          return "blob";
        case "100755":
          return "blob";
        case "120000":
          return "blob";
        case "160000":
          return "commit";
      }
      throw new InternalError(`Unexpected GitTree entry mode: ${mode}`);
    }
    __name(mode2type$1, "mode2type$1");
    function parseBuffer(buffer) {
      const _entries = [];
      let cursor = 0;
      while (cursor < buffer.length) {
        const space = buffer.indexOf(32, cursor);
        if (space === -1) {
          throw new InternalError(
            `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`
          );
        }
        const nullchar = buffer.indexOf(0, cursor);
        if (nullchar === -1) {
          throw new InternalError(
            `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`
          );
        }
        let mode = buffer.slice(cursor, space).toString("utf8");
        if (mode === "40000") mode = "040000";
        const type = mode2type$1(mode);
        const path6 = buffer.slice(space + 1, nullchar).toString("utf8");
        if (path6.includes("\\") || path6.includes("/")) {
          throw new UnsafeFilepathError(path6);
        }
        const oid = buffer.slice(nullchar + 1, nullchar + 21).toString("hex");
        cursor = nullchar + 21;
        _entries.push({ mode, path: path6, oid, type });
      }
      return _entries;
    }
    __name(parseBuffer, "parseBuffer");
    function limitModeToAllowed(mode) {
      if (typeof mode === "number") {
        mode = mode.toString(8);
      }
      if (mode.match(/^0?4.*/)) return "040000";
      if (mode.match(/^1006.*/)) return "100644";
      if (mode.match(/^1007.*/)) return "100755";
      if (mode.match(/^120.*/)) return "120000";
      if (mode.match(/^160.*/)) return "160000";
      throw new InternalError(`Could not understand file mode: ${mode}`);
    }
    __name(limitModeToAllowed, "limitModeToAllowed");
    function nudgeIntoShape(entry) {
      if (!entry.oid && entry.sha) {
        entry.oid = entry.sha;
      }
      entry.mode = limitModeToAllowed(entry.mode);
      if (!entry.type) {
        entry.type = mode2type$1(entry.mode);
      }
      return entry;
    }
    __name(nudgeIntoShape, "nudgeIntoShape");
    var _GitTree = class _GitTree {
      constructor(entries) {
        if (Buffer.isBuffer(entries)) {
          this._entries = parseBuffer(entries);
        } else if (Array.isArray(entries)) {
          this._entries = entries.map(nudgeIntoShape);
        } else {
          throw new InternalError("invalid type passed to GitTree constructor");
        }
        this._entries.sort(comparePath);
      }
      static from(tree) {
        return new _GitTree(tree);
      }
      render() {
        return this._entries.map((entry) => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`).join("\n");
      }
      toObject() {
        const entries = [...this._entries];
        entries.sort(compareTreeEntryPath);
        return Buffer.concat(
          entries.map((entry) => {
            const mode = Buffer.from(entry.mode.replace(/^0/, ""));
            const space = Buffer.from(" ");
            const path6 = Buffer.from(entry.path, "utf8");
            const nullchar = Buffer.from([0]);
            const oid = Buffer.from(entry.oid, "hex");
            return Buffer.concat([mode, space, path6, nullchar, oid]);
          })
        );
      }
      /**
       * @returns {TreeEntry[]}
       */
      entries() {
        return this._entries;
      }
      *[Symbol.iterator]() {
        for (const entry of this._entries) {
          yield entry;
        }
      }
    };
    __name(_GitTree, "GitTree");
    var GitTree = _GitTree;
    var _GitObject = class _GitObject {
      /**
       * Wraps a raw object with a Git header.
       *
       * @param {Object} params - The parameters for wrapping.
       * @param {string} params.type - The type of the Git object (e.g., 'blob', 'tree', 'commit').
       * @param {Uint8Array} params.object - The raw object data to wrap.
       * @returns {Uint8Array} The wrapped Git object as a single buffer.
       */
      static wrap({ type, object }) {
        const header = `${type} ${object.length}\0`;
        const headerLen = header.length;
        const totalLength = headerLen + object.length;
        const wrappedObject = new Uint8Array(totalLength);
        for (let i = 0; i < headerLen; i++) {
          wrappedObject[i] = header.charCodeAt(i);
        }
        wrappedObject.set(object, headerLen);
        return wrappedObject;
      }
      /**
       * Unwraps a Git object buffer into its type and raw object data.
       *
       * @param {Buffer|Uint8Array} buffer - The buffer containing the wrapped Git object.
       * @returns {{ type: string, object: Buffer }} An object containing the type and the raw object data.
       * @throws {InternalError} If the length specified in the header does not match the actual object length.
       */
      static unwrap(buffer) {
        const s = buffer.indexOf(32);
        const i = buffer.indexOf(0);
        const type = buffer.slice(0, s).toString("utf8");
        const length = buffer.slice(s + 1, i).toString("utf8");
        const actualLength = buffer.length - (i + 1);
        if (parseInt(length) !== actualLength) {
          throw new InternalError(
            `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`
          );
        }
        return {
          type,
          object: Buffer.from(buffer.slice(i + 1))
        };
      }
    };
    __name(_GitObject, "GitObject");
    var GitObject = _GitObject;
    async function readObjectLoose({ fs, gitdir, oid }) {
      const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
      const file = await fs.read(`${gitdir}/${source}`);
      if (!file) {
        return null;
      }
      return { object: file, format: "deflated", source };
    }
    __name(readObjectLoose, "readObjectLoose");
    function applyDelta(delta, source) {
      const reader = new BufferCursor(delta);
      const sourceSize = readVarIntLE(reader);
      if (sourceSize !== source.byteLength) {
        throw new InternalError(
          `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`
        );
      }
      const targetSize = readVarIntLE(reader);
      let target;
      const firstOp = readOp(reader, source);
      if (firstOp.byteLength === targetSize) {
        target = firstOp;
      } else {
        target = Buffer.alloc(targetSize);
        const writer = new BufferCursor(target);
        writer.copy(firstOp);
        while (!reader.eof()) {
          writer.copy(readOp(reader, source));
        }
        const tell = writer.tell();
        if (targetSize !== tell) {
          throw new InternalError(
            `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`
          );
        }
      }
      return target;
    }
    __name(applyDelta, "applyDelta");
    function readVarIntLE(reader) {
      let result = 0;
      let shift = 0;
      let byte = null;
      do {
        byte = reader.readUInt8();
        result |= (byte & 127) << shift;
        shift += 7;
      } while (byte & 128);
      return result;
    }
    __name(readVarIntLE, "readVarIntLE");
    function readCompactLE(reader, flags, size) {
      let result = 0;
      let shift = 0;
      while (size--) {
        if (flags & 1) {
          result |= reader.readUInt8() << shift;
        }
        flags >>= 1;
        shift += 8;
      }
      return result;
    }
    __name(readCompactLE, "readCompactLE");
    function readOp(reader, source) {
      const byte = reader.readUInt8();
      const COPY = 128;
      const OFFS = 15;
      const SIZE = 112;
      if (byte & COPY) {
        const offset = readCompactLE(reader, byte & OFFS, 4);
        let size = readCompactLE(reader, (byte & SIZE) >> 4, 3);
        if (size === 0) size = 65536;
        return source.slice(offset, offset + size);
      } else {
        return reader.slice(byte);
      }
    }
    __name(readOp, "readOp");
    function fromValue2(value) {
      let queue = [value];
      return {
        next() {
          return Promise.resolve({ done: queue.length === 0, value: queue.pop() });
        },
        return() {
          queue = [];
          return {};
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(fromValue2, "fromValue");
    function getIterator2(iterable) {
      if (iterable[Symbol.asyncIterator]) {
        return iterable[Symbol.asyncIterator]();
      }
      if (iterable[Symbol.iterator]) {
        return iterable[Symbol.iterator]();
      }
      if (iterable.next) {
        return iterable;
      }
      return fromValue2(iterable);
    }
    __name(getIterator2, "getIterator");
    var _StreamReader = class _StreamReader {
      constructor(stream) {
        if (typeof Buffer === "undefined") {
          throw new Error("Missing Buffer dependency");
        }
        this.stream = getIterator2(stream);
        this.buffer = null;
        this.cursor = 0;
        this.undoCursor = 0;
        this.started = false;
        this._ended = false;
        this._discardedBytes = 0;
      }
      eof() {
        return this._ended && this.cursor === this.buffer.length;
      }
      tell() {
        return this._discardedBytes + this.cursor;
      }
      async byte() {
        if (this.eof()) return;
        if (!this.started) await this._init();
        if (this.cursor === this.buffer.length) {
          await this._loadnext();
          if (this._ended) return;
        }
        this._moveCursor(1);
        return this.buffer[this.undoCursor];
      }
      async chunk() {
        if (this.eof()) return;
        if (!this.started) await this._init();
        if (this.cursor === this.buffer.length) {
          await this._loadnext();
          if (this._ended) return;
        }
        this._moveCursor(this.buffer.length);
        return this.buffer.slice(this.undoCursor, this.cursor);
      }
      async read(n) {
        if (this.eof()) return;
        if (!this.started) await this._init();
        if (this.cursor + n > this.buffer.length) {
          this._trim();
          await this._accumulate(n);
        }
        this._moveCursor(n);
        return this.buffer.slice(this.undoCursor, this.cursor);
      }
      async skip(n) {
        if (this.eof()) return;
        if (!this.started) await this._init();
        if (this.cursor + n > this.buffer.length) {
          this._trim();
          await this._accumulate(n);
        }
        this._moveCursor(n);
      }
      async undo() {
        this.cursor = this.undoCursor;
      }
      async _next() {
        this.started = true;
        let { done, value } = await this.stream.next();
        if (done) {
          this._ended = true;
          if (!value) return Buffer.alloc(0);
        }
        if (value) {
          value = Buffer.from(value);
        }
        return value;
      }
      _trim() {
        this.buffer = this.buffer.slice(this.undoCursor);
        this.cursor -= this.undoCursor;
        this._discardedBytes += this.undoCursor;
        this.undoCursor = 0;
      }
      _moveCursor(n) {
        this.undoCursor = this.cursor;
        this.cursor += n;
        if (this.cursor > this.buffer.length) {
          this.cursor = this.buffer.length;
        }
      }
      async _accumulate(n) {
        if (this._ended) return;
        const buffers = [this.buffer];
        while (this.cursor + n > lengthBuffers(buffers)) {
          const nextbuffer = await this._next();
          if (this._ended) break;
          buffers.push(nextbuffer);
        }
        this.buffer = Buffer.concat(buffers);
      }
      async _loadnext() {
        this._discardedBytes += this.buffer.length;
        this.undoCursor = 0;
        this.cursor = 0;
        this.buffer = await this._next();
      }
      async _init() {
        this.buffer = await this._next();
      }
    };
    __name(_StreamReader, "StreamReader");
    var StreamReader = _StreamReader;
    function lengthBuffers(buffers) {
      return buffers.reduce((acc, buffer) => acc + buffer.length, 0);
    }
    __name(lengthBuffers, "lengthBuffers");
    async function listpack(stream, onData) {
      const reader = new StreamReader(stream);
      let PACK = await reader.read(4);
      PACK = PACK.toString("utf8");
      if (PACK !== "PACK") {
        throw new InternalError(`Invalid PACK header '${PACK}'`);
      }
      let version2 = await reader.read(4);
      version2 = version2.readUInt32BE(0);
      if (version2 !== 2) {
        throw new InternalError(`Invalid packfile version: ${version2}`);
      }
      let numObjects = await reader.read(4);
      numObjects = numObjects.readUInt32BE(0);
      if (numObjects < 1) return;
      while (!reader.eof() && numObjects--) {
        const offset = reader.tell();
        const { type, length, ofs, reference } = await parseHeader(reader);
        const inflator = new pako.Inflate();
        while (!inflator.result) {
          const chunk = await reader.chunk();
          if (!chunk) break;
          inflator.push(chunk, false);
          if (inflator.err) {
            throw new InternalError(`Pako error: ${inflator.msg}`);
          }
          if (inflator.result) {
            if (inflator.result.length !== length) {
              throw new InternalError(
                `Inflated object size is different from that stated in packfile.`
              );
            }
            await reader.undo();
            await reader.read(chunk.length - inflator.strm.avail_in);
            const end = reader.tell();
            await onData({
              data: inflator.result,
              type,
              num: numObjects,
              offset,
              end,
              reference,
              ofs
            });
          }
        }
      }
    }
    __name(listpack, "listpack");
    async function parseHeader(reader) {
      let byte = await reader.byte();
      const type = byte >> 4 & 7;
      let length = byte & 15;
      if (byte & 128) {
        let shift = 4;
        do {
          byte = await reader.byte();
          length |= (byte & 127) << shift;
          shift += 7;
        } while (byte & 128);
      }
      let ofs;
      let reference;
      if (type === 6) {
        let shift = 0;
        ofs = 0;
        const bytes = [];
        do {
          byte = await reader.byte();
          ofs |= (byte & 127) << shift;
          shift += 7;
          bytes.push(byte);
        } while (byte & 128);
        reference = Buffer.from(bytes);
      }
      if (type === 7) {
        const buf = await reader.read(20);
        reference = buf;
      }
      return { type, length, ofs, reference };
    }
    __name(parseHeader, "parseHeader");
    var supportsDecompressionStream = false;
    async function inflate(buffer) {
      if (supportsDecompressionStream === null) {
        supportsDecompressionStream = testDecompressionStream();
      }
      return supportsDecompressionStream ? browserInflate(buffer) : pako.inflate(buffer);
    }
    __name(inflate, "inflate");
    async function browserInflate(buffer) {
      const ds = new DecompressionStream("deflate");
      const d = new Blob([buffer]).stream().pipeThrough(ds);
      return new Uint8Array(await new Response(d).arrayBuffer());
    }
    __name(browserInflate, "browserInflate");
    function testDecompressionStream() {
      try {
        const ds = new DecompressionStream("deflate");
        if (ds) return true;
      } catch (_) {
      }
      return false;
    }
    __name(testDecompressionStream, "testDecompressionStream");
    function decodeVarInt(reader) {
      const bytes = [];
      let byte = 0;
      let multibyte = 0;
      do {
        byte = reader.readUInt8();
        const lastSeven = byte & 127;
        bytes.push(lastSeven);
        multibyte = byte & 128;
      } while (multibyte);
      return bytes.reduce((a, b) => a + 1 << 7 | b, -1);
    }
    __name(decodeVarInt, "decodeVarInt");
    function otherVarIntDecode(reader, startWith) {
      let result = startWith;
      let shift = 4;
      let byte = null;
      do {
        byte = reader.readUInt8();
        result |= (byte & 127) << shift;
        shift += 7;
      } while (byte & 128);
      return result;
    }
    __name(otherVarIntDecode, "otherVarIntDecode");
    var _GitPackIndex = class _GitPackIndex {
      constructor(stuff) {
        Object.assign(this, stuff);
        this.offsetCache = {};
      }
      static async fromIdx({ idx, getExternalRefDelta }) {
        const reader = new BufferCursor(idx);
        const magic = reader.slice(4).toString("hex");
        if (magic !== "ff744f63") {
          return;
        }
        const version2 = reader.readUInt32BE();
        if (version2 !== 2) {
          throw new InternalError(
            `Unable to read version ${version2} packfile IDX. (Only version 2 supported)`
          );
        }
        if (idx.byteLength > 2048 * 1024 * 1024) {
          throw new InternalError(
            `To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`
          );
        }
        reader.seek(reader.tell() + 4 * 255);
        const size = reader.readUInt32BE();
        const hashes = [];
        for (let i = 0; i < size; i++) {
          const hash = reader.slice(20).toString("hex");
          hashes[i] = hash;
        }
        reader.seek(reader.tell() + 4 * size);
        const offsets = /* @__PURE__ */ new Map();
        for (let i = 0; i < size; i++) {
          offsets.set(hashes[i], reader.readUInt32BE());
        }
        const packfileSha = reader.slice(20).toString("hex");
        return new _GitPackIndex({
          hashes,
          crcs: {},
          offsets,
          packfileSha,
          getExternalRefDelta
        });
      }
      static async fromPack({ pack, getExternalRefDelta, onProgress }) {
        const listpackTypes = {
          1: "commit",
          2: "tree",
          3: "blob",
          4: "tag",
          6: "ofs-delta",
          7: "ref-delta"
        };
        const offsetToObject = {};
        const packfileSha = pack.slice(-20).toString("hex");
        const hashes = [];
        const crcs = {};
        const offsets = /* @__PURE__ */ new Map();
        let totalObjectCount = null;
        let lastPercent = null;
        await listpack([pack], async ({ data, type, reference, offset, num: num2 }) => {
          if (totalObjectCount === null) totalObjectCount = num2;
          const percent = Math.floor(
            (totalObjectCount - num2) * 100 / totalObjectCount
          );
          if (percent !== lastPercent) {
            if (onProgress) {
              await onProgress({
                phase: "Receiving objects",
                loaded: totalObjectCount - num2,
                total: totalObjectCount
              });
            }
          }
          lastPercent = percent;
          type = listpackTypes[type];
          if (["commit", "tree", "blob", "tag"].includes(type)) {
            offsetToObject[offset] = {
              type,
              offset
            };
          } else if (type === "ofs-delta") {
            offsetToObject[offset] = {
              type,
              offset
            };
          } else if (type === "ref-delta") {
            offsetToObject[offset] = {
              type,
              offset
            };
          }
        });
        const offsetArray = Object.keys(offsetToObject).map(Number);
        for (const [i, start] of offsetArray.entries()) {
          const end = i + 1 === offsetArray.length ? pack.byteLength - 20 : offsetArray[i + 1];
          const o = offsetToObject[start];
          const crc = crc32.buf(pack.slice(start, end)) >>> 0;
          o.end = end;
          o.crc = crc;
        }
        const p = new _GitPackIndex({
          pack: Promise.resolve(pack),
          packfileSha,
          crcs,
          hashes,
          offsets,
          getExternalRefDelta
        });
        lastPercent = null;
        let count = 0;
        const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (let offset in offsetToObject) {
          offset = Number(offset);
          const percent = Math.floor(count * 100 / totalObjectCount);
          if (percent !== lastPercent) {
            if (onProgress) {
              await onProgress({
                phase: "Resolving deltas",
                loaded: count,
                total: totalObjectCount
              });
            }
          }
          count++;
          lastPercent = percent;
          const o = offsetToObject[offset];
          if (o.oid) continue;
          try {
            p.readDepth = 0;
            p.externalReadDepth = 0;
            const { type, object } = await p.readSlice({ start: offset });
            objectsByDepth[p.readDepth] += 1;
            const oid = await shasum(GitObject.wrap({ type, object }));
            o.oid = oid;
            hashes.push(oid);
            offsets.set(oid, offset);
            crcs[oid] = o.crc;
          } catch (err) {
            continue;
          }
        }
        hashes.sort();
        return p;
      }
      async toBuffer() {
        const buffers = [];
        const write = /* @__PURE__ */ __name((str, encoding) => {
          buffers.push(Buffer.from(str, encoding));
        }, "write");
        write("ff744f63", "hex");
        write("00000002", "hex");
        const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4));
        for (let i = 0; i < 256; i++) {
          let count = 0;
          for (const hash of this.hashes) {
            if (parseInt(hash.slice(0, 2), 16) <= i) count++;
          }
          fanoutBuffer.writeUInt32BE(count);
        }
        buffers.push(fanoutBuffer.buffer);
        for (const hash of this.hashes) {
          write(hash, "hex");
        }
        const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
        for (const hash of this.hashes) {
          crcsBuffer.writeUInt32BE(this.crcs[hash]);
        }
        buffers.push(crcsBuffer.buffer);
        const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
        for (const hash of this.hashes) {
          offsetsBuffer.writeUInt32BE(this.offsets.get(hash));
        }
        buffers.push(offsetsBuffer.buffer);
        write(this.packfileSha, "hex");
        const totalBuffer = Buffer.concat(buffers);
        const sha = await shasum(totalBuffer);
        const shaBuffer = Buffer.alloc(20);
        shaBuffer.write(sha, "hex");
        return Buffer.concat([totalBuffer, shaBuffer]);
      }
      async load({ pack }) {
        this.pack = pack;
      }
      async unload() {
        this.pack = null;
      }
      async read({ oid }) {
        if (!this.offsets.get(oid)) {
          if (this.getExternalRefDelta) {
            this.externalReadDepth++;
            return this.getExternalRefDelta(oid);
          } else {
            throw new InternalError(`Could not read object ${oid} from packfile`);
          }
        }
        const start = this.offsets.get(oid);
        return this.readSlice({ start });
      }
      async readSlice({ start }) {
        if (this.offsetCache[start]) {
          return Object.assign({}, this.offsetCache[start]);
        }
        this.readDepth++;
        const types2 = {
          16: "commit",
          32: "tree",
          48: "blob",
          64: "tag",
          96: "ofs_delta",
          112: "ref_delta"
        };
        if (!this.pack) {
          throw new InternalError(
            "Tried to read from a GitPackIndex with no packfile loaded into memory"
          );
        }
        const raw = (await this.pack).slice(start);
        const reader = new BufferCursor(raw);
        const byte = reader.readUInt8();
        const btype = byte & 112;
        let type = types2[btype];
        if (type === void 0) {
          throw new InternalError("Unrecognized type: 0b" + btype.toString(2));
        }
        const lastFour = byte & 15;
        let length = lastFour;
        const multibyte = byte & 128;
        if (multibyte) {
          length = otherVarIntDecode(reader, lastFour);
        }
        let base = null;
        let object = null;
        if (type === "ofs_delta") {
          const offset = decodeVarInt(reader);
          const baseOffset = start - offset;
          ({ object: base, type } = await this.readSlice({ start: baseOffset }));
        }
        if (type === "ref_delta") {
          const oid = reader.slice(20).toString("hex");
          ({ object: base, type } = await this.read({ oid }));
        }
        const buffer = raw.slice(reader.tell());
        object = Buffer.from(await inflate(buffer));
        if (object.byteLength !== length) {
          throw new InternalError(
            `Packfile told us object would have length ${length} but it had length ${object.byteLength}`
          );
        }
        if (base) {
          object = Buffer.from(applyDelta(object, base));
        }
        if (this.readDepth > 3) {
          this.offsetCache[start] = { type, object };
        }
        return { type, format: "content", object };
      }
    };
    __name(_GitPackIndex, "GitPackIndex");
    var GitPackIndex = _GitPackIndex;
    var PackfileCache = Symbol("PackfileCache");
    async function loadPackIndex({
      fs,
      filename,
      getExternalRefDelta,
      emitter,
      emitterPrefix
    }) {
      const idx = await fs.read(filename);
      return GitPackIndex.fromIdx({ idx, getExternalRefDelta });
    }
    __name(loadPackIndex, "loadPackIndex");
    function readPackIndex({
      fs,
      cache,
      filename,
      getExternalRefDelta,
      emitter,
      emitterPrefix
    }) {
      if (!cache[PackfileCache]) cache[PackfileCache] = /* @__PURE__ */ new Map();
      let p = cache[PackfileCache].get(filename);
      if (!p) {
        p = loadPackIndex({
          fs,
          filename,
          getExternalRefDelta,
          emitter,
          emitterPrefix
        });
        cache[PackfileCache].set(filename, p);
      }
      return p;
    }
    __name(readPackIndex, "readPackIndex");
    async function readObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      format = "content",
      getExternalRefDelta
    }) {
      let list = await fs.readdir(pathBrowserify.join(gitdir, "objects/pack"));
      list = list.filter((x) => x.endsWith(".idx"));
      for (const filename of list) {
        const indexFile = `${gitdir}/objects/pack/${filename}`;
        const p = await readPackIndex({
          fs,
          cache,
          filename: indexFile,
          getExternalRefDelta
        });
        if (p.error) throw new InternalError(p.error);
        if (p.offsets.has(oid)) {
          if (!p.pack) {
            const packFile = indexFile.replace(/idx$/, "pack");
            p.pack = fs.read(packFile);
          }
          const result = await p.read({ oid, getExternalRefDelta });
          result.format = "content";
          result.source = `objects/pack/${filename.replace(/idx$/, "pack")}`;
          return result;
        }
      }
      return null;
    }
    __name(readObjectPacked, "readObjectPacked");
    async function _readObject({
      fs,
      cache,
      gitdir,
      oid,
      format = "content"
    }) {
      const getExternalRefDelta = /* @__PURE__ */ __name((oid2) => _readObject({ fs, cache, gitdir, oid: oid2 }), "getExternalRefDelta");
      let result;
      if (oid === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") {
        result = { format: "wrapped", object: Buffer.from(`tree 0\0`) };
      }
      if (!result) {
        result = await readObjectLoose({ fs, gitdir, oid });
      }
      if (!result) {
        result = await readObjectPacked({
          fs,
          cache,
          gitdir,
          oid,
          getExternalRefDelta
        });
        if (!result) {
          throw new NotFoundError(oid);
        }
        return result;
      }
      if (format === "deflated") {
        return result;
      }
      if (result.format === "deflated") {
        result.object = Buffer.from(await inflate(result.object));
        result.format = "wrapped";
      }
      if (format === "wrapped") {
        return result;
      }
      const sha = await shasum(result.object);
      if (sha !== oid) {
        throw new InternalError(
          `SHA check failed! Expected ${oid}, computed ${sha}`
        );
      }
      const { object, type } = GitObject.unwrap(result.object);
      result.type = type;
      result.object = object;
      result.format = "content";
      if (format === "content") {
        return result;
      }
      throw new InternalError(`invalid requested format "${format}"`);
    }
    __name(_readObject, "_readObject");
    var _AlreadyExistsError = class _AlreadyExistsError extends BaseError {
      /**
       * @param {'note'|'remote'|'tag'|'branch'} noun
       * @param {string} where
       * @param {boolean} canForce
       */
      constructor(noun, where, canForce = true) {
        super(
          `Failed to create ${noun} at ${where} because it already exists.${canForce ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)` : ""}`
        );
        this.code = this.name = _AlreadyExistsError.code;
        this.data = { noun, where, canForce };
      }
    };
    __name(_AlreadyExistsError, "AlreadyExistsError");
    var AlreadyExistsError = _AlreadyExistsError;
    AlreadyExistsError.code = "AlreadyExistsError";
    var _AmbiguousError = class _AmbiguousError extends BaseError {
      /**
       * @param {'oids'|'refs'} nouns
       * @param {string} short
       * @param {string[]} matches
       */
      constructor(nouns, short, matches) {
        super(
          `Found multiple ${nouns} matching "${short}" (${matches.join(
            ", "
          )}). Use a longer abbreviation length to disambiguate them.`
        );
        this.code = this.name = _AmbiguousError.code;
        this.data = { nouns, short, matches };
      }
    };
    __name(_AmbiguousError, "AmbiguousError");
    var AmbiguousError = _AmbiguousError;
    AmbiguousError.code = "AmbiguousError";
    var _CheckoutConflictError = class _CheckoutConflictError extends BaseError {
      /**
       * @param {string[]} filepaths
       */
      constructor(filepaths) {
        super(
          `Your local changes to the following files would be overwritten by checkout: ${filepaths.join(
            ", "
          )}`
        );
        this.code = this.name = _CheckoutConflictError.code;
        this.data = { filepaths };
      }
    };
    __name(_CheckoutConflictError, "CheckoutConflictError");
    var CheckoutConflictError = _CheckoutConflictError;
    CheckoutConflictError.code = "CheckoutConflictError";
    var _CommitNotFetchedError = class _CommitNotFetchedError extends BaseError {
      /**
       * @param {string} ref
       * @param {string} oid
       */
      constructor(ref, oid) {
        super(
          `Failed to checkout "${ref}" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`
        );
        this.code = this.name = _CommitNotFetchedError.code;
        this.data = { ref, oid };
      }
    };
    __name(_CommitNotFetchedError, "CommitNotFetchedError");
    var CommitNotFetchedError = _CommitNotFetchedError;
    CommitNotFetchedError.code = "CommitNotFetchedError";
    var _EmptyServerResponseError = class _EmptyServerResponseError extends BaseError {
      constructor() {
        super(`Empty response from git server.`);
        this.code = this.name = _EmptyServerResponseError.code;
        this.data = {};
      }
    };
    __name(_EmptyServerResponseError, "EmptyServerResponseError");
    var EmptyServerResponseError = _EmptyServerResponseError;
    EmptyServerResponseError.code = "EmptyServerResponseError";
    var _FastForwardError = class _FastForwardError extends BaseError {
      constructor() {
        super(`A simple fast-forward merge was not possible.`);
        this.code = this.name = _FastForwardError.code;
        this.data = {};
      }
    };
    __name(_FastForwardError, "FastForwardError");
    var FastForwardError = _FastForwardError;
    FastForwardError.code = "FastForwardError";
    var _GitPushError = class _GitPushError extends BaseError {
      /**
       * @param {string} prettyDetails
       * @param {PushResult} result
       */
      constructor(prettyDetails, result) {
        super(`One or more branches were not updated: ${prettyDetails}`);
        this.code = this.name = _GitPushError.code;
        this.data = { prettyDetails, result };
      }
    };
    __name(_GitPushError, "GitPushError");
    var GitPushError = _GitPushError;
    GitPushError.code = "GitPushError";
    var _HttpError = class _HttpError extends BaseError {
      /**
       * @param {number} statusCode
       * @param {string} statusMessage
       * @param {string} response
       */
      constructor(statusCode, statusMessage, response) {
        super(`HTTP Error: ${statusCode} ${statusMessage}`);
        this.code = this.name = _HttpError.code;
        this.data = { statusCode, statusMessage, response };
      }
    };
    __name(_HttpError, "HttpError");
    var HttpError = _HttpError;
    HttpError.code = "HttpError";
    var _InvalidFilepathError = class _InvalidFilepathError extends BaseError {
      /**
       * @param {'leading-slash'|'trailing-slash'|'directory'} [reason]
       */
      constructor(reason) {
        let message = "invalid filepath";
        if (reason === "leading-slash" || reason === "trailing-slash") {
          message = `"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;
        } else if (reason === "directory") {
          message = `"filepath" should not be a directory.`;
        }
        super(message);
        this.code = this.name = _InvalidFilepathError.code;
        this.data = { reason };
      }
    };
    __name(_InvalidFilepathError, "InvalidFilepathError");
    var InvalidFilepathError = _InvalidFilepathError;
    InvalidFilepathError.code = "InvalidFilepathError";
    var _InvalidRefNameError = class _InvalidRefNameError extends BaseError {
      /**
       * @param {string} ref
       * @param {string} suggestion
       * @param {boolean} canForce
       */
      constructor(ref, suggestion) {
        super(
          `"${ref}" would be an invalid git reference. (Hint: a valid alternative would be "${suggestion}".)`
        );
        this.code = this.name = _InvalidRefNameError.code;
        this.data = { ref, suggestion };
      }
    };
    __name(_InvalidRefNameError, "InvalidRefNameError");
    var InvalidRefNameError = _InvalidRefNameError;
    InvalidRefNameError.code = "InvalidRefNameError";
    var _MaxDepthError = class _MaxDepthError extends BaseError {
      /**
       * @param {number} depth
       */
      constructor(depth) {
        super(`Maximum search depth of ${depth} exceeded.`);
        this.code = this.name = _MaxDepthError.code;
        this.data = { depth };
      }
    };
    __name(_MaxDepthError, "MaxDepthError");
    var MaxDepthError = _MaxDepthError;
    MaxDepthError.code = "MaxDepthError";
    var _MergeNotSupportedError = class _MergeNotSupportedError extends BaseError {
      constructor() {
        super(`Merges with conflicts are not supported yet.`);
        this.code = this.name = _MergeNotSupportedError.code;
        this.data = {};
      }
    };
    __name(_MergeNotSupportedError, "MergeNotSupportedError");
    var MergeNotSupportedError = _MergeNotSupportedError;
    MergeNotSupportedError.code = "MergeNotSupportedError";
    var _MergeConflictError = class _MergeConflictError extends BaseError {
      /**
       * @param {Array<string>} filepaths
       * @param {Array<string>} bothModified
       * @param {Array<string>} deleteByUs
       * @param {Array<string>} deleteByTheirs
       */
      constructor(filepaths, bothModified, deleteByUs, deleteByTheirs) {
        super(
          `Automatic merge failed with one or more merge conflicts in the following files: ${filepaths.toString()}. Fix conflicts then commit the result.`
        );
        this.code = this.name = _MergeConflictError.code;
        this.data = { filepaths, bothModified, deleteByUs, deleteByTheirs };
      }
    };
    __name(_MergeConflictError, "MergeConflictError");
    var MergeConflictError = _MergeConflictError;
    MergeConflictError.code = "MergeConflictError";
    var _MissingNameError = class _MissingNameError extends BaseError {
      /**
       * @param {'author'|'committer'|'tagger'} role
       */
      constructor(role) {
        super(
          `No name was provided for ${role} in the argument or in the .git/config file.`
        );
        this.code = this.name = _MissingNameError.code;
        this.data = { role };
      }
    };
    __name(_MissingNameError, "MissingNameError");
    var MissingNameError = _MissingNameError;
    MissingNameError.code = "MissingNameError";
    var _MissingParameterError = class _MissingParameterError extends BaseError {
      /**
       * @param {string} parameter
       */
      constructor(parameter) {
        super(
          `The function requires a "${parameter}" parameter but none was provided.`
        );
        this.code = this.name = _MissingParameterError.code;
        this.data = { parameter };
      }
    };
    __name(_MissingParameterError, "MissingParameterError");
    var MissingParameterError = _MissingParameterError;
    MissingParameterError.code = "MissingParameterError";
    var _MultipleGitError = class _MultipleGitError extends BaseError {
      /**
       * @param {Error[]} errors
       * @param {string} message
       */
      constructor(errors) {
        super(
          `There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more`
        );
        this.code = this.name = _MultipleGitError.code;
        this.data = { errors };
        this.errors = errors;
      }
    };
    __name(_MultipleGitError, "MultipleGitError");
    var MultipleGitError = _MultipleGitError;
    MultipleGitError.code = "MultipleGitError";
    var _ParseError = class _ParseError extends BaseError {
      /**
       * @param {string} expected
       * @param {string} actual
       */
      constructor(expected, actual) {
        super(`Expected "${expected}" but received "${actual}".`);
        this.code = this.name = _ParseError.code;
        this.data = { expected, actual };
      }
    };
    __name(_ParseError, "ParseError");
    var ParseError = _ParseError;
    ParseError.code = "ParseError";
    var _PushRejectedError = class _PushRejectedError extends BaseError {
      /**
       * @param {'not-fast-forward'|'tag-exists'} reason
       */
      constructor(reason) {
        let message = "";
        if (reason === "not-fast-forward") {
          message = " because it was not a simple fast-forward";
        } else if (reason === "tag-exists") {
          message = " because tag already exists";
        }
        super(`Push rejected${message}. Use "force: true" to override.`);
        this.code = this.name = _PushRejectedError.code;
        this.data = { reason };
      }
    };
    __name(_PushRejectedError, "PushRejectedError");
    var PushRejectedError = _PushRejectedError;
    PushRejectedError.code = "PushRejectedError";
    var _RemoteCapabilityError = class _RemoteCapabilityError extends BaseError {
      /**
       * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability
       * @param {'depth'|'since'|'exclude'|'relative'} parameter
       */
      constructor(capability, parameter) {
        super(
          `Remote does not support the "${capability}" so the "${parameter}" parameter cannot be used.`
        );
        this.code = this.name = _RemoteCapabilityError.code;
        this.data = { capability, parameter };
      }
    };
    __name(_RemoteCapabilityError, "RemoteCapabilityError");
    var RemoteCapabilityError = _RemoteCapabilityError;
    RemoteCapabilityError.code = "RemoteCapabilityError";
    var _SmartHttpError = class _SmartHttpError extends BaseError {
      /**
       * @param {string} preview
       * @param {string} response
       */
      constructor(preview, response) {
        super(
          `Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${preview}`
        );
        this.code = this.name = _SmartHttpError.code;
        this.data = { preview, response };
      }
    };
    __name(_SmartHttpError, "SmartHttpError");
    var SmartHttpError = _SmartHttpError;
    SmartHttpError.code = "SmartHttpError";
    var _UnknownTransportError = class _UnknownTransportError extends BaseError {
      /**
       * @param {string} url
       * @param {string} transport
       * @param {string} [suggestion]
       */
      constructor(url, transport, suggestion) {
        super(
          `Git remote "${url}" uses an unrecognized transport protocol: "${transport}"`
        );
        this.code = this.name = _UnknownTransportError.code;
        this.data = { url, transport, suggestion };
      }
    };
    __name(_UnknownTransportError, "UnknownTransportError");
    var UnknownTransportError = _UnknownTransportError;
    UnknownTransportError.code = "UnknownTransportError";
    var _UrlParseError = class _UrlParseError extends BaseError {
      /**
       * @param {string} url
       */
      constructor(url) {
        super(`Cannot parse remote URL: "${url}"`);
        this.code = this.name = _UrlParseError.code;
        this.data = { url };
      }
    };
    __name(_UrlParseError, "UrlParseError");
    var UrlParseError = _UrlParseError;
    UrlParseError.code = "UrlParseError";
    var _UserCanceledError = class _UserCanceledError extends BaseError {
      constructor() {
        super(`The operation was canceled.`);
        this.code = this.name = _UserCanceledError.code;
        this.data = {};
      }
    };
    __name(_UserCanceledError, "UserCanceledError");
    var UserCanceledError = _UserCanceledError;
    UserCanceledError.code = "UserCanceledError";
    var _IndexResetError = class _IndexResetError extends BaseError {
      /**
       * @param {Array<string>} filepaths
       */
      constructor(filepath) {
        super(
          `Could not merge index: Entry for '${filepath}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`
        );
        this.code = this.name = _IndexResetError.code;
        this.data = { filepath };
      }
    };
    __name(_IndexResetError, "IndexResetError");
    var IndexResetError = _IndexResetError;
    IndexResetError.code = "IndexResetError";
    var _NoCommitError = class _NoCommitError extends BaseError {
      /**
       * @param {string} ref
       */
      constructor(ref) {
        super(
          `"${ref}" does not point to any commit. You're maybe working on a repository with no commits yet. `
        );
        this.code = this.name = _NoCommitError.code;
        this.data = { ref };
      }
    };
    __name(_NoCommitError, "NoCommitError");
    var NoCommitError = _NoCommitError;
    NoCommitError.code = "NoCommitError";
    var Errors = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      AlreadyExistsError,
      AmbiguousError,
      CheckoutConflictError,
      CommitNotFetchedError,
      EmptyServerResponseError,
      FastForwardError,
      GitPushError,
      HttpError,
      InternalError,
      InvalidFilepathError,
      InvalidOidError,
      InvalidRefNameError,
      MaxDepthError,
      MergeNotSupportedError,
      MergeConflictError,
      MissingNameError,
      MissingParameterError,
      MultipleGitError,
      NoRefspecError,
      NotFoundError,
      ObjectTypeError,
      ParseError,
      PushRejectedError,
      RemoteCapabilityError,
      SmartHttpError,
      UnknownTransportError,
      UnsafeFilepathError,
      UrlParseError,
      UserCanceledError,
      UnmergedPathsError,
      IndexResetError,
      NoCommitError
    });
    function formatAuthor({ name, email, timestamp, timezoneOffset }) {
      timezoneOffset = formatTimezoneOffset(timezoneOffset);
      return `${name} <${email}> ${timestamp} ${timezoneOffset}`;
    }
    __name(formatAuthor, "formatAuthor");
    function formatTimezoneOffset(minutes) {
      const sign = simpleSign(negateExceptForZero(minutes));
      minutes = Math.abs(minutes);
      const hours = Math.floor(minutes / 60);
      minutes -= hours * 60;
      let strHours = String(hours);
      let strMinutes = String(minutes);
      if (strHours.length < 2) strHours = "0" + strHours;
      if (strMinutes.length < 2) strMinutes = "0" + strMinutes;
      return (sign === -1 ? "-" : "+") + strHours + strMinutes;
    }
    __name(formatTimezoneOffset, "formatTimezoneOffset");
    function simpleSign(n) {
      return Math.sign(n) || (Object.is(n, -0) ? -1 : 1);
    }
    __name(simpleSign, "simpleSign");
    function negateExceptForZero(n) {
      return n === 0 ? n : -n;
    }
    __name(negateExceptForZero, "negateExceptForZero");
    function normalizeNewlines(str) {
      str = str.replace(/\r/g, "");
      str = str.replace(/^\n+/, "");
      str = str.replace(/\n+$/, "") + "\n";
      return str;
    }
    __name(normalizeNewlines, "normalizeNewlines");
    function parseAuthor(author) {
      const [, name, email, timestamp, offset] = author.match(
        /^(.*) <(.*)> (.*) (.*)$/
      );
      return {
        name,
        email,
        timestamp: Number(timestamp),
        timezoneOffset: parseTimezoneOffset(offset)
      };
    }
    __name(parseAuthor, "parseAuthor");
    function parseTimezoneOffset(offset) {
      let [, sign, hours, minutes] = offset.match(/(\+|-)(\d\d)(\d\d)/);
      minutes = (sign === "+" ? 1 : -1) * (Number(hours) * 60 + Number(minutes));
      return negateExceptForZero$1(minutes);
    }
    __name(parseTimezoneOffset, "parseTimezoneOffset");
    function negateExceptForZero$1(n) {
      return n === 0 ? n : -n;
    }
    __name(negateExceptForZero$1, "negateExceptForZero$1");
    var _GitAnnotatedTag = class _GitAnnotatedTag {
      constructor(tag2) {
        if (typeof tag2 === "string") {
          this._tag = tag2;
        } else if (Buffer.isBuffer(tag2)) {
          this._tag = tag2.toString("utf8");
        } else if (typeof tag2 === "object") {
          this._tag = _GitAnnotatedTag.render(tag2);
        } else {
          throw new InternalError(
            "invalid type passed to GitAnnotatedTag constructor"
          );
        }
      }
      static from(tag2) {
        return new _GitAnnotatedTag(tag2);
      }
      static render(obj) {
        return `object ${obj.object}
type ${obj.type}
tag ${obj.tag}
tagger ${formatAuthor(obj.tagger)}

${obj.message}
${obj.gpgsig ? obj.gpgsig : ""}`;
      }
      justHeaders() {
        return this._tag.slice(0, this._tag.indexOf("\n\n"));
      }
      message() {
        const tag2 = this.withoutSignature();
        return tag2.slice(tag2.indexOf("\n\n") + 2);
      }
      parse() {
        return Object.assign(this.headers(), {
          message: this.message(),
          gpgsig: this.gpgsig()
        });
      }
      render() {
        return this._tag;
      }
      headers() {
        const headers = this.justHeaders().split("\n");
        const hs = [];
        for (const h of headers) {
          if (h[0] === " ") {
            hs[hs.length - 1] += "\n" + h.slice(1);
          } else {
            hs.push(h);
          }
        }
        const obj = {};
        for (const h of hs) {
          const key = h.slice(0, h.indexOf(" "));
          const value = h.slice(h.indexOf(" ") + 1);
          if (Array.isArray(obj[key])) {
            obj[key].push(value);
          } else {
            obj[key] = value;
          }
        }
        if (obj.tagger) {
          obj.tagger = parseAuthor(obj.tagger);
        }
        if (obj.committer) {
          obj.committer = parseAuthor(obj.committer);
        }
        return obj;
      }
      withoutSignature() {
        const tag2 = normalizeNewlines(this._tag);
        if (tag2.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1) return tag2;
        return tag2.slice(0, tag2.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----"));
      }
      gpgsig() {
        if (this._tag.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1) return;
        const signature = this._tag.slice(
          this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),
          this._tag.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length
        );
        return normalizeNewlines(signature);
      }
      payload() {
        return this.withoutSignature() + "\n";
      }
      toObject() {
        return Buffer.from(this._tag, "utf8");
      }
      static async sign(tag2, sign, secretKey) {
        const payload = tag2.payload();
        let { signature } = await sign({ payload, secretKey });
        signature = normalizeNewlines(signature);
        const signedTag = payload + signature;
        return _GitAnnotatedTag.from(signedTag);
      }
    };
    __name(_GitAnnotatedTag, "GitAnnotatedTag");
    var GitAnnotatedTag = _GitAnnotatedTag;
    function indent(str) {
      return str.trim().split("\n").map((x) => " " + x).join("\n") + "\n";
    }
    __name(indent, "indent");
    function outdent(str) {
      return str.split("\n").map((x) => x.replace(/^ /, "")).join("\n");
    }
    __name(outdent, "outdent");
    var _GitCommit = class _GitCommit {
      constructor(commit2) {
        if (typeof commit2 === "string") {
          this._commit = commit2;
        } else if (Buffer.isBuffer(commit2)) {
          this._commit = commit2.toString("utf8");
        } else if (typeof commit2 === "object") {
          this._commit = _GitCommit.render(commit2);
        } else {
          throw new InternalError("invalid type passed to GitCommit constructor");
        }
      }
      static fromPayloadSignature({ payload, signature }) {
        const headers = _GitCommit.justHeaders(payload);
        const message = _GitCommit.justMessage(payload);
        const commit2 = normalizeNewlines(
          headers + "\ngpgsig" + indent(signature) + "\n" + message
        );
        return new _GitCommit(commit2);
      }
      static from(commit2) {
        return new _GitCommit(commit2);
      }
      toObject() {
        return Buffer.from(this._commit, "utf8");
      }
      // Todo: allow setting the headers and message
      headers() {
        return this.parseHeaders();
      }
      // Todo: allow setting the headers and message
      message() {
        return _GitCommit.justMessage(this._commit);
      }
      parse() {
        return Object.assign({ message: this.message() }, this.headers());
      }
      static justMessage(commit2) {
        return normalizeNewlines(commit2.slice(commit2.indexOf("\n\n") + 2));
      }
      static justHeaders(commit2) {
        return commit2.slice(0, commit2.indexOf("\n\n"));
      }
      parseHeaders() {
        const headers = _GitCommit.justHeaders(this._commit).split("\n");
        const hs = [];
        for (const h of headers) {
          if (h[0] === " ") {
            hs[hs.length - 1] += "\n" + h.slice(1);
          } else {
            hs.push(h);
          }
        }
        const obj = {
          parent: []
        };
        for (const h of hs) {
          const key = h.slice(0, h.indexOf(" "));
          const value = h.slice(h.indexOf(" ") + 1);
          if (Array.isArray(obj[key])) {
            obj[key].push(value);
          } else {
            obj[key] = value;
          }
        }
        if (obj.author) {
          obj.author = parseAuthor(obj.author);
        }
        if (obj.committer) {
          obj.committer = parseAuthor(obj.committer);
        }
        return obj;
      }
      static renderHeaders(obj) {
        let headers = "";
        if (obj.tree) {
          headers += `tree ${obj.tree}
`;
        } else {
          headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`;
        }
        if (obj.parent) {
          if (obj.parent.length === void 0) {
            throw new InternalError(`commit 'parent' property should be an array`);
          }
          for (const p of obj.parent) {
            headers += `parent ${p}
`;
          }
        }
        const author = obj.author;
        headers += `author ${formatAuthor(author)}
`;
        const committer = obj.committer || obj.author;
        headers += `committer ${formatAuthor(committer)}
`;
        if (obj.gpgsig) {
          headers += "gpgsig" + indent(obj.gpgsig);
        }
        return headers;
      }
      static render(obj) {
        return _GitCommit.renderHeaders(obj) + "\n" + normalizeNewlines(obj.message);
      }
      render() {
        return this._commit;
      }
      withoutSignature() {
        const commit2 = normalizeNewlines(this._commit);
        if (commit2.indexOf("\ngpgsig") === -1) return commit2;
        const headers = commit2.slice(0, commit2.indexOf("\ngpgsig"));
        const message = commit2.slice(
          commit2.indexOf("-----END PGP SIGNATURE-----\n") + "-----END PGP SIGNATURE-----\n".length
        );
        return normalizeNewlines(headers + "\n" + message);
      }
      isolateSignature() {
        const signature = this._commit.slice(
          this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),
          this._commit.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length
        );
        return outdent(signature);
      }
      static async sign(commit2, sign, secretKey) {
        const payload = commit2.withoutSignature();
        const message = _GitCommit.justMessage(commit2._commit);
        let { signature } = await sign({ payload, secretKey });
        signature = normalizeNewlines(signature);
        const headers = _GitCommit.justHeaders(commit2._commit);
        const signedCommit = headers + "\ngpgsig" + indent(signature) + "\n" + message;
        return _GitCommit.from(signedCommit);
      }
    };
    __name(_GitCommit, "GitCommit");
    var GitCommit = _GitCommit;
    async function resolveTree({ fs, cache, gitdir, oid }) {
      if (oid === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") {
        return { tree: GitTree.from([]), oid };
      }
      const { type, object } = await _readObject({ fs, cache, gitdir, oid });
      if (type === "tag") {
        oid = GitAnnotatedTag.from(object).parse().object;
        return resolveTree({ fs, cache, gitdir, oid });
      }
      if (type === "commit") {
        oid = GitCommit.from(object).parse().tree;
        return resolveTree({ fs, cache, gitdir, oid });
      }
      if (type !== "tree") {
        throw new ObjectTypeError(oid, type, "tree");
      }
      return { tree: GitTree.from(object), oid };
    }
    __name(resolveTree, "resolveTree");
    var _GitWalkerRepo = class _GitWalkerRepo {
      constructor({ fs, gitdir, ref, cache }) {
        var _a;
        this.fs = fs;
        this.cache = cache;
        this.gitdir = gitdir;
        this.mapPromise = (async () => {
          const map = /* @__PURE__ */ new Map();
          let oid;
          try {
            oid = await GitRefManager.resolve({ fs, gitdir, ref });
          } catch (e) {
            if (e instanceof NotFoundError) {
              oid = "4b825dc642cb6eb9a060e54bf8d69288fbee4904";
            }
          }
          const tree = await resolveTree({ fs, cache: this.cache, gitdir, oid });
          tree.type = "tree";
          tree.mode = "40000";
          map.set(".", tree);
          return map;
        })();
        const walker = this;
        this.ConstructEntry = (_a = class {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._content = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        }, __name(_a, "TreeEntry"), _a);
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const { fs, cache, gitdir } = this;
        const map = await this.mapPromise;
        const obj = map.get(filepath);
        if (!obj) throw new Error(`No obj for ${filepath}`);
        const oid = obj.oid;
        if (!oid) throw new Error(`No oid for obj ${JSON.stringify(obj)}`);
        if (obj.type !== "tree") {
          return null;
        }
        const { type, object } = await _readObject({ fs, cache, gitdir, oid });
        if (type !== obj.type) {
          throw new ObjectTypeError(oid, type, obj.type);
        }
        const tree = GitTree.from(object);
        for (const entry2 of tree) {
          map.set(pathBrowserify.join(filepath, entry2.path), entry2);
        }
        return tree.entries().map((entry2) => pathBrowserify.join(filepath, entry2.path));
      }
      async type(entry) {
        if (entry._type === false) {
          const map = await this.mapPromise;
          const { type } = map.get(entry._fullpath);
          entry._type = type;
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          const map = await this.mapPromise;
          const { mode } = map.get(entry._fullpath);
          entry._mode = normalizeMode(parseInt(mode, 8));
        }
        return entry._mode;
      }
      async stat(_entry) {
      }
      async content(entry) {
        if (entry._content === false) {
          const map = await this.mapPromise;
          const { fs, cache, gitdir } = this;
          const obj = map.get(entry._fullpath);
          const oid = obj.oid;
          const { type, object } = await _readObject({ fs, cache, gitdir, oid });
          if (type !== "blob") {
            entry._content = void 0;
          } else {
            entry._content = new Uint8Array(object);
          }
        }
        return entry._content;
      }
      async oid(entry) {
        if (entry._oid === false) {
          const map = await this.mapPromise;
          const obj = map.get(entry._fullpath);
          entry._oid = obj.oid;
        }
        return entry._oid;
      }
    };
    __name(_GitWalkerRepo, "GitWalkerRepo");
    var GitWalkerRepo = _GitWalkerRepo;
    function TREE({ ref = "HEAD" } = {}) {
      const o = /* @__PURE__ */ Object.create(null);
      Object.defineProperty(o, GitWalkSymbol, {
        value: /* @__PURE__ */ __name(function({ fs, gitdir, cache }) {
          return new GitWalkerRepo({ fs, gitdir, ref, cache });
        }, "value")
      });
      Object.freeze(o);
      return o;
    }
    __name(TREE, "TREE");
    var _GitWalkerFs = class _GitWalkerFs {
      constructor({ fs, dir, gitdir, cache }) {
        var _a;
        this.fs = fs;
        this.cache = cache;
        this.dir = dir;
        this.gitdir = gitdir;
        this.config = null;
        const walker = this;
        this.ConstructEntry = (_a = class {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._content = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        }, __name(_a, "WorkdirEntry"), _a);
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const { fs, dir } = this;
        const names = await fs.readdir(pathBrowserify.join(dir, filepath));
        if (names === null) return null;
        return names.map((name) => pathBrowserify.join(filepath, name));
      }
      async type(entry) {
        if (entry._type === false) {
          await entry.stat();
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          await entry.stat();
        }
        return entry._mode;
      }
      async stat(entry) {
        if (entry._stat === false) {
          const { fs, dir } = this;
          let stat = await fs.lstat(`${dir}/${entry._fullpath}`);
          if (!stat) {
            throw new Error(
              `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
            );
          }
          let type = stat.isDirectory() ? "tree" : "blob";
          if (type === "blob" && !stat.isFile() && !stat.isSymbolicLink()) {
            type = "special";
          }
          entry._type = type;
          stat = normalizeStats(stat);
          entry._mode = stat.mode;
          if (stat.size === -1 && entry._actualSize) {
            stat.size = entry._actualSize;
          }
          entry._stat = stat;
        }
        return entry._stat;
      }
      async content(entry) {
        if (entry._content === false) {
          const { fs, dir, gitdir } = this;
          if (await entry.type() === "tree") {
            entry._content = void 0;
          } else {
            const config = await this._getGitConfig(fs, gitdir);
            const autocrlf = await config.get("core.autocrlf");
            const content = await fs.read(`${dir}/${entry._fullpath}`, { autocrlf });
            entry._actualSize = content.length;
            if (entry._stat && entry._stat.size === -1) {
              entry._stat.size = entry._actualSize;
            }
            entry._content = new Uint8Array(content);
          }
        }
        return entry._content;
      }
      async oid(entry) {
        if (entry._oid === false) {
          const self2 = this;
          const { fs, gitdir, cache } = this;
          let oid;
          await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index3) {
            const stage = index3.entriesMap.get(entry._fullpath);
            const stats = await entry.stat();
            const config = await self2._getGitConfig(fs, gitdir);
            const filemode = await config.get("core.filemode");
            const trustino = typeof process !== "undefined" ? !(process.platform === "win32") : true;
            if (!stage || compareStats(stats, stage, filemode, trustino)) {
              const content = await entry.content();
              if (content === void 0) {
                oid = void 0;
              } else {
                oid = await shasum(
                  GitObject.wrap({ type: "blob", object: content })
                );
                if (stage && oid === stage.oid && (!filemode || stats.mode === stage.mode) && compareStats(stats, stage, filemode, trustino)) {
                  index3.insert({
                    filepath: entry._fullpath,
                    stats,
                    oid
                  });
                }
              }
            } else {
              oid = stage.oid;
            }
          });
          entry._oid = oid;
        }
        return entry._oid;
      }
      async _getGitConfig(fs, gitdir) {
        if (this.config) {
          return this.config;
        }
        this.config = await GitConfigManager.get({ fs, gitdir });
        return this.config;
      }
    };
    __name(_GitWalkerFs, "GitWalkerFs");
    var GitWalkerFs = _GitWalkerFs;
    function WORKDIR() {
      const o = /* @__PURE__ */ Object.create(null);
      Object.defineProperty(o, GitWalkSymbol, {
        value: /* @__PURE__ */ __name(function({ fs, dir, gitdir, cache }) {
          return new GitWalkerFs({ fs, dir, gitdir, cache });
        }, "value")
      });
      Object.freeze(o);
      return o;
    }
    __name(WORKDIR, "WORKDIR");
    function arrayRange(start, end) {
      const length = end - start;
      return Array.from({ length }, (_, i) => start + i);
    }
    __name(arrayRange, "arrayRange");
    var flat = typeof Array.prototype.flat === "undefined" ? (entries) => entries.reduce((acc, x) => acc.concat(x), []) : (entries) => entries.flat();
    var _RunningMinimum = class _RunningMinimum {
      constructor() {
        this.value = null;
      }
      consider(value) {
        if (value === null || value === void 0) return;
        if (this.value === null) {
          this.value = value;
        } else if (value < this.value) {
          this.value = value;
        }
      }
      reset() {
        this.value = null;
      }
    };
    __name(_RunningMinimum, "RunningMinimum");
    var RunningMinimum = _RunningMinimum;
    function* unionOfIterators(sets) {
      const min = new RunningMinimum();
      let minimum;
      const heads = [];
      const numsets = sets.length;
      for (let i = 0; i < numsets; i++) {
        heads[i] = sets[i].next().value;
        if (heads[i] !== void 0) {
          min.consider(heads[i]);
        }
      }
      if (min.value === null) return;
      while (true) {
        const result = [];
        minimum = min.value;
        min.reset();
        for (let i = 0; i < numsets; i++) {
          if (heads[i] !== void 0 && heads[i] === minimum) {
            result[i] = heads[i];
            heads[i] = sets[i].next().value;
          } else {
            result[i] = null;
          }
          if (heads[i] !== void 0) {
            min.consider(heads[i]);
          }
        }
        yield result;
        if (min.value === null) return;
      }
    }
    __name(unionOfIterators, "unionOfIterators");
    async function _walk({
      fs,
      cache,
      dir,
      gitdir,
      trees,
      // @ts-ignore
      map = /* @__PURE__ */ __name(async (_, entry) => entry, "map"),
      // The default reducer is a flatmap that filters out undefineds.
      reduce = /* @__PURE__ */ __name(async (parent, children) => {
        const flatten = flat(children);
        if (parent !== void 0) flatten.unshift(parent);
        return flatten;
      }, "reduce"),
      // The default iterate function walks all children concurrently
      iterate = /* @__PURE__ */ __name((walk2, children) => Promise.all([...children].map(walk2)), "iterate")
    }) {
      const walkers = trees.map(
        (proxy) => proxy[GitWalkSymbol]({ fs, dir, gitdir, cache })
      );
      const root = new Array(walkers.length).fill(".");
      const range = arrayRange(0, walkers.length);
      const unionWalkerFromReaddir = /* @__PURE__ */ __name(async (entries) => {
        range.map((i) => {
          const entry = entries[i];
          entries[i] = entry && new walkers[i].ConstructEntry(entry);
        });
        const subdirs = await Promise.all(
          range.map((i) => {
            const entry = entries[i];
            return entry ? walkers[i].readdir(entry) : [];
          })
        );
        const iterators = subdirs.map((array) => {
          return (array === null ? [] : array)[Symbol.iterator]();
        });
        return {
          entries,
          children: unionOfIterators(iterators)
        };
      }, "unionWalkerFromReaddir");
      const walk2 = /* @__PURE__ */ __name(async (root2) => {
        const { entries, children } = await unionWalkerFromReaddir(root2);
        const fullpath = entries.find((entry) => entry && entry._fullpath)._fullpath;
        const parent = await map(fullpath, entries);
        if (parent !== null) {
          let walkedChildren = await iterate(walk2, children);
          walkedChildren = walkedChildren.filter((x) => x !== void 0);
          return reduce(parent, walkedChildren);
        }
      }, "walk");
      return walk2(root);
    }
    __name(_walk, "_walk");
    async function rmRecursive(fs, filepath) {
      const entries = await fs.readdir(filepath);
      if (entries == null) {
        await fs.rm(filepath);
      } else if (entries.length) {
        await Promise.all(
          entries.map((entry) => {
            const subpath = pathBrowserify.join(filepath, entry);
            return fs.lstat(subpath).then((stat) => {
              if (!stat) return;
              return stat.isDirectory() ? rmRecursive(fs, subpath) : fs.rm(subpath);
            });
          })
        ).then(() => fs.rmdir(filepath));
      } else {
        await fs.rmdir(filepath);
      }
    }
    __name(rmRecursive, "rmRecursive");
    function isPromiseLike(obj) {
      return isObject(obj) && isFunction(obj.then) && isFunction(obj.catch);
    }
    __name(isPromiseLike, "isPromiseLike");
    function isObject(obj) {
      return obj && typeof obj === "object";
    }
    __name(isObject, "isObject");
    function isFunction(obj) {
      return typeof obj === "function";
    }
    __name(isFunction, "isFunction");
    function isPromiseFs(fs) {
      const test = /* @__PURE__ */ __name((targetFs) => {
        try {
          return targetFs.readFile().catch((e) => e);
        } catch (e) {
          return e;
        }
      }, "test");
      return isPromiseLike(test(fs));
    }
    __name(isPromiseFs, "isPromiseFs");
    var commands = [
      "readFile",
      "writeFile",
      "mkdir",
      "rmdir",
      "unlink",
      "stat",
      "lstat",
      "readdir",
      "readlink",
      "symlink"
    ];
    function bindFs(target, fs) {
      if (isPromiseFs(fs)) {
        for (const command of commands) {
          target[`_${command}`] = fs[command].bind(fs);
        }
      } else {
        for (const command of commands) {
          target[`_${command}`] = pify(fs[command].bind(fs));
        }
      }
      if (isPromiseFs(fs)) {
        if (fs.rm) target._rm = fs.rm.bind(fs);
        else if (fs.rmdir.length > 1) target._rm = fs.rmdir.bind(fs);
        else target._rm = rmRecursive.bind(null, target);
      } else {
        if (fs.rm) target._rm = pify(fs.rm.bind(fs));
        else if (fs.rmdir.length > 2) target._rm = pify(fs.rmdir.bind(fs));
        else target._rm = rmRecursive.bind(null, target);
      }
    }
    __name(bindFs, "bindFs");
    var _FileSystem = class _FileSystem {
      /**
       * Creates an instance of FileSystem.
       *
       * @param {Object} fs - A file system implementation to wrap.
       */
      constructor(fs) {
        if (typeof fs._original_unwrapped_fs !== "undefined") return fs;
        const promises = Object.getOwnPropertyDescriptor(fs, "promises");
        if (promises && promises.enumerable) {
          bindFs(this, fs.promises);
        } else {
          bindFs(this, fs);
        }
        this._original_unwrapped_fs = fs;
      }
      /**
       * Return true if a file exists, false if it doesn't exist.
       * Rethrows errors that aren't related to file existence.
       *
       * @param {string} filepath - The path to the file.
       * @param {Object} [options] - Additional options.
       * @returns {Promise<boolean>} - `true` if the file exists, `false` otherwise.
       */
      async exists(filepath, options = {}) {
        try {
          await this._stat(filepath);
          return true;
        } catch (err) {
          if (err.code === "ENOENT" || err.code === "ENOTDIR" || (err.code || "").includes("ENS")) {
            return false;
          } else {
            console.log('Unhandled error in "FileSystem.exists()" function', err);
            throw err;
          }
        }
      }
      /**
       * Return the contents of a file if it exists, otherwise returns null.
       *
       * @param {string} filepath - The path to the file.
       * @param {Object} [options] - Options for reading the file.
       * @returns {Promise<Buffer|string|null>} - The file contents, or `null` if the file doesn't exist.
       */
      async read(filepath, options = {}) {
        try {
          let buffer = await this._readFile(filepath, options);
          if (options.autocrlf === "true") {
            try {
              buffer = new TextDecoder("utf8", { fatal: true }).decode(buffer);
              buffer = buffer.replace(/\r\n/g, "\n");
              buffer = new TextEncoder().encode(buffer);
            } catch (error) {
            }
          }
          if (typeof buffer !== "string") {
            buffer = Buffer.from(buffer);
          }
          return buffer;
        } catch (err) {
          return null;
        }
      }
      /**
       * Write a file (creating missing directories if need be) without throwing errors.
       *
       * @param {string} filepath - The path to the file.
       * @param {Buffer|Uint8Array|string} contents - The data to write.
       * @param {Object|string} [options] - Options for writing the file.
       * @returns {Promise<void>}
       */
      async write(filepath, contents, options = {}) {
        try {
          await this._writeFile(filepath, contents, options);
          return;
        } catch (err) {
          await this.mkdir(dirname5(filepath));
          await this._writeFile(filepath, contents, options);
        }
      }
      /**
       * Make a directory (or series of nested directories) without throwing an error if it already exists.
       *
       * @param {string} filepath - The path to the directory.
       * @param {boolean} [_selfCall=false] - Internal flag to prevent infinite recursion.
       * @returns {Promise<void>}
       */
      async mkdir(filepath, _selfCall = false) {
        try {
          await this._mkdir(filepath);
          return;
        } catch (err) {
          if (err === null) return;
          if (err.code === "EEXIST") return;
          if (_selfCall) throw err;
          if (err.code === "ENOENT") {
            const parent = dirname5(filepath);
            if (parent === "." || parent === "/" || parent === filepath) throw err;
            await this.mkdir(parent);
            await this.mkdir(filepath, true);
          }
        }
      }
      /**
       * Delete a file without throwing an error if it is already deleted.
       *
       * @param {string} filepath - The path to the file.
       * @returns {Promise<void>}
       */
      async rm(filepath) {
        try {
          await this._unlink(filepath);
        } catch (err) {
          if (err.code !== "ENOENT") throw err;
        }
      }
      /**
       * Delete a directory without throwing an error if it is already deleted.
       *
       * @param {string} filepath - The path to the directory.
       * @param {Object} [opts] - Options for deleting the directory.
       * @returns {Promise<void>}
       */
      async rmdir(filepath, opts) {
        try {
          if (opts && opts.recursive) {
            await this._rm(filepath, opts);
          } else {
            await this._rmdir(filepath);
          }
        } catch (err) {
          if (err.code !== "ENOENT") throw err;
        }
      }
      /**
       * Read a directory without throwing an error is the directory doesn't exist
       *
       * @param {string} filepath - The path to the directory.
       * @returns {Promise<string[]|null>} - An array of file names, or `null` if the path is not a directory.
       */
      async readdir(filepath) {
        try {
          const names = await this._readdir(filepath);
          names.sort(compareStrings);
          return names;
        } catch (err) {
          if (err.code === "ENOTDIR") return null;
          return [];
        }
      }
      /**
       * Return a flat list of all the files nested inside a directory
       *
       * Based on an elegant concurrent recursive solution from SO
       * https://stackoverflow.com/a/45130990/2168416
       *
       * @param {string} dir - The directory to read.
       * @returns {Promise<string[]>} - A flat list of all files in the directory.
       */
      async readdirDeep(dir) {
        const subdirs = await this._readdir(dir);
        const files = await Promise.all(
          subdirs.map(async (subdir) => {
            const res = dir + "/" + subdir;
            return (await this._stat(res)).isDirectory() ? this.readdirDeep(res) : res;
          })
        );
        return files.reduce((a, f) => a.concat(f), []);
      }
      /**
       * Return the Stats of a file/symlink if it exists, otherwise returns null.
       * Rethrows errors that aren't related to file existence.
       *
       * @param {string} filename - The path to the file or symlink.
       * @returns {Promise<Object|null>} - The stats object, or `null` if the file doesn't exist.
       */
      async lstat(filename) {
        try {
          const stats = await this._lstat(filename);
          return stats;
        } catch (err) {
          if (err.code === "ENOENT" || (err.code || "").includes("ENS")) {
            return null;
          }
          throw err;
        }
      }
      /**
       * Reads the contents of a symlink if it exists, otherwise returns null.
       * Rethrows errors that aren't related to file existence.
       *
       * @param {string} filename - The path to the symlink.
       * @param {Object} [opts={ encoding: 'buffer' }] - Options for reading the symlink.
       * @returns {Promise<Buffer|null>} - The symlink target, or `null` if it doesn't exist.
       */
      async readlink(filename, opts = { encoding: "buffer" }) {
        try {
          const link = await this._readlink(filename, opts);
          return Buffer.isBuffer(link) ? link : Buffer.from(link);
        } catch (err) {
          if (err.code === "ENOENT" || (err.code || "").includes("ENS")) {
            return null;
          }
          throw err;
        }
      }
      /**
       * Write the contents of buffer to a symlink.
       *
       * @param {string} filename - The path to the symlink.
       * @param {Buffer} buffer - The symlink target.
       * @returns {Promise<void>}
       */
      async writelink(filename, buffer) {
        return this._symlink(buffer.toString("utf8"), filename);
      }
    };
    __name(_FileSystem, "FileSystem");
    var FileSystem = _FileSystem;
    function assertParameter(name, value) {
      if (value === void 0) {
        throw new MissingParameterError(name);
      }
    }
    __name(assertParameter, "assertParameter");
    async function modified(entry, base) {
      if (!entry && !base) return false;
      if (entry && !base) return true;
      if (!entry && base) return true;
      if (await entry.type() === "tree" && await base.type() === "tree") {
        return false;
      }
      if (await entry.type() === await base.type() && await entry.mode() === await base.mode() && await entry.oid() === await base.oid()) {
        return false;
      }
      return true;
    }
    __name(modified, "modified");
    async function abortMerge({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      commit: commit2 = "HEAD",
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("dir", dir);
        assertParameter("gitdir", gitdir);
        const fs = new FileSystem(_fs);
        const trees = [TREE({ ref: commit2 }), WORKDIR(), STAGE()];
        let unmergedPaths = [];
        await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index3) {
          unmergedPaths = index3.unmergedPaths;
        });
        const results = await _walk({
          fs,
          cache,
          dir,
          gitdir,
          trees,
          map: /* @__PURE__ */ __name(async function(path6, [head, workdir, index3]) {
            const staged = !await modified(workdir, index3);
            const unmerged = unmergedPaths.includes(path6);
            const unmodified = !await modified(index3, head);
            if (staged || unmerged) {
              return head ? {
                path: path6,
                mode: await head.mode(),
                oid: await head.oid(),
                type: await head.type(),
                content: await head.content()
              } : void 0;
            }
            if (unmodified) return false;
            else throw new IndexResetError(path6);
          }, "map")
        });
        await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index3) {
          for (const entry of results) {
            if (entry === false) continue;
            if (!entry) {
              await fs.rmdir(`${dir}/${entry.path}`, { recursive: true });
              index3.delete({ filepath: entry.path });
              continue;
            }
            if (entry.type === "blob") {
              const content = new TextDecoder().decode(entry.content);
              await fs.write(`${dir}/${entry.path}`, content, { mode: entry.mode });
              index3.insert({
                filepath: entry.path,
                oid: entry.oid,
                stage: 0
              });
            }
          }
        });
      } catch (err) {
        err.caller = "git.abortMerge";
        throw err;
      }
    }
    __name(abortMerge, "abortMerge");
    var _GitIgnoreManager = class _GitIgnoreManager {
      /**
       * Determines whether a given file is ignored based on `.gitignore` rules and exclusion files.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} args.dir - The working directory.
       * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {string} args.filepath - The path of the file to check.
       * @returns {Promise<boolean>} - `true` if the file is ignored, `false` otherwise.
       */
      static async isIgnored({ fs, dir, gitdir = pathBrowserify.join(dir, ".git"), filepath }) {
        if (basename2(filepath) === ".git") return true;
        if (filepath === ".") return false;
        let excludes = "";
        const excludesFile = pathBrowserify.join(gitdir, "info", "exclude");
        if (await fs.exists(excludesFile)) {
          excludes = await fs.read(excludesFile, "utf8");
        }
        const pairs = [
          {
            gitignore: pathBrowserify.join(dir, ".gitignore"),
            filepath
          }
        ];
        const pieces = filepath.split("/").filter(Boolean);
        for (let i = 1; i < pieces.length; i++) {
          const folder = pieces.slice(0, i).join("/");
          const file = pieces.slice(i).join("/");
          pairs.push({
            gitignore: pathBrowserify.join(dir, folder, ".gitignore"),
            filepath: file
          });
        }
        let ignoredStatus = false;
        for (const p of pairs) {
          let file;
          try {
            file = await fs.read(p.gitignore, "utf8");
          } catch (err) {
            if (err.code === "NOENT") continue;
          }
          const ign = ignore3().add(excludes);
          ign.add(file);
          const parentdir = dirname5(p.filepath);
          if (parentdir !== "." && ign.ignores(parentdir)) return true;
          if (ignoredStatus) {
            ignoredStatus = !ign.test(p.filepath).unignored;
          } else {
            ignoredStatus = ign.test(p.filepath).ignored;
          }
        }
        return ignoredStatus;
      }
    };
    __name(_GitIgnoreManager, "GitIgnoreManager");
    var GitIgnoreManager = _GitIgnoreManager;
    async function writeObjectLoose({ fs, gitdir, object, format, oid }) {
      if (format !== "deflated") {
        throw new InternalError(
          "GitObjectStoreLoose expects objects to write to be in deflated format"
        );
      }
      const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
      const filepath = `${gitdir}/${source}`;
      if (!await fs.exists(filepath)) await fs.write(filepath, object);
    }
    __name(writeObjectLoose, "writeObjectLoose");
    var supportsCompressionStream = null;
    async function deflate(buffer) {
      if (supportsCompressionStream === null) {
        supportsCompressionStream = testCompressionStream();
      }
      return supportsCompressionStream ? browserDeflate(buffer) : pako.deflate(buffer);
    }
    __name(deflate, "deflate");
    async function browserDeflate(buffer) {
      const cs = new CompressionStream("deflate");
      const c = new Blob([buffer]).stream().pipeThrough(cs);
      return new Uint8Array(await new Response(c).arrayBuffer());
    }
    __name(browserDeflate, "browserDeflate");
    function testCompressionStream() {
      try {
        const cs = new CompressionStream("deflate");
        cs.writable.close();
        const stream = new Blob([]).stream();
        stream.cancel();
        return true;
      } catch (_) {
        return false;
      }
    }
    __name(testCompressionStream, "testCompressionStream");
    async function _writeObject({
      fs,
      gitdir,
      type,
      object,
      format = "content",
      oid = void 0,
      dryRun = false
    }) {
      if (format !== "deflated") {
        if (format !== "wrapped") {
          object = GitObject.wrap({ type, object });
        }
        oid = await shasum(object);
        object = Buffer.from(await deflate(object));
      }
      if (!dryRun) {
        await writeObjectLoose({ fs, gitdir, object, format: "deflated", oid });
      }
      return oid;
    }
    __name(_writeObject, "_writeObject");
    function posixifyPathBuffer(buffer) {
      let idx;
      while (~(idx = buffer.indexOf(92))) buffer[idx] = 47;
      return buffer;
    }
    __name(posixifyPathBuffer, "posixifyPathBuffer");
    async function add({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      filepath,
      cache = {},
      force = false,
      parallel = true
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("dir", dir);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        const fs = new FileSystem(_fs);
        await GitIndexManager.acquire({ fs, gitdir, cache }, async (index3) => {
          const config = await GitConfigManager.get({ fs, gitdir });
          const autocrlf = await config.get("core.autocrlf");
          return addToIndex({
            dir,
            gitdir,
            fs,
            filepath,
            index: index3,
            force,
            parallel,
            autocrlf
          });
        });
      } catch (err) {
        err.caller = "git.add";
        throw err;
      }
    }
    __name(add, "add");
    async function addToIndex({
      dir,
      gitdir,
      fs,
      filepath,
      index: index3,
      force,
      parallel,
      autocrlf
    }) {
      filepath = Array.isArray(filepath) ? filepath : [filepath];
      const promises = filepath.map(async (currentFilepath) => {
        if (!force) {
          const ignored = await GitIgnoreManager.isIgnored({
            fs,
            dir,
            gitdir,
            filepath: currentFilepath
          });
          if (ignored) return;
        }
        const stats = await fs.lstat(pathBrowserify.join(dir, currentFilepath));
        if (!stats) throw new NotFoundError(currentFilepath);
        if (stats.isDirectory()) {
          const children = await fs.readdir(pathBrowserify.join(dir, currentFilepath));
          if (parallel) {
            const promises2 = children.map(
              (child) => addToIndex({
                dir,
                gitdir,
                fs,
                filepath: [pathBrowserify.join(currentFilepath, child)],
                index: index3,
                force,
                parallel,
                autocrlf
              })
            );
            await Promise.all(promises2);
          } else {
            for (const child of children) {
              await addToIndex({
                dir,
                gitdir,
                fs,
                filepath: [pathBrowserify.join(currentFilepath, child)],
                index: index3,
                force,
                parallel,
                autocrlf
              });
            }
          }
        } else {
          const object = stats.isSymbolicLink() ? await fs.readlink(pathBrowserify.join(dir, currentFilepath)).then(posixifyPathBuffer) : await fs.read(pathBrowserify.join(dir, currentFilepath), { autocrlf });
          if (object === null) throw new NotFoundError(currentFilepath);
          const oid = await _writeObject({ fs, gitdir, type: "blob", object });
          index3.insert({ filepath: currentFilepath, stats, oid });
        }
      });
      const settledPromises = await Promise.allSettled(promises);
      const rejectedPromises = settledPromises.filter((settle) => settle.status === "rejected").map((settle) => settle.reason);
      if (rejectedPromises.length > 1) {
        throw new MultipleGitError(rejectedPromises);
      }
      if (rejectedPromises.length === 1) {
        throw rejectedPromises[0];
      }
      const fulfilledPromises = settledPromises.filter((settle) => settle.status === "fulfilled" && settle.value).map((settle) => settle.value);
      return fulfilledPromises;
    }
    __name(addToIndex, "addToIndex");
    async function _getConfig({ fs, gitdir, path: path6 }) {
      const config = await GitConfigManager.get({ fs, gitdir });
      return config.get(path6);
    }
    __name(_getConfig, "_getConfig");
    function assignDefined(target, ...sources) {
      for (const source of sources) {
        if (source) {
          for (const key of Object.keys(source)) {
            const val = source[key];
            if (val !== void 0) {
              target[key] = val;
            }
          }
        }
      }
      return target;
    }
    __name(assignDefined, "assignDefined");
    async function normalizeAuthorObject({ fs, gitdir, author, commit: commit2 }) {
      const timestamp = Math.floor(Date.now() / 1e3);
      const defaultAuthor = {
        name: await _getConfig({ fs, gitdir, path: "user.name" }),
        email: await _getConfig({ fs, gitdir, path: "user.email" }) || "",
        // author.email is allowed to be empty string
        timestamp,
        timezoneOffset: new Date(timestamp * 1e3).getTimezoneOffset()
      };
      const normalizedAuthor = assignDefined(
        {},
        defaultAuthor,
        commit2 ? commit2.author : void 0,
        author
      );
      if (normalizedAuthor.name === void 0) {
        return void 0;
      }
      return normalizedAuthor;
    }
    __name(normalizeAuthorObject, "normalizeAuthorObject");
    async function normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer,
      commit: commit2
    }) {
      const timestamp = Math.floor(Date.now() / 1e3);
      const defaultCommitter = {
        name: await _getConfig({ fs, gitdir, path: "user.name" }),
        email: await _getConfig({ fs, gitdir, path: "user.email" }) || "",
        // committer.email is allowed to be empty string
        timestamp,
        timezoneOffset: new Date(timestamp * 1e3).getTimezoneOffset()
      };
      const normalizedCommitter = assignDefined(
        {},
        defaultCommitter,
        commit2 ? commit2.committer : void 0,
        author,
        committer
      );
      if (normalizedCommitter.name === void 0) {
        return void 0;
      }
      return normalizedCommitter;
    }
    __name(normalizeCommitterObject, "normalizeCommitterObject");
    async function resolveCommit({ fs, cache, gitdir, oid }) {
      const { type, object } = await _readObject({ fs, cache, gitdir, oid });
      if (type === "tag") {
        oid = GitAnnotatedTag.from(object).parse().object;
        return resolveCommit({ fs, cache, gitdir, oid });
      }
      if (type !== "commit") {
        throw new ObjectTypeError(oid, type, "commit");
      }
      return { commit: GitCommit.from(object), oid };
    }
    __name(resolveCommit, "resolveCommit");
    async function _readCommit({ fs, cache, gitdir, oid }) {
      const { commit: commit2, oid: commitOid } = await resolveCommit({
        fs,
        cache,
        gitdir,
        oid
      });
      const result = {
        oid: commitOid,
        commit: commit2.parse(),
        payload: commit2.withoutSignature()
      };
      return result;
    }
    __name(_readCommit, "_readCommit");
    async function _commit({
      fs,
      cache,
      onSign,
      gitdir,
      message,
      author: _author,
      committer: _committer,
      signingKey,
      amend = false,
      dryRun = false,
      noUpdateBranch = false,
      ref,
      parent,
      tree
    }) {
      let initialCommit = false;
      if (!ref) {
        ref = await GitRefManager.resolve({
          fs,
          gitdir,
          ref: "HEAD",
          depth: 2
        });
      }
      let refOid, refCommit;
      try {
        refOid = await GitRefManager.resolve({
          fs,
          gitdir,
          ref
        });
        refCommit = await _readCommit({ fs, gitdir, oid: refOid, cache: {} });
      } catch {
        initialCommit = true;
      }
      if (amend && initialCommit) {
        throw new NoCommitError(ref);
      }
      const author = !amend ? await normalizeAuthorObject({ fs, gitdir, author: _author }) : await normalizeAuthorObject({
        fs,
        gitdir,
        author: _author,
        commit: refCommit.commit
      });
      if (!author) throw new MissingNameError("author");
      const committer = !amend ? await normalizeCommitterObject({
        fs,
        gitdir,
        author,
        committer: _committer
      }) : await normalizeCommitterObject({
        fs,
        gitdir,
        author,
        committer: _committer,
        commit: refCommit.commit
      });
      if (!committer) throw new MissingNameError("committer");
      return GitIndexManager.acquire(
        { fs, gitdir, cache, allowUnmerged: false },
        async function(index3) {
          const inodes = flatFileListToDirectoryStructure(index3.entries);
          const inode = inodes.get(".");
          if (!tree) {
            tree = await constructTree({ fs, gitdir, inode, dryRun });
          }
          if (!parent) {
            if (!amend) {
              parent = refOid ? [refOid] : [];
            } else {
              parent = refCommit.commit.parent;
            }
          } else {
            parent = await Promise.all(
              parent.map((p) => {
                return GitRefManager.resolve({ fs, gitdir, ref: p });
              })
            );
          }
          if (!message) {
            if (!amend) {
              throw new MissingParameterError("message");
            } else {
              message = refCommit.commit.message;
            }
          }
          let comm = GitCommit.from({
            tree,
            parent,
            author,
            committer,
            message
          });
          if (signingKey) {
            comm = await GitCommit.sign(comm, onSign, signingKey);
          }
          const oid = await _writeObject({
            fs,
            gitdir,
            type: "commit",
            object: comm.toObject(),
            dryRun
          });
          if (!noUpdateBranch && !dryRun) {
            await GitRefManager.writeRef({
              fs,
              gitdir,
              ref,
              value: oid
            });
          }
          return oid;
        }
      );
    }
    __name(_commit, "_commit");
    async function constructTree({ fs, gitdir, inode, dryRun }) {
      const children = inode.children;
      for (const inode2 of children) {
        if (inode2.type === "tree") {
          inode2.metadata.mode = "040000";
          inode2.metadata.oid = await constructTree({ fs, gitdir, inode: inode2, dryRun });
        }
      }
      const entries = children.map((inode2) => ({
        mode: inode2.metadata.mode,
        path: inode2.basename,
        oid: inode2.metadata.oid,
        type: inode2.type
      }));
      const tree = GitTree.from(entries);
      const oid = await _writeObject({
        fs,
        gitdir,
        type: "tree",
        object: tree.toObject(),
        dryRun
      });
      return oid;
    }
    __name(constructTree, "constructTree");
    async function resolveFilepath({ fs, cache, gitdir, oid, filepath }) {
      if (filepath.startsWith("/")) {
        throw new InvalidFilepathError("leading-slash");
      } else if (filepath.endsWith("/")) {
        throw new InvalidFilepathError("trailing-slash");
      }
      const _oid = oid;
      const result = await resolveTree({ fs, cache, gitdir, oid });
      const tree = result.tree;
      if (filepath === "") {
        oid = result.oid;
      } else {
        const pathArray = filepath.split("/");
        oid = await _resolveFilepath({
          fs,
          cache,
          gitdir,
          tree,
          pathArray,
          oid: _oid,
          filepath
        });
      }
      return oid;
    }
    __name(resolveFilepath, "resolveFilepath");
    async function _resolveFilepath({
      fs,
      cache,
      gitdir,
      tree,
      pathArray,
      oid,
      filepath
    }) {
      const name = pathArray.shift();
      for (const entry of tree) {
        if (entry.path === name) {
          if (pathArray.length === 0) {
            return entry.oid;
          } else {
            const { type, object } = await _readObject({
              fs,
              cache,
              gitdir,
              oid: entry.oid
            });
            if (type !== "tree") {
              throw new ObjectTypeError(oid, type, "tree", filepath);
            }
            tree = GitTree.from(object);
            return _resolveFilepath({
              fs,
              cache,
              gitdir,
              tree,
              pathArray,
              oid,
              filepath
            });
          }
        }
      }
      throw new NotFoundError(`file or directory found at "${oid}:${filepath}"`);
    }
    __name(_resolveFilepath, "_resolveFilepath");
    async function _readTree({
      fs,
      cache,
      gitdir,
      oid,
      filepath = void 0
    }) {
      if (filepath !== void 0) {
        oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
      }
      const { tree, oid: treeOid } = await resolveTree({ fs, cache, gitdir, oid });
      const result = {
        oid: treeOid,
        tree: tree.entries()
      };
      return result;
    }
    __name(_readTree, "_readTree");
    async function _writeTree({ fs, gitdir, tree }) {
      const object = GitTree.from(tree).toObject();
      const oid = await _writeObject({
        fs,
        gitdir,
        type: "tree",
        object,
        format: "content"
      });
      return oid;
    }
    __name(_writeTree, "_writeTree");
    async function _addNote({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      note,
      force,
      author,
      committer,
      signingKey
    }) {
      let parent;
      try {
        parent = await GitRefManager.resolve({ gitdir, fs, ref });
      } catch (err) {
        if (!(err instanceof NotFoundError)) {
          throw err;
        }
      }
      const result = await _readTree({
        fs,
        cache,
        gitdir,
        oid: parent || "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
      });
      let tree = result.tree;
      if (force) {
        tree = tree.filter((entry) => entry.path !== oid);
      } else {
        for (const entry of tree) {
          if (entry.path === oid) {
            throw new AlreadyExistsError("note", oid);
          }
        }
      }
      if (typeof note === "string") {
        note = Buffer.from(note, "utf8");
      }
      const noteOid = await _writeObject({
        fs,
        gitdir,
        type: "blob",
        object: note,
        format: "content"
      });
      tree.push({ mode: "100644", path: oid, oid: noteOid, type: "blob" });
      const treeOid = await _writeTree({
        fs,
        gitdir,
        tree
      });
      const commitOid = await _commit({
        fs,
        cache,
        onSign,
        gitdir,
        ref,
        tree: treeOid,
        parent: parent && [parent],
        message: `Note added by 'isomorphic-git addNote'
`,
        author,
        committer,
        signingKey
      });
      return commitOid;
    }
    __name(_addNote, "_addNote");
    async function addNote({
      fs: _fs,
      onSign,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref = "refs/notes/commits",
      oid,
      note,
      force,
      author: _author,
      committer: _committer,
      signingKey,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        assertParameter("note", note);
        if (signingKey) {
          assertParameter("onSign", onSign);
        }
        const fs = new FileSystem(_fs);
        const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
        if (!author) throw new MissingNameError("author");
        const committer = await normalizeCommitterObject({
          fs,
          gitdir,
          author,
          committer: _committer
        });
        if (!committer) throw new MissingNameError("committer");
        return await _addNote({
          fs: new FileSystem(fs),
          cache,
          onSign,
          gitdir,
          ref,
          oid,
          note,
          force,
          author,
          committer,
          signingKey
        });
      } catch (err) {
        err.caller = "git.addNote";
        throw err;
      }
    }
    __name(addNote, "addNote");
    async function _addRemote({ fs, gitdir, remote, url, force }) {
      if (!validRef(remote, true)) {
        throw new InvalidRefNameError(remote, cleanGitRef.clean(remote));
      }
      const config = await GitConfigManager.get({ fs, gitdir });
      if (!force) {
        const remoteNames = await config.getSubsections("remote");
        if (remoteNames.includes(remote)) {
          if (url !== await config.get(`remote.${remote}.url`)) {
            throw new AlreadyExistsError("remote", remote);
          }
        }
      }
      await config.set(`remote.${remote}.url`, url);
      await config.set(
        `remote.${remote}.fetch`,
        `+refs/heads/*:refs/remotes/${remote}/*`
      );
      await GitConfigManager.save({ fs, gitdir, config });
    }
    __name(_addRemote, "_addRemote");
    async function addRemote({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      remote,
      url,
      force = false
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("remote", remote);
        assertParameter("url", url);
        return await _addRemote({
          fs: new FileSystem(fs),
          gitdir,
          remote,
          url,
          force
        });
      } catch (err) {
        err.caller = "git.addRemote";
        throw err;
      }
    }
    __name(addRemote, "addRemote");
    async function _annotatedTag({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      tagger,
      message = ref,
      gpgsig,
      object,
      signingKey,
      force = false
    }) {
      ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
      if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
        throw new AlreadyExistsError("tag", ref);
      }
      const oid = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: object || "HEAD"
      });
      const { type } = await _readObject({ fs, cache, gitdir, oid });
      let tagObject = GitAnnotatedTag.from({
        object: oid,
        type,
        tag: ref.replace("refs/tags/", ""),
        tagger,
        message,
        gpgsig
      });
      if (signingKey) {
        tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);
      }
      const value = await _writeObject({
        fs,
        gitdir,
        type: "tag",
        object: tagObject.toObject()
      });
      await GitRefManager.writeRef({ fs, gitdir, ref, value });
    }
    __name(_annotatedTag, "_annotatedTag");
    async function annotatedTag({
      fs: _fs,
      onSign,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      tagger: _tagger,
      message = ref,
      gpgsig,
      object,
      signingKey,
      force = false,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        if (signingKey) {
          assertParameter("onSign", onSign);
        }
        const fs = new FileSystem(_fs);
        const tagger = await normalizeAuthorObject({ fs, gitdir, author: _tagger });
        if (!tagger) throw new MissingNameError("tagger");
        return await _annotatedTag({
          fs,
          cache,
          onSign,
          gitdir,
          ref,
          tagger,
          message,
          gpgsig,
          object,
          signingKey,
          force
        });
      } catch (err) {
        err.caller = "git.annotatedTag";
        throw err;
      }
    }
    __name(annotatedTag, "annotatedTag");
    async function _branch({
      fs,
      gitdir,
      ref,
      object,
      checkout: checkout2 = false,
      force = false
    }) {
      if (!validRef(ref, true)) {
        throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));
      }
      const fullref = `refs/heads/${ref}`;
      if (!force) {
        const exist = await GitRefManager.exists({ fs, gitdir, ref: fullref });
        if (exist) {
          throw new AlreadyExistsError("branch", ref, false);
        }
      }
      let oid;
      try {
        oid = await GitRefManager.resolve({ fs, gitdir, ref: object || "HEAD" });
      } catch (e) {
      }
      if (oid) {
        await GitRefManager.writeRef({ fs, gitdir, ref: fullref, value: oid });
      }
      if (checkout2) {
        await GitRefManager.writeSymbolicRef({
          fs,
          gitdir,
          ref: "HEAD",
          value: fullref
        });
      }
    }
    __name(_branch, "_branch");
    async function branch({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      object,
      checkout: checkout2 = false,
      force = false
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        return await _branch({
          fs: new FileSystem(fs),
          gitdir,
          ref,
          object,
          checkout: checkout2,
          force
        });
      } catch (err) {
        err.caller = "git.branch";
        throw err;
      }
    }
    __name(branch, "branch");
    var worthWalking = /* @__PURE__ */ __name((filepath, root) => {
      if (filepath === "." || root == null || root.length === 0 || root === ".") {
        return true;
      }
      if (root.length >= filepath.length) {
        return root.startsWith(filepath);
      } else {
        return filepath.startsWith(root);
      }
    }, "worthWalking");
    async function _checkout({
      fs,
      cache,
      onProgress,
      onPostCheckout,
      dir,
      gitdir,
      remote,
      ref,
      filepaths,
      noCheckout,
      noUpdateHead,
      dryRun,
      force,
      track = true,
      nonBlocking = false,
      batchSize = 100
    }) {
      let oldOid;
      if (onPostCheckout) {
        try {
          oldOid = await GitRefManager.resolve({ fs, gitdir, ref: "HEAD" });
        } catch (err) {
          oldOid = "0000000000000000000000000000000000000000";
        }
      }
      let oid;
      try {
        oid = await GitRefManager.resolve({ fs, gitdir, ref });
      } catch (err) {
        if (ref === "HEAD") throw err;
        const remoteRef = `${remote}/${ref}`;
        oid = await GitRefManager.resolve({
          fs,
          gitdir,
          ref: remoteRef
        });
        if (track) {
          const config = await GitConfigManager.get({ fs, gitdir });
          await config.set(`branch.${ref}.remote`, remote);
          await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);
          await GitConfigManager.save({ fs, gitdir, config });
        }
        await GitRefManager.writeRef({
          fs,
          gitdir,
          ref: `refs/heads/${ref}`,
          value: oid
        });
      }
      if (!noCheckout) {
        let ops;
        try {
          ops = await analyze({
            fs,
            cache,
            onProgress,
            dir,
            gitdir,
            ref,
            force,
            filepaths
          });
        } catch (err) {
          if (err instanceof NotFoundError && err.data.what === oid) {
            throw new CommitNotFetchedError(ref, oid);
          } else {
            throw err;
          }
        }
        const conflicts = ops.filter(([method]) => method === "conflict").map(([method, fullpath]) => fullpath);
        if (conflicts.length > 0) {
          throw new CheckoutConflictError(conflicts);
        }
        const errors = ops.filter(([method]) => method === "error").map(([method, fullpath]) => fullpath);
        if (errors.length > 0) {
          throw new InternalError(errors.join(", "));
        }
        if (dryRun) {
          if (onPostCheckout) {
            await onPostCheckout({
              previousHead: oldOid,
              newHead: oid,
              type: filepaths != null && filepaths.length > 0 ? "file" : "branch"
            });
          }
          return;
        }
        let count = 0;
        const total = ops.length;
        await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index3) {
          await Promise.all(
            ops.filter(
              ([method]) => method === "delete" || method === "delete-index"
            ).map(async function([method, fullpath]) {
              const filepath = `${dir}/${fullpath}`;
              if (method === "delete") {
                await fs.rm(filepath);
              }
              index3.delete({ filepath: fullpath });
              if (onProgress) {
                await onProgress({
                  phase: "Updating workdir",
                  loaded: ++count,
                  total
                });
              }
            })
          );
        });
        await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index3) {
          for (const [method, fullpath] of ops) {
            if (method === "rmdir" || method === "rmdir-index") {
              const filepath = `${dir}/${fullpath}`;
              try {
                if (method === "rmdir") {
                  await fs.rmdir(filepath);
                }
                index3.delete({ filepath: fullpath });
                if (onProgress) {
                  await onProgress({
                    phase: "Updating workdir",
                    loaded: ++count,
                    total
                  });
                }
              } catch (e) {
                if (e.code === "ENOTEMPTY") {
                  console.log(
                    `Did not delete ${fullpath} because directory is not empty`
                  );
                } else {
                  throw e;
                }
              }
            }
          }
        });
        await Promise.all(
          ops.filter(([method]) => method === "mkdir" || method === "mkdir-index").map(async function([_, fullpath]) {
            const filepath = `${dir}/${fullpath}`;
            await fs.mkdir(filepath);
            if (onProgress) {
              await onProgress({
                phase: "Updating workdir",
                loaded: ++count,
                total
              });
            }
          })
        );
        if (nonBlocking) {
          const eligibleOps = ops.filter(
            ([method]) => method === "create" || method === "create-index" || method === "update" || method === "mkdir-index"
          );
          const updateWorkingDirResults = await batchAllSettled(
            "Update Working Dir",
            eligibleOps.map(
              ([method, fullpath, oid2, mode, chmod]) => () => updateWorkingDir({ fs, cache, gitdir, dir }, [
                method,
                fullpath,
                oid2,
                mode,
                chmod
              ])
            ),
            onProgress,
            batchSize
          );
          await GitIndexManager.acquire(
            { fs, gitdir, cache, allowUnmerged: true },
            async function(index3) {
              await batchAllSettled(
                "Update Index",
                updateWorkingDirResults.map(
                  ([fullpath, oid2, stats]) => () => updateIndex({ index: index3, fullpath, oid: oid2, stats })
                ),
                onProgress,
                batchSize
              );
            }
          );
        } else {
          await GitIndexManager.acquire(
            { fs, gitdir, cache, allowUnmerged: true },
            async function(index3) {
              await Promise.all(
                ops.filter(
                  ([method]) => method === "create" || method === "create-index" || method === "update" || method === "mkdir-index"
                ).map(async function([method, fullpath, oid2, mode, chmod]) {
                  const filepath = `${dir}/${fullpath}`;
                  try {
                    if (method !== "create-index" && method !== "mkdir-index") {
                      const { object } = await _readObject({
                        fs,
                        cache,
                        gitdir,
                        oid: oid2
                      });
                      if (chmod) {
                        await fs.rm(filepath);
                      }
                      if (mode === 33188) {
                        await fs.write(filepath, object);
                      } else if (mode === 33261) {
                        await fs.write(filepath, object, { mode: 511 });
                      } else if (mode === 40960) {
                        await fs.writelink(filepath, object);
                      } else {
                        throw new InternalError(
                          `Invalid mode 0o${mode.toString(
                            8
                          )} detected in blob ${oid2}`
                        );
                      }
                    }
                    const stats = await fs.lstat(filepath);
                    if (mode === 33261) {
                      stats.mode = 493;
                    }
                    if (method === "mkdir-index") {
                      stats.mode = 57344;
                    }
                    index3.insert({
                      filepath: fullpath,
                      stats,
                      oid: oid2
                    });
                    if (onProgress) {
                      await onProgress({
                        phase: "Updating workdir",
                        loaded: ++count,
                        total
                      });
                    }
                  } catch (e) {
                    console.log(e);
                  }
                })
              );
            }
          );
        }
        if (onPostCheckout) {
          await onPostCheckout({
            previousHead: oldOid,
            newHead: oid,
            type: filepaths != null && filepaths.length > 0 ? "file" : "branch"
          });
        }
      }
      if (!noUpdateHead) {
        const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
        if (fullRef.startsWith("refs/heads")) {
          await GitRefManager.writeSymbolicRef({
            fs,
            gitdir,
            ref: "HEAD",
            value: fullRef
          });
        } else {
          await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value: oid });
        }
      }
    }
    __name(_checkout, "_checkout");
    async function analyze({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      force,
      filepaths
    }) {
      let count = 0;
      return _walk({
        fs,
        cache,
        dir,
        gitdir,
        trees: [TREE({ ref }), WORKDIR(), STAGE()],
        map: /* @__PURE__ */ __name(async function(fullpath, [commit2, workdir, stage]) {
          if (fullpath === ".") return;
          if (filepaths && !filepaths.some((base) => worthWalking(fullpath, base))) {
            return null;
          }
          if (onProgress) {
            await onProgress({ phase: "Analyzing workdir", loaded: ++count });
          }
          const key = [!!stage, !!commit2, !!workdir].map(Number).join("");
          switch (key) {
            // Impossible case.
            case "000":
              return;
            // Ignore workdir files that are not tracked and not part of the new commit.
            case "001":
              if (force && filepaths && filepaths.includes(fullpath)) {
                return ["delete", fullpath];
              }
              return;
            // New entries
            case "010": {
              switch (await commit2.type()) {
                case "tree": {
                  return ["mkdir", fullpath];
                }
                case "blob": {
                  return [
                    "create",
                    fullpath,
                    await commit2.oid(),
                    await commit2.mode()
                  ];
                }
                case "commit": {
                  return [
                    "mkdir-index",
                    fullpath,
                    await commit2.oid(),
                    await commit2.mode()
                  ];
                }
                default: {
                  return [
                    "error",
                    `new entry Unhandled type ${await commit2.type()}`
                  ];
                }
              }
            }
            // New entries but there is already something in the workdir there.
            case "011": {
              switch (`${await commit2.type()}-${await workdir.type()}`) {
                case "tree-tree": {
                  return;
                }
                case "tree-blob":
                case "blob-tree": {
                  return ["conflict", fullpath];
                }
                case "blob-blob": {
                  if (await commit2.oid() !== await workdir.oid()) {
                    if (force) {
                      return [
                        "update",
                        fullpath,
                        await commit2.oid(),
                        await commit2.mode(),
                        await commit2.mode() !== await workdir.mode()
                      ];
                    } else {
                      return ["conflict", fullpath];
                    }
                  } else {
                    if (await commit2.mode() !== await workdir.mode()) {
                      if (force) {
                        return [
                          "update",
                          fullpath,
                          await commit2.oid(),
                          await commit2.mode(),
                          true
                        ];
                      } else {
                        return ["conflict", fullpath];
                      }
                    } else {
                      return [
                        "create-index",
                        fullpath,
                        await commit2.oid(),
                        await commit2.mode()
                      ];
                    }
                  }
                }
                case "commit-tree": {
                  return;
                }
                case "commit-blob": {
                  return ["conflict", fullpath];
                }
                default: {
                  return ["error", `new entry Unhandled type ${commit2.type}`];
                }
              }
            }
            // Something in stage but not in the commit OR the workdir.
            // Note: I verified this behavior against canonical git.
            case "100": {
              return ["delete-index", fullpath];
            }
            // Deleted entries
            // TODO: How to handle if stage type and workdir type mismatch?
            case "101": {
              switch (await stage.type()) {
                case "tree": {
                  return ["rmdir-index", fullpath];
                }
                case "blob": {
                  if (await stage.oid() !== await workdir.oid()) {
                    if (force) {
                      return ["delete", fullpath];
                    } else {
                      return ["conflict", fullpath];
                    }
                  } else {
                    return ["delete", fullpath];
                  }
                }
                case "commit": {
                  return ["rmdir-index", fullpath];
                }
                default: {
                  return [
                    "error",
                    `delete entry Unhandled type ${await stage.type()}`
                  ];
                }
              }
            }
            /* eslint-disable no-fallthrough */
            // File missing from workdir
            case "110":
            // Possibly modified entries
            case "111": {
              switch (`${await stage.type()}-${await commit2.type()}`) {
                case "tree-tree": {
                  return;
                }
                case "blob-blob": {
                  if (await stage.oid() === await commit2.oid() && await stage.mode() === await commit2.mode() && !force) {
                    return;
                  }
                  if (workdir) {
                    if (await workdir.oid() !== await stage.oid() && await workdir.oid() !== await commit2.oid()) {
                      if (force) {
                        return [
                          "update",
                          fullpath,
                          await commit2.oid(),
                          await commit2.mode(),
                          await commit2.mode() !== await workdir.mode()
                        ];
                      } else {
                        return ["conflict", fullpath];
                      }
                    }
                  } else if (force) {
                    return [
                      "update",
                      fullpath,
                      await commit2.oid(),
                      await commit2.mode(),
                      await commit2.mode() !== await stage.mode()
                    ];
                  }
                  if (await commit2.mode() !== await stage.mode()) {
                    return [
                      "update",
                      fullpath,
                      await commit2.oid(),
                      await commit2.mode(),
                      true
                    ];
                  }
                  if (await commit2.oid() !== await stage.oid()) {
                    return [
                      "update",
                      fullpath,
                      await commit2.oid(),
                      await commit2.mode(),
                      false
                    ];
                  } else {
                    return;
                  }
                }
                case "tree-blob": {
                  return ["update-dir-to-blob", fullpath, await commit2.oid()];
                }
                case "blob-tree": {
                  return ["update-blob-to-tree", fullpath];
                }
                case "commit-commit": {
                  return [
                    "mkdir-index",
                    fullpath,
                    await commit2.oid(),
                    await commit2.mode()
                  ];
                }
                default: {
                  return [
                    "error",
                    `update entry Unhandled type ${await stage.type()}-${await commit2.type()}`
                  ];
                }
              }
            }
          }
        }, "map"),
        // Modify the default flat mapping
        reduce: /* @__PURE__ */ __name(async function(parent, children) {
          children = flat(children);
          if (!parent) {
            return children;
          } else if (parent && parent[0] === "rmdir") {
            children.push(parent);
            return children;
          } else {
            children.unshift(parent);
            return children;
          }
        }, "reduce")
      });
    }
    __name(analyze, "analyze");
    async function updateIndex({ index: index3, fullpath, stats, oid }) {
      try {
        index3.insert({
          filepath: fullpath,
          stats,
          oid
        });
      } catch (e) {
        console.warn(`Error inserting ${fullpath} into index:`, e);
      }
    }
    __name(updateIndex, "updateIndex");
    async function updateWorkingDir({ fs, cache, gitdir, dir }, [method, fullpath, oid, mode, chmod]) {
      const filepath = `${dir}/${fullpath}`;
      if (method !== "create-index" && method !== "mkdir-index") {
        const { object } = await _readObject({ fs, cache, gitdir, oid });
        if (chmod) {
          await fs.rm(filepath);
        }
        if (mode === 33188) {
          await fs.write(filepath, object);
        } else if (mode === 33261) {
          await fs.write(filepath, object, { mode: 511 });
        } else if (mode === 40960) {
          await fs.writelink(filepath, object);
        } else {
          throw new InternalError(
            `Invalid mode 0o${mode.toString(8)} detected in blob ${oid}`
          );
        }
      }
      const stats = await fs.lstat(filepath);
      if (mode === 33261) {
        stats.mode = 493;
      }
      if (method === "mkdir-index") {
        stats.mode = 57344;
      }
      return [fullpath, oid, stats];
    }
    __name(updateWorkingDir, "updateWorkingDir");
    async function batchAllSettled(operationName, tasks, onProgress, batchSize) {
      const results = [];
      try {
        for (let i = 0; i < tasks.length; i += batchSize) {
          const batch = tasks.slice(i, i + batchSize).map((task) => task());
          const batchResults = await Promise.allSettled(batch);
          batchResults.forEach((result) => {
            if (result.status === "fulfilled") results.push(result.value);
          });
          if (onProgress) {
            await onProgress({
              phase: "Updating workdir",
              loaded: i + batch.length,
              total: tasks.length
            });
          }
        }
        return results;
      } catch (error) {
        console.error(`Error during ${operationName}: ${error}`);
      }
      return results;
    }
    __name(batchAllSettled, "batchAllSettled");
    async function checkout({
      fs,
      onProgress,
      onPostCheckout,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      remote = "origin",
      ref: _ref,
      filepaths,
      noCheckout = false,
      noUpdateHead = _ref === void 0,
      dryRun = false,
      force = false,
      track = true,
      cache = {},
      nonBlocking = false,
      batchSize = 100
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("dir", dir);
        assertParameter("gitdir", gitdir);
        const ref = _ref || "HEAD";
        return await _checkout({
          fs: new FileSystem(fs),
          cache,
          onProgress,
          onPostCheckout,
          dir,
          gitdir,
          remote,
          ref,
          filepaths,
          noCheckout,
          noUpdateHead,
          dryRun,
          force,
          track,
          nonBlocking,
          batchSize
        });
      } catch (err) {
        err.caller = "git.checkout";
        throw err;
      }
    }
    __name(checkout, "checkout");
    var abbreviateRx = new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");
    function abbreviateRef(ref) {
      const match = abbreviateRx.exec(ref);
      if (match) {
        if (match[1] === "remotes/" && ref.endsWith("/HEAD")) {
          return match[2].slice(0, -5);
        } else {
          return match[2];
        }
      }
      return ref;
    }
    __name(abbreviateRef, "abbreviateRef");
    async function _currentBranch({
      fs,
      gitdir,
      fullname = false,
      test = false
    }) {
      const ref = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: "HEAD",
        depth: 2
      });
      if (test) {
        try {
          await GitRefManager.resolve({ fs, gitdir, ref });
        } catch (_) {
          return;
        }
      }
      if (!ref.startsWith("refs/")) return;
      return fullname ? ref : abbreviateRef(ref);
    }
    __name(_currentBranch, "_currentBranch");
    function translateSSHtoHTTP(url) {
      url = url.replace(/^git@([^:]+):/, "https://$1/");
      url = url.replace(/^ssh:\/\//, "https://");
      return url;
    }
    __name(translateSSHtoHTTP, "translateSSHtoHTTP");
    function calculateBasicAuthHeader({ username = "", password = "" }) {
      return `Basic ${Buffer.from(`${username}:${password}`).toString("base64")}`;
    }
    __name(calculateBasicAuthHeader, "calculateBasicAuthHeader");
    async function forAwait2(iterable, cb) {
      const iter = getIterator2(iterable);
      while (true) {
        const { value, done } = await iter.next();
        if (value) await cb(value);
        if (done) break;
      }
      if (iter.return) iter.return();
    }
    __name(forAwait2, "forAwait");
    async function collect2(iterable) {
      let size = 0;
      const buffers = [];
      await forAwait2(iterable, (value) => {
        buffers.push(value);
        size += value.byteLength;
      });
      const result = new Uint8Array(size);
      let nextIndex = 0;
      for (const buffer of buffers) {
        result.set(buffer, nextIndex);
        nextIndex += buffer.byteLength;
      }
      return result;
    }
    __name(collect2, "collect");
    function extractAuthFromUrl(url) {
      let userpass = url.match(/^https?:\/\/([^/]+)@/);
      if (userpass == null) return { url, auth: {} };
      userpass = userpass[1];
      const [username, password] = userpass.split(":");
      url = url.replace(`${userpass}@`, "");
      return { url, auth: { username, password } };
    }
    __name(extractAuthFromUrl, "extractAuthFromUrl");
    function padHex(b, n) {
      const s = n.toString(16);
      return "0".repeat(b - s.length) + s;
    }
    __name(padHex, "padHex");
    var _GitPktLine = class _GitPktLine {
      static flush() {
        return Buffer.from("0000", "utf8");
      }
      static delim() {
        return Buffer.from("0001", "utf8");
      }
      static encode(line) {
        if (typeof line === "string") {
          line = Buffer.from(line);
        }
        const length = line.length + 4;
        const hexlength = padHex(4, length);
        return Buffer.concat([Buffer.from(hexlength, "utf8"), line]);
      }
      static streamReader(stream) {
        const reader = new StreamReader(stream);
        return /* @__PURE__ */ __name(async function read() {
          try {
            let length = await reader.read(4);
            if (length == null) return true;
            length = parseInt(length.toString("utf8"), 16);
            if (length === 0) return null;
            if (length === 1) return null;
            const buffer = await reader.read(length - 4);
            if (buffer == null) return true;
            return buffer;
          } catch (err) {
            stream.error = err;
            return true;
          }
        }, "read");
      }
    };
    __name(_GitPktLine, "GitPktLine");
    var GitPktLine = _GitPktLine;
    async function parseCapabilitiesV2(read) {
      const capabilities2 = {};
      let line;
      while (true) {
        line = await read();
        if (line === true) break;
        if (line === null) continue;
        line = line.toString("utf8").replace(/\n$/, "");
        const i = line.indexOf("=");
        if (i > -1) {
          const key = line.slice(0, i);
          const value = line.slice(i + 1);
          capabilities2[key] = value;
        } else {
          capabilities2[line] = true;
        }
      }
      return { protocolVersion: 2, capabilities2 };
    }
    __name(parseCapabilitiesV2, "parseCapabilitiesV2");
    async function parseRefsAdResponse(stream, { service }) {
      const capabilities = /* @__PURE__ */ new Set();
      const refs = /* @__PURE__ */ new Map();
      const symrefs = /* @__PURE__ */ new Map();
      const read = GitPktLine.streamReader(stream);
      let lineOne = await read();
      while (lineOne === null) lineOne = await read();
      if (lineOne === true) throw new EmptyServerResponseError();
      if (lineOne.includes("version 2")) {
        return parseCapabilitiesV2(read);
      }
      if (lineOne.toString("utf8").replace(/\n$/, "") !== `# service=${service}`) {
        throw new ParseError(`# service=${service}\\n`, lineOne.toString("utf8"));
      }
      let lineTwo = await read();
      while (lineTwo === null) lineTwo = await read();
      if (lineTwo === true) return { capabilities, refs, symrefs };
      lineTwo = lineTwo.toString("utf8");
      if (lineTwo.includes("version 2")) {
        return parseCapabilitiesV2(read);
      }
      const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, "\0", "\\x00");
      capabilitiesLine.split(" ").map((x) => capabilities.add(x));
      if (firstRef !== "0000000000000000000000000000000000000000 capabilities^{}") {
        const [ref, name] = splitAndAssert(firstRef, " ", " ");
        refs.set(name, ref);
        while (true) {
          const line = await read();
          if (line === true) break;
          if (line !== null) {
            const [ref2, name2] = splitAndAssert(line.toString("utf8"), " ", " ");
            refs.set(name2, ref2);
          }
        }
      }
      for (const cap of capabilities) {
        if (cap.startsWith("symref=")) {
          const m = cap.match(/symref=([^:]+):(.*)/);
          if (m.length === 3) {
            symrefs.set(m[1], m[2]);
          }
        }
      }
      return { protocolVersion: 1, capabilities, refs, symrefs };
    }
    __name(parseRefsAdResponse, "parseRefsAdResponse");
    function splitAndAssert(line, sep, expected) {
      const split = line.trim().split(sep);
      if (split.length !== 2) {
        throw new ParseError(
          `Two strings separated by '${expected}'`,
          line.toString("utf8")
        );
      }
      return split;
    }
    __name(splitAndAssert, "splitAndAssert");
    var corsProxify = /* @__PURE__ */ __name((corsProxy, url) => corsProxy.endsWith("?") ? `${corsProxy}${url}` : `${corsProxy}/${url.replace(/^https?:\/\//, "")}`, "corsProxify");
    var updateHeaders = /* @__PURE__ */ __name((headers, auth) => {
      if (auth.username || auth.password) {
        headers.Authorization = calculateBasicAuthHeader(auth);
      }
      if (auth.headers) {
        Object.assign(headers, auth.headers);
      }
    }, "updateHeaders");
    var stringifyBody = /* @__PURE__ */ __name(async (res) => {
      try {
        const data = Buffer.from(await collect2(res.body));
        const response = data.toString("utf8");
        const preview = response.length < 256 ? response : response.slice(0, 256) + "...";
        return { preview, response, data };
      } catch (e) {
        return {};
      }
    }, "stringifyBody");
    var _GitRemoteHTTP = class _GitRemoteHTTP {
      /**
       * Returns the capabilities of the GitRemoteHTTP class.
       *
       * @returns {Promise<string[]>} - An array of supported capabilities.
       */
      static async capabilities() {
        return ["discover", "connect"];
      }
      /**
       * Discovers references from a remote Git repository.
       *
       * @param {Object} args
       * @param {HttpClient} args.http - The HTTP client to use for requests.
       * @param {ProgressCallback} [args.onProgress] - Callback for progress updates.
       * @param {AuthCallback} [args.onAuth] - Callback for providing authentication credentials.
       * @param {AuthFailureCallback} [args.onAuthFailure] - Callback for handling authentication failures.
       * @param {AuthSuccessCallback} [args.onAuthSuccess] - Callback for handling successful authentication.
       * @param {string} [args.corsProxy] - Optional CORS proxy URL.
       * @param {string} args.service - The Git service (e.g., "git-upload-pack").
       * @param {string} args.url - The URL of the remote repository.
       * @param {Object<string, string>} args.headers - HTTP headers to include in the request.
       * @param {1 | 2} args.protocolVersion - The Git protocol version to use.
       * @returns {Promise<Object>} - The parsed response from the remote repository.
       * @throws {HttpError} - If the HTTP request fails.
       * @throws {SmartHttpError} - If the response cannot be parsed.
       * @throws {UserCanceledError} - If the user cancels the operation.
       */
      static async discover({
        http,
        onProgress,
        onAuth,
        onAuthSuccess,
        onAuthFailure,
        corsProxy,
        service,
        url: _origUrl,
        headers,
        protocolVersion
      }) {
        let { url, auth } = extractAuthFromUrl(_origUrl);
        const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;
        if (auth.username || auth.password) {
          headers.Authorization = calculateBasicAuthHeader(auth);
        }
        if (protocolVersion === 2) {
          headers["Git-Protocol"] = "version=2";
        }
        let res;
        let tryAgain;
        let providedAuthBefore = false;
        do {
          res = await http.request({
            onProgress,
            method: "GET",
            url: `${proxifiedURL}/info/refs?service=${service}`,
            headers
          });
          tryAgain = false;
          if (res.statusCode === 401 || res.statusCode === 203) {
            const getAuth = providedAuthBefore ? onAuthFailure : onAuth;
            if (getAuth) {
              auth = await getAuth(url, {
                ...auth,
                headers: { ...headers }
              });
              if (auth && auth.cancel) {
                throw new UserCanceledError();
              } else if (auth) {
                updateHeaders(headers, auth);
                providedAuthBefore = true;
                tryAgain = true;
              }
            }
          } else if (res.statusCode === 200 && providedAuthBefore && onAuthSuccess) {
            await onAuthSuccess(url, auth);
          }
        } while (tryAgain);
        if (res.statusCode !== 200) {
          const { response } = await stringifyBody(res);
          throw new HttpError(res.statusCode, res.statusMessage, response);
        }
        if (res.headers["content-type"] === `application/x-${service}-advertisement`) {
          const remoteHTTP = await parseRefsAdResponse(res.body, { service });
          remoteHTTP.auth = auth;
          return remoteHTTP;
        } else {
          const { preview, response, data } = await stringifyBody(res);
          try {
            const remoteHTTP = await parseRefsAdResponse([data], { service });
            remoteHTTP.auth = auth;
            return remoteHTTP;
          } catch (e) {
            throw new SmartHttpError(preview, response);
          }
        }
      }
      /**
       * Connects to a remote Git repository and sends a request.
       *
       * @param {Object} args
       * @param {HttpClient} args.http - The HTTP client to use for requests.
       * @param {ProgressCallback} [args.onProgress] - Callback for progress updates.
       * @param {string} [args.corsProxy] - Optional CORS proxy URL.
       * @param {string} args.service - The Git service (e.g., "git-upload-pack").
       * @param {string} args.url - The URL of the remote repository.
       * @param {Object<string, string>} [args.headers] - HTTP headers to include in the request.
       * @param {any} args.body - The request body to send.
       * @param {any} args.auth - Authentication credentials.
       * @returns {Promise<GitHttpResponse>} - The HTTP response from the remote repository.
       * @throws {HttpError} - If the HTTP request fails.
       */
      static async connect({
        http,
        onProgress,
        corsProxy,
        service,
        url,
        auth,
        body,
        headers
      }) {
        const urlAuth = extractAuthFromUrl(url);
        if (urlAuth) url = urlAuth.url;
        if (corsProxy) url = corsProxify(corsProxy, url);
        headers["content-type"] = `application/x-${service}-request`;
        headers.accept = `application/x-${service}-result`;
        updateHeaders(headers, auth);
        const res = await http.request({
          onProgress,
          method: "POST",
          url: `${url}/${service}`,
          body,
          headers
        });
        if (res.statusCode !== 200) {
          const { response } = stringifyBody(res);
          throw new HttpError(res.statusCode, res.statusMessage, response);
        }
        return res;
      }
    };
    __name(_GitRemoteHTTP, "GitRemoteHTTP");
    var GitRemoteHTTP = _GitRemoteHTTP;
    var _GitRemoteManager = class _GitRemoteManager {
      /**
       * Determines the appropriate remote helper for the given URL.
       *
       * @param {Object} args
       * @param {string} args.url - The URL of the remote repository.
       * @returns {Object} - The remote helper class for the specified transport.
       * @throws {UrlParseError} - If the URL cannot be parsed.
       * @throws {UnknownTransportError} - If the transport is not supported.
       */
      static getRemoteHelperFor({ url }) {
        const remoteHelpers = /* @__PURE__ */ new Map();
        remoteHelpers.set("http", GitRemoteHTTP);
        remoteHelpers.set("https", GitRemoteHTTP);
        const parts = parseRemoteUrl({ url });
        if (!parts) {
          throw new UrlParseError(url);
        }
        if (remoteHelpers.has(parts.transport)) {
          return remoteHelpers.get(parts.transport);
        }
        throw new UnknownTransportError(
          url,
          parts.transport,
          parts.transport === "ssh" ? translateSSHtoHTTP(url) : void 0
        );
      }
    };
    __name(_GitRemoteManager, "GitRemoteManager");
    var GitRemoteManager = _GitRemoteManager;
    function parseRemoteUrl({ url }) {
      if (url.startsWith("git@")) {
        return {
          transport: "ssh",
          address: url
        };
      }
      const matches = url.match(/(\w+)(:\/\/|::)(.*)/);
      if (matches === null) return;
      if (matches[2] === "://") {
        return {
          transport: matches[1],
          address: matches[0]
        };
      }
      if (matches[2] === "::") {
        return {
          transport: matches[1],
          address: matches[3]
        };
      }
    }
    __name(parseRemoteUrl, "parseRemoteUrl");
    var lock$2 = null;
    var _GitShallowManager = class _GitShallowManager {
      /**
       * Reads the `shallow` file in the Git repository and returns a set of object IDs (OIDs).
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path
       * @returns {Promise<Set<string>>} - A set of shallow object IDs.
       */
      static async read({ fs, gitdir }) {
        if (lock$2 === null) lock$2 = new AsyncLock();
        const filepath = pathBrowserify.join(gitdir, "shallow");
        const oids = /* @__PURE__ */ new Set();
        await lock$2.acquire(filepath, async function() {
          const text = await fs.read(filepath, { encoding: "utf8" });
          if (text === null) return oids;
          if (text.trim() === "") return oids;
          text.trim().split("\n").map((oid) => oids.add(oid));
        });
        return oids;
      }
      /**
       * Writes a set of object IDs (OIDs) to the `shallow` file in the Git repository.
       * If the set is empty, the `shallow` file is removed.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path
       * @param {Set<string>} args.oids - A set of shallow object IDs to write.
       * @returns {Promise<void>}
       */
      static async write({ fs, gitdir, oids }) {
        if (lock$2 === null) lock$2 = new AsyncLock();
        const filepath = pathBrowserify.join(gitdir, "shallow");
        if (oids.size > 0) {
          const text = [...oids].join("\n") + "\n";
          await lock$2.acquire(filepath, async function() {
            await fs.write(filepath, text, {
              encoding: "utf8"
            });
          });
        } else {
          await lock$2.acquire(filepath, async function() {
            await fs.rm(filepath);
          });
        }
      }
    };
    __name(_GitShallowManager, "GitShallowManager");
    var GitShallowManager = _GitShallowManager;
    async function hasObjectLoose({ fs, gitdir, oid }) {
      const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
      return fs.exists(`${gitdir}/${source}`);
    }
    __name(hasObjectLoose, "hasObjectLoose");
    async function hasObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta
    }) {
      let list = await fs.readdir(pathBrowserify.join(gitdir, "objects/pack"));
      list = list.filter((x) => x.endsWith(".idx"));
      for (const filename of list) {
        const indexFile = `${gitdir}/objects/pack/${filename}`;
        const p = await readPackIndex({
          fs,
          cache,
          filename: indexFile,
          getExternalRefDelta
        });
        if (p.error) throw new InternalError(p.error);
        if (p.offsets.has(oid)) {
          return true;
        }
      }
      return false;
    }
    __name(hasObjectPacked, "hasObjectPacked");
    async function hasObject({
      fs,
      cache,
      gitdir,
      oid,
      format = "content"
    }) {
      const getExternalRefDelta = /* @__PURE__ */ __name((oid2) => _readObject({ fs, cache, gitdir, oid: oid2 }), "getExternalRefDelta");
      let result = await hasObjectLoose({ fs, gitdir, oid });
      if (!result) {
        result = await hasObjectPacked({
          fs,
          cache,
          gitdir,
          oid,
          getExternalRefDelta
        });
      }
      return result;
    }
    __name(hasObject, "hasObject");
    function emptyPackfile(pack) {
      const pheader = "5041434b";
      const version2 = "00000002";
      const obCount = "00000000";
      const header = pheader + version2 + obCount;
      return pack.slice(0, 12).toString("hex") === header;
    }
    __name(emptyPackfile, "emptyPackfile");
    function filterCapabilities(server, client) {
      const serverNames = server.map((cap) => cap.split("=", 1)[0]);
      return client.filter((cap) => {
        const name = cap.split("=", 1)[0];
        return serverNames.includes(name);
      });
    }
    __name(filterCapabilities, "filterCapabilities");
    var pkg = {
      name: "isomorphic-git",
      version: "1.34.0",
      agent: "git/isomorphic-git@1.34.0"
    };
    var _FIFO = class _FIFO {
      constructor() {
        this._queue = [];
      }
      write(chunk) {
        if (this._ended) {
          throw Error("You cannot write to a FIFO that has already been ended!");
        }
        if (this._waiting) {
          const resolve = this._waiting;
          this._waiting = null;
          resolve({ value: chunk });
        } else {
          this._queue.push(chunk);
        }
      }
      end() {
        this._ended = true;
        if (this._waiting) {
          const resolve = this._waiting;
          this._waiting = null;
          resolve({ done: true });
        }
      }
      destroy(err) {
        this.error = err;
        this.end();
      }
      async next() {
        if (this._queue.length > 0) {
          return { value: this._queue.shift() };
        }
        if (this._ended) {
          return { done: true };
        }
        if (this._waiting) {
          throw Error(
            "You cannot call read until the previous call to read has returned!"
          );
        }
        return new Promise((resolve) => {
          this._waiting = resolve;
        });
      }
    };
    __name(_FIFO, "FIFO");
    var FIFO = _FIFO;
    function findSplit(str) {
      const r = str.indexOf("\r");
      const n = str.indexOf("\n");
      if (r === -1 && n === -1) return -1;
      if (r === -1) return n + 1;
      if (n === -1) return r + 1;
      if (n === r + 1) return n + 1;
      return Math.min(r, n) + 1;
    }
    __name(findSplit, "findSplit");
    function splitLines(input) {
      const output = new FIFO();
      let tmp = "";
      (async () => {
        await forAwait2(input, (chunk) => {
          chunk = chunk.toString("utf8");
          tmp += chunk;
          while (true) {
            const i = findSplit(tmp);
            if (i === -1) break;
            output.write(tmp.slice(0, i));
            tmp = tmp.slice(i);
          }
        });
        if (tmp.length > 0) {
          output.write(tmp);
        }
        output.end();
      })();
      return output;
    }
    __name(splitLines, "splitLines");
    var _GitSideBand = class _GitSideBand {
      static demux(input) {
        const read = GitPktLine.streamReader(input);
        const packetlines = new FIFO();
        const packfile = new FIFO();
        const progress = new FIFO();
        const nextBit = /* @__PURE__ */ __name(async function() {
          const line = await read();
          if (line === null) return nextBit();
          if (line === true) {
            packetlines.end();
            progress.end();
            input.error ? packfile.destroy(input.error) : packfile.end();
            return;
          }
          switch (line[0]) {
            case 1: {
              packfile.write(line.slice(1));
              break;
            }
            case 2: {
              progress.write(line.slice(1));
              break;
            }
            case 3: {
              const error = line.slice(1);
              progress.write(error);
              packetlines.end();
              progress.end();
              packfile.destroy(new Error(error.toString("utf8")));
              return;
            }
            default: {
              packetlines.write(line);
            }
          }
          nextBit();
        }, "nextBit");
        nextBit();
        return {
          packetlines,
          packfile,
          progress
        };
      }
      // static mux ({
      //   protocol, // 'side-band' or 'side-band-64k'
      //   packetlines,
      //   packfile,
      //   progress,
      //   error
      // }) {
      //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519
      //   let output = new PassThrough()
      //   packetlines.on('data', data => {
      //     if (data === null) {
      //       output.write(GitPktLine.flush())
      //     } else {
      //       output.write(GitPktLine.encode(data))
      //     }
      //   })
      //   let packfileWasEmpty = true
      //   let packfileEnded = false
      //   let progressEnded = false
      //   let errorEnded = false
      //   let goodbye = Buffer.concat([
      //     GitPktLine.encode(Buffer.from('010A', 'hex')),
      //     GitPktLine.flush()
      //   ])
      //   packfile
      //     .on('data', data => {
      //       packfileWasEmpty = false
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       packfileEnded = true
      //       if (!packfileWasEmpty) output.write(goodbye)
      //       if (progressEnded && errorEnded) output.end()
      //     })
      //   progress
      //     .on('data', data => {
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       progressEnded = true
      //       if (packfileEnded && errorEnded) output.end()
      //     })
      //   error
      //     .on('data', data => {
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       errorEnded = true
      //       if (progressEnded && packfileEnded) output.end()
      //     })
      //   return output
      // }
    };
    __name(_GitSideBand, "GitSideBand");
    var GitSideBand = _GitSideBand;
    async function parseUploadPackResponse(stream) {
      const { packetlines, packfile, progress } = GitSideBand.demux(stream);
      const shallows = [];
      const unshallows = [];
      const acks = [];
      let nak = false;
      let done = false;
      return new Promise((resolve, reject) => {
        forAwait2(packetlines, (data) => {
          const line = data.toString("utf8").trim();
          if (line.startsWith("shallow")) {
            const oid = line.slice(-41).trim();
            if (oid.length !== 40) {
              reject(new InvalidOidError(oid));
            }
            shallows.push(oid);
          } else if (line.startsWith("unshallow")) {
            const oid = line.slice(-41).trim();
            if (oid.length !== 40) {
              reject(new InvalidOidError(oid));
            }
            unshallows.push(oid);
          } else if (line.startsWith("ACK")) {
            const [, oid, status2] = line.split(" ");
            acks.push({ oid, status: status2 });
            if (!status2) done = true;
          } else if (line.startsWith("NAK")) {
            nak = true;
            done = true;
          } else {
            done = true;
            nak = true;
          }
          if (done) {
            stream.error ? reject(stream.error) : resolve({ shallows, unshallows, acks, nak, packfile, progress });
          }
        }).finally(() => {
          if (!done) {
            stream.error ? reject(stream.error) : resolve({ shallows, unshallows, acks, nak, packfile, progress });
          }
        });
      });
    }
    __name(parseUploadPackResponse, "parseUploadPackResponse");
    function writeUploadPackRequest({
      capabilities = [],
      wants = [],
      haves = [],
      shallows = [],
      depth = null,
      since = null,
      exclude = []
    }) {
      const packstream = [];
      wants = [...new Set(wants)];
      let firstLineCapabilities = ` ${capabilities.join(" ")}`;
      for (const oid of wants) {
        packstream.push(GitPktLine.encode(`want ${oid}${firstLineCapabilities}
`));
        firstLineCapabilities = "";
      }
      for (const oid of shallows) {
        packstream.push(GitPktLine.encode(`shallow ${oid}
`));
      }
      if (depth !== null) {
        packstream.push(GitPktLine.encode(`deepen ${depth}
`));
      }
      if (since !== null) {
        packstream.push(
          GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / 1e3)}
`)
        );
      }
      for (const oid of exclude) {
        packstream.push(GitPktLine.encode(`deepen-not ${oid}
`));
      }
      packstream.push(GitPktLine.flush());
      for (const oid of haves) {
        packstream.push(GitPktLine.encode(`have ${oid}
`));
      }
      packstream.push(GitPktLine.encode(`done
`));
      return packstream;
    }
    __name(writeUploadPackRequest, "writeUploadPackRequest");
    async function _fetch({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref: _ref,
      remoteRef: _remoteRef,
      remote: _remote,
      url: _url,
      corsProxy,
      depth = null,
      since = null,
      exclude = [],
      relative = false,
      tags = false,
      singleBranch = false,
      headers = {},
      prune = false,
      pruneTags = false
    }) {
      const ref = _ref || await _currentBranch({ fs, gitdir, test: true });
      const config = await GitConfigManager.get({ fs, gitdir });
      const remote = _remote || ref && await config.get(`branch.${ref}.remote`) || "origin";
      const url = _url || await config.get(`remote.${remote}.url`);
      if (typeof url === "undefined") {
        throw new MissingParameterError("remote OR url");
      }
      const remoteRef = _remoteRef || ref && await config.get(`branch.${ref}.merge`) || _ref || "HEAD";
      if (corsProxy === void 0) {
        corsProxy = await config.get("http.corsProxy");
      }
      const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
      const remoteHTTP = await GitRemoteHTTP2.discover({
        http,
        onAuth,
        onAuthSuccess,
        onAuthFailure,
        corsProxy,
        service: "git-upload-pack",
        url,
        headers,
        protocolVersion: 1
      });
      const auth = remoteHTTP.auth;
      const remoteRefs = remoteHTTP.refs;
      if (remoteRefs.size === 0) {
        return {
          defaultBranch: null,
          fetchHead: null,
          fetchHeadDescription: null
        };
      }
      if (depth !== null && !remoteHTTP.capabilities.has("shallow")) {
        throw new RemoteCapabilityError("shallow", "depth");
      }
      if (since !== null && !remoteHTTP.capabilities.has("deepen-since")) {
        throw new RemoteCapabilityError("deepen-since", "since");
      }
      if (exclude.length > 0 && !remoteHTTP.capabilities.has("deepen-not")) {
        throw new RemoteCapabilityError("deepen-not", "exclude");
      }
      if (relative === true && !remoteHTTP.capabilities.has("deepen-relative")) {
        throw new RemoteCapabilityError("deepen-relative", "relative");
      }
      const { oid, fullref } = GitRefManager.resolveAgainstMap({
        ref: remoteRef,
        map: remoteRefs
      });
      for (const remoteRef2 of remoteRefs.keys()) {
        if (remoteRef2 === fullref || remoteRef2 === "HEAD" || remoteRef2.startsWith("refs/heads/") || tags && remoteRef2.startsWith("refs/tags/")) {
          continue;
        }
        remoteRefs.delete(remoteRef2);
      }
      const capabilities = filterCapabilities(
        [...remoteHTTP.capabilities],
        [
          "multi_ack_detailed",
          "no-done",
          "side-band-64k",
          // Note: I removed 'thin-pack' option since our code doesn't "fatten" packfiles,
          // which is necessary for compatibility with git. It was the cause of mysterious
          // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.
          // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but
          // canonical git it turns out is NOT.
          "ofs-delta",
          `agent=${pkg.agent}`
        ]
      );
      if (relative) capabilities.push("deepen-relative");
      const wants = singleBranch ? [oid] : remoteRefs.values();
      const haveRefs = singleBranch ? [ref] : await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: `refs`
      });
      let haves = [];
      for (let ref2 of haveRefs) {
        try {
          ref2 = await GitRefManager.expand({ fs, gitdir, ref: ref2 });
          const oid2 = await GitRefManager.resolve({ fs, gitdir, ref: ref2 });
          if (await hasObject({ fs, cache, gitdir, oid: oid2 })) {
            haves.push(oid2);
          }
        } catch (err) {
        }
      }
      haves = [...new Set(haves)];
      const oids = await GitShallowManager.read({ fs, gitdir });
      const shallows = remoteHTTP.capabilities.has("shallow") ? [...oids] : [];
      const packstream = writeUploadPackRequest({
        capabilities,
        wants,
        haves,
        shallows,
        depth,
        since,
        exclude
      });
      const packbuffer = Buffer.from(await collect2(packstream));
      const raw = await GitRemoteHTTP2.connect({
        http,
        onProgress,
        corsProxy,
        service: "git-upload-pack",
        url,
        auth,
        body: [packbuffer],
        headers
      });
      const response = await parseUploadPackResponse(raw.body);
      if (raw.headers) {
        response.headers = raw.headers;
      }
      for (const oid2 of response.shallows) {
        if (!oids.has(oid2)) {
          try {
            const { object } = await _readObject({ fs, cache, gitdir, oid: oid2 });
            const commit2 = new GitCommit(object);
            const hasParents = await Promise.all(
              commit2.headers().parent.map((oid3) => hasObject({ fs, cache, gitdir, oid: oid3 }))
            );
            const haveAllParents = hasParents.length === 0 || hasParents.every((has) => has);
            if (!haveAllParents) {
              oids.add(oid2);
            }
          } catch (err) {
            oids.add(oid2);
          }
        }
      }
      for (const oid2 of response.unshallows) {
        oids.delete(oid2);
      }
      await GitShallowManager.write({ fs, gitdir, oids });
      if (singleBranch) {
        const refs = /* @__PURE__ */ new Map([[fullref, oid]]);
        const symrefs = /* @__PURE__ */ new Map();
        let bail = 10;
        let key = fullref;
        while (bail--) {
          const value = remoteHTTP.symrefs.get(key);
          if (value === void 0) break;
          symrefs.set(key, value);
          key = value;
        }
        const realRef = remoteRefs.get(key);
        if (realRef) {
          refs.set(key, realRef);
        }
        const { pruned } = await GitRefManager.updateRemoteRefs({
          fs,
          gitdir,
          remote,
          refs,
          symrefs,
          tags,
          prune
        });
        if (prune) {
          response.pruned = pruned;
        }
      } else {
        const { pruned } = await GitRefManager.updateRemoteRefs({
          fs,
          gitdir,
          remote,
          refs: remoteRefs,
          symrefs: remoteHTTP.symrefs,
          tags,
          prune,
          pruneTags
        });
        if (prune) {
          response.pruned = pruned;
        }
      }
      response.HEAD = remoteHTTP.symrefs.get("HEAD");
      if (response.HEAD === void 0) {
        const { oid: oid2 } = GitRefManager.resolveAgainstMap({
          ref: "HEAD",
          map: remoteRefs
        });
        for (const [key, value] of remoteRefs.entries()) {
          if (key !== "HEAD" && value === oid2) {
            response.HEAD = key;
            break;
          }
        }
      }
      const noun = fullref.startsWith("refs/tags") ? "tag" : "branch";
      response.FETCH_HEAD = {
        oid,
        description: `${noun} '${abbreviateRef(fullref)}' of ${url}`
      };
      if (onProgress || onMessage) {
        const lines = splitLines(response.progress);
        forAwait2(lines, async (line) => {
          if (onMessage) await onMessage(line);
          if (onProgress) {
            const matches = line.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);
            if (matches) {
              await onProgress({
                phase: matches[1].trim(),
                loaded: parseInt(matches[2], 10),
                total: parseInt(matches[3], 10)
              });
            }
          }
        });
      }
      const packfile = Buffer.from(await collect2(response.packfile));
      if (raw.body.error) throw raw.body.error;
      const packfileSha = packfile.slice(-20).toString("hex");
      const res = {
        defaultBranch: response.HEAD,
        fetchHead: response.FETCH_HEAD.oid,
        fetchHeadDescription: response.FETCH_HEAD.description
      };
      if (response.headers) {
        res.headers = response.headers;
      }
      if (prune) {
        res.pruned = response.pruned;
      }
      if (packfileSha !== "" && !emptyPackfile(packfile)) {
        res.packfile = `objects/pack/pack-${packfileSha}.pack`;
        const fullpath = pathBrowserify.join(gitdir, res.packfile);
        await fs.write(fullpath, packfile);
        const getExternalRefDelta = /* @__PURE__ */ __name((oid2) => _readObject({ fs, cache, gitdir, oid: oid2 }), "getExternalRefDelta");
        const idx = await GitPackIndex.fromPack({
          pack: packfile,
          getExternalRefDelta,
          onProgress
        });
        await fs.write(fullpath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
      }
      return res;
    }
    __name(_fetch, "_fetch");
    async function _init({
      fs,
      bare = false,
      dir,
      gitdir = bare ? dir : pathBrowserify.join(dir, ".git"),
      defaultBranch = "master"
    }) {
      if (await fs.exists(gitdir + "/config")) return;
      let folders = [
        "hooks",
        "info",
        "objects/info",
        "objects/pack",
        "refs/heads",
        "refs/tags"
      ];
      folders = folders.map((dir2) => gitdir + "/" + dir2);
      for (const folder of folders) {
        await fs.mkdir(folder);
      }
      await fs.write(
        gitdir + "/config",
        `[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${bare}
` + (bare ? "" : "	logallrefupdates = true\n") + "	symlinks = false\n	ignorecase = true\n"
      );
      await fs.write(gitdir + "/HEAD", `ref: refs/heads/${defaultBranch}
`);
    }
    __name(_init, "_init");
    async function _clone({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      onPostCheckout,
      dir,
      gitdir,
      url,
      corsProxy,
      ref,
      remote,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      noCheckout,
      noTags,
      headers,
      nonBlocking,
      batchSize = 100
    }) {
      try {
        await _init({ fs, gitdir });
        await _addRemote({ fs, gitdir, remote, url, force: false });
        if (corsProxy) {
          const config = await GitConfigManager.get({ fs, gitdir });
          await config.set(`http.corsProxy`, corsProxy);
          await GitConfigManager.save({ fs, gitdir, config });
        }
        const { defaultBranch, fetchHead } = await _fetch({
          fs,
          cache,
          http,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          gitdir,
          ref,
          remote,
          corsProxy,
          depth,
          since,
          exclude,
          relative,
          singleBranch,
          headers,
          tags: !noTags
        });
        if (fetchHead === null) return;
        ref = ref || defaultBranch;
        ref = ref.replace("refs/heads/", "");
        await _checkout({
          fs,
          cache,
          onProgress,
          onPostCheckout,
          dir,
          gitdir,
          ref,
          remote,
          noCheckout,
          nonBlocking,
          batchSize
        });
      } catch (err) {
        await fs.rmdir(gitdir, { recursive: true, maxRetries: 10 }).catch(() => void 0);
        throw err;
      }
    }
    __name(_clone, "_clone");
    async function clone({
      fs,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      onPostCheckout,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      url,
      corsProxy = void 0,
      ref = void 0,
      remote = "origin",
      depth = void 0,
      since = void 0,
      exclude = [],
      relative = false,
      singleBranch = false,
      noCheckout = false,
      noTags = false,
      headers = {},
      cache = {},
      nonBlocking = false,
      batchSize = 100
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("http", http);
        assertParameter("gitdir", gitdir);
        if (!noCheckout) {
          assertParameter("dir", dir);
        }
        assertParameter("url", url);
        return await _clone({
          fs: new FileSystem(fs),
          cache,
          http,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          onPostCheckout,
          dir,
          gitdir,
          url,
          corsProxy,
          ref,
          remote,
          depth,
          since,
          exclude,
          relative,
          singleBranch,
          noCheckout,
          noTags,
          headers,
          nonBlocking,
          batchSize
        });
      } catch (err) {
        err.caller = "git.clone";
        throw err;
      }
    }
    __name(clone, "clone");
    async function commit({
      fs: _fs,
      onSign,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      message,
      author,
      committer,
      signingKey,
      amend = false,
      dryRun = false,
      noUpdateBranch = false,
      ref,
      parent,
      tree,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        if (!amend) {
          assertParameter("message", message);
        }
        if (signingKey) {
          assertParameter("onSign", onSign);
        }
        const fs = new FileSystem(_fs);
        return await _commit({
          fs,
          cache,
          onSign,
          gitdir,
          message,
          author,
          committer,
          signingKey,
          amend,
          dryRun,
          noUpdateBranch,
          ref,
          parent,
          tree
        });
      } catch (err) {
        err.caller = "git.commit";
        throw err;
      }
    }
    __name(commit, "commit");
    async function currentBranch2({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      fullname = false,
      test = false
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        return await _currentBranch({
          fs: new FileSystem(fs),
          gitdir,
          fullname,
          test
        });
      } catch (err) {
        err.caller = "git.currentBranch";
        throw err;
      }
    }
    __name(currentBranch2, "currentBranch");
    async function _deleteBranch({ fs, gitdir, ref }) {
      ref = ref.startsWith("refs/heads/") ? ref : `refs/heads/${ref}`;
      const exist = await GitRefManager.exists({ fs, gitdir, ref });
      if (!exist) {
        throw new NotFoundError(ref);
      }
      const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
      const currentRef = await _currentBranch({ fs, gitdir, fullname: true });
      if (fullRef === currentRef) {
        const value = await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
        await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value });
      }
      await GitRefManager.deleteRef({ fs, gitdir, ref: fullRef });
      const abbrevRef = abbreviateRef(ref);
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.deleteSection("branch", abbrevRef);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    __name(_deleteBranch, "_deleteBranch");
    async function deleteBranch({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("ref", ref);
        return await _deleteBranch({
          fs: new FileSystem(fs),
          gitdir,
          ref
        });
      } catch (err) {
        err.caller = "git.deleteBranch";
        throw err;
      }
    }
    __name(deleteBranch, "deleteBranch");
    async function deleteRef({ fs, dir, gitdir = pathBrowserify.join(dir, ".git"), ref }) {
      try {
        assertParameter("fs", fs);
        assertParameter("ref", ref);
        await GitRefManager.deleteRef({ fs: new FileSystem(fs), gitdir, ref });
      } catch (err) {
        err.caller = "git.deleteRef";
        throw err;
      }
    }
    __name(deleteRef, "deleteRef");
    async function _deleteRemote({ fs, gitdir, remote }) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.deleteSection("remote", remote);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    __name(_deleteRemote, "_deleteRemote");
    async function deleteRemote({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      remote
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("remote", remote);
        return await _deleteRemote({
          fs: new FileSystem(fs),
          gitdir,
          remote
        });
      } catch (err) {
        err.caller = "git.deleteRemote";
        throw err;
      }
    }
    __name(deleteRemote, "deleteRemote");
    async function _deleteTag({ fs, gitdir, ref }) {
      ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
      await GitRefManager.deleteRef({ fs, gitdir, ref });
    }
    __name(_deleteTag, "_deleteTag");
    async function deleteTag({ fs, dir, gitdir = pathBrowserify.join(dir, ".git"), ref }) {
      try {
        assertParameter("fs", fs);
        assertParameter("ref", ref);
        return await _deleteTag({
          fs: new FileSystem(fs),
          gitdir,
          ref
        });
      } catch (err) {
        err.caller = "git.deleteTag";
        throw err;
      }
    }
    __name(deleteTag, "deleteTag");
    async function expandOidLoose({ fs, gitdir, oid: short }) {
      const prefix = short.slice(0, 2);
      const objectsSuffixes = await fs.readdir(`${gitdir}/objects/${prefix}`);
      return objectsSuffixes.map((suffix) => `${prefix}${suffix}`).filter((_oid) => _oid.startsWith(short));
    }
    __name(expandOidLoose, "expandOidLoose");
    async function expandOidPacked({
      fs,
      cache,
      gitdir,
      oid: short,
      getExternalRefDelta
    }) {
      const results = [];
      let list = await fs.readdir(pathBrowserify.join(gitdir, "objects/pack"));
      list = list.filter((x) => x.endsWith(".idx"));
      for (const filename of list) {
        const indexFile = `${gitdir}/objects/pack/${filename}`;
        const p = await readPackIndex({
          fs,
          cache,
          filename: indexFile,
          getExternalRefDelta
        });
        if (p.error) throw new InternalError(p.error);
        for (const oid of p.offsets.keys()) {
          if (oid.startsWith(short)) results.push(oid);
        }
      }
      return results;
    }
    __name(expandOidPacked, "expandOidPacked");
    async function _expandOid({ fs, cache, gitdir, oid: short }) {
      const getExternalRefDelta = /* @__PURE__ */ __name((oid) => _readObject({ fs, cache, gitdir, oid }), "getExternalRefDelta");
      const results = await expandOidLoose({ fs, gitdir, oid: short });
      const packedOids = await expandOidPacked({
        fs,
        cache,
        gitdir,
        oid: short,
        getExternalRefDelta
      });
      for (const packedOid of packedOids) {
        if (results.indexOf(packedOid) === -1) {
          results.push(packedOid);
        }
      }
      if (results.length === 1) {
        return results[0];
      }
      if (results.length > 1) {
        throw new AmbiguousError("oids", short, results);
      }
      throw new NotFoundError(`an object matching "${short}"`);
    }
    __name(_expandOid, "_expandOid");
    async function expandOid({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oid,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        return await _expandOid({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          oid
        });
      } catch (err) {
        err.caller = "git.expandOid";
        throw err;
      }
    }
    __name(expandOid, "expandOid");
    async function expandRef({ fs, dir, gitdir = pathBrowserify.join(dir, ".git"), ref }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        return await GitRefManager.expand({
          fs: new FileSystem(fs),
          gitdir,
          ref
        });
      } catch (err) {
        err.caller = "git.expandRef";
        throw err;
      }
    }
    __name(expandRef, "expandRef");
    async function _findMergeBase({ fs, cache, gitdir, oids }) {
      const visits = {};
      const passes = oids.length;
      let heads = oids.map((oid, index3) => ({ index: index3, oid }));
      while (heads.length) {
        const result = /* @__PURE__ */ new Set();
        for (const { oid, index: index3 } of heads) {
          if (!visits[oid]) visits[oid] = /* @__PURE__ */ new Set();
          visits[oid].add(index3);
          if (visits[oid].size === passes) {
            result.add(oid);
          }
        }
        if (result.size > 0) {
          return [...result];
        }
        const newheads = /* @__PURE__ */ new Map();
        for (const { oid, index: index3 } of heads) {
          try {
            const { object } = await _readObject({ fs, cache, gitdir, oid });
            const commit2 = GitCommit.from(object);
            const { parent } = commit2.parseHeaders();
            for (const oid2 of parent) {
              if (!visits[oid2] || !visits[oid2].has(index3)) {
                newheads.set(oid2 + ":" + index3, { oid: oid2, index: index3 });
              }
            }
          } catch (err) {
          }
        }
        heads = Array.from(newheads.values());
      }
      return [];
    }
    __name(_findMergeBase, "_findMergeBase");
    var LINEBREAKS = /^.*(\r?\n|$)/gm;
    function mergeFile({ branches, contents }) {
      const ourName = branches[1];
      const theirName = branches[2];
      const baseContent = contents[0];
      const ourContent = contents[1];
      const theirContent = contents[2];
      const ours = ourContent.match(LINEBREAKS);
      const base = baseContent.match(LINEBREAKS);
      const theirs = theirContent.match(LINEBREAKS);
      const result = diff3Merge(ours, base, theirs);
      const markerSize = 7;
      let mergedText = "";
      let cleanMerge = true;
      for (const item of result) {
        if (item.ok) {
          mergedText += item.ok.join("");
        }
        if (item.conflict) {
          cleanMerge = false;
          mergedText += `${"<".repeat(markerSize)} ${ourName}
`;
          mergedText += item.conflict.a.join("");
          mergedText += `${"=".repeat(markerSize)}
`;
          mergedText += item.conflict.b.join("");
          mergedText += `${">".repeat(markerSize)} ${theirName}
`;
        }
      }
      return { cleanMerge, mergedText };
    }
    __name(mergeFile, "mergeFile");
    async function mergeTree({
      fs,
      cache,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      index: index3,
      ourOid,
      baseOid,
      theirOid,
      ourName = "ours",
      baseName = "base",
      theirName = "theirs",
      dryRun = false,
      abortOnConflict = true,
      mergeDriver
    }) {
      const ourTree = TREE({ ref: ourOid });
      const baseTree = TREE({ ref: baseOid });
      const theirTree = TREE({ ref: theirOid });
      const unmergedFiles = [];
      const bothModified = [];
      const deleteByUs = [];
      const deleteByTheirs = [];
      const results = await _walk({
        fs,
        cache,
        dir,
        gitdir,
        trees: [ourTree, baseTree, theirTree],
        map: /* @__PURE__ */ __name(async function(filepath, [ours, base, theirs]) {
          const path6 = basename2(filepath);
          const ourChange = await modified(ours, base);
          const theirChange = await modified(theirs, base);
          switch (`${ourChange}-${theirChange}`) {
            case "false-false": {
              return {
                mode: await base.mode(),
                path: path6,
                oid: await base.oid(),
                type: await base.type()
              };
            }
            case "false-true": {
              if (!theirs && await ours.type() === "tree") {
                return {
                  mode: await ours.mode(),
                  path: path6,
                  oid: await ours.oid(),
                  type: await ours.type()
                };
              }
              return theirs ? {
                mode: await theirs.mode(),
                path: path6,
                oid: await theirs.oid(),
                type: await theirs.type()
              } : void 0;
            }
            case "true-false": {
              if (!ours && await theirs.type() === "tree") {
                return {
                  mode: await theirs.mode(),
                  path: path6,
                  oid: await theirs.oid(),
                  type: await theirs.type()
                };
              }
              return ours ? {
                mode: await ours.mode(),
                path: path6,
                oid: await ours.oid(),
                type: await ours.type()
              } : void 0;
            }
            case "true-true": {
              if (ours && theirs && await ours.type() === "tree" && await theirs.type() === "tree") {
                return {
                  mode: await ours.mode(),
                  path: path6,
                  oid: await ours.oid(),
                  type: "tree"
                };
              }
              if (ours && theirs && await ours.type() === "blob" && await theirs.type() === "blob") {
                return mergeBlobs({
                  fs,
                  gitdir,
                  path: path6,
                  ours,
                  base,
                  theirs,
                  ourName,
                  baseName,
                  theirName,
                  mergeDriver
                }).then(async (r) => {
                  if (!r.cleanMerge) {
                    unmergedFiles.push(filepath);
                    bothModified.push(filepath);
                    if (!abortOnConflict) {
                      let baseOid2 = "";
                      if (base && await base.type() === "blob") {
                        baseOid2 = await base.oid();
                      }
                      const ourOid2 = await ours.oid();
                      const theirOid2 = await theirs.oid();
                      index3.delete({ filepath });
                      if (baseOid2) {
                        index3.insert({ filepath, oid: baseOid2, stage: 1 });
                      }
                      index3.insert({ filepath, oid: ourOid2, stage: 2 });
                      index3.insert({ filepath, oid: theirOid2, stage: 3 });
                    }
                  } else if (!abortOnConflict) {
                    index3.insert({ filepath, oid: r.mergeResult.oid, stage: 0 });
                  }
                  return r.mergeResult;
                });
              }
              if (base && !ours && theirs && await base.type() === "blob" && await theirs.type() === "blob") {
                unmergedFiles.push(filepath);
                deleteByUs.push(filepath);
                if (!abortOnConflict) {
                  const baseOid2 = await base.oid();
                  const theirOid2 = await theirs.oid();
                  index3.delete({ filepath });
                  index3.insert({ filepath, oid: baseOid2, stage: 1 });
                  index3.insert({ filepath, oid: theirOid2, stage: 3 });
                }
                return {
                  mode: await theirs.mode(),
                  oid: await theirs.oid(),
                  type: "blob",
                  path: path6
                };
              }
              if (base && ours && !theirs && await base.type() === "blob" && await ours.type() === "blob") {
                unmergedFiles.push(filepath);
                deleteByTheirs.push(filepath);
                if (!abortOnConflict) {
                  const baseOid2 = await base.oid();
                  const ourOid2 = await ours.oid();
                  index3.delete({ filepath });
                  index3.insert({ filepath, oid: baseOid2, stage: 1 });
                  index3.insert({ filepath, oid: ourOid2, stage: 2 });
                }
                return {
                  mode: await ours.mode(),
                  oid: await ours.oid(),
                  type: "blob",
                  path: path6
                };
              }
              if (base && !ours && !theirs && (await base.type() === "blob" || await base.type() === "tree")) {
                return void 0;
              }
              throw new MergeNotSupportedError();
            }
          }
        }, "map"),
        /**
         * @param {TreeEntry} [parent]
         * @param {Array<TreeEntry>} children
         */
        reduce: unmergedFiles.length !== 0 && (!dir || abortOnConflict) ? void 0 : async (parent, children) => {
          const entries = children.filter(Boolean);
          if (!parent) return;
          if (parent && parent.type === "tree" && entries.length === 0 && parent.path !== ".")
            return;
          if (entries.length > 0 || parent.path === "." && entries.length === 0) {
            const tree = new GitTree(entries);
            const object = tree.toObject();
            const oid = await _writeObject({
              fs,
              gitdir,
              type: "tree",
              object,
              dryRun
            });
            parent.oid = oid;
          }
          return parent;
        }
      });
      if (unmergedFiles.length !== 0) {
        if (dir && !abortOnConflict) {
          await _walk({
            fs,
            cache,
            dir,
            gitdir,
            trees: [TREE({ ref: results.oid })],
            map: /* @__PURE__ */ __name(async function(filepath, [entry]) {
              const path6 = `${dir}/${filepath}`;
              if (await entry.type() === "blob") {
                const mode = await entry.mode();
                const content = new TextDecoder().decode(await entry.content());
                await fs.write(path6, content, { mode });
              }
              return true;
            }, "map")
          });
        }
        return new MergeConflictError(
          unmergedFiles,
          bothModified,
          deleteByUs,
          deleteByTheirs
        );
      }
      return results.oid;
    }
    __name(mergeTree, "mergeTree");
    async function mergeBlobs({
      fs,
      gitdir,
      path: path6,
      ours,
      base,
      theirs,
      ourName,
      theirName,
      baseName,
      dryRun,
      mergeDriver = mergeFile
    }) {
      const type = "blob";
      let baseMode = "100755";
      let baseOid = "";
      let baseContent = "";
      if (base && await base.type() === "blob") {
        baseMode = await base.mode();
        baseOid = await base.oid();
        baseContent = Buffer.from(await base.content()).toString("utf8");
      }
      const mode = baseMode === await ours.mode() ? await theirs.mode() : await ours.mode();
      if (await ours.oid() === await theirs.oid()) {
        return {
          cleanMerge: true,
          mergeResult: { mode, path: path6, oid: await ours.oid(), type }
        };
      }
      if (await ours.oid() === baseOid) {
        return {
          cleanMerge: true,
          mergeResult: { mode, path: path6, oid: await theirs.oid(), type }
        };
      }
      if (await theirs.oid() === baseOid) {
        return {
          cleanMerge: true,
          mergeResult: { mode, path: path6, oid: await ours.oid(), type }
        };
      }
      const ourContent = Buffer.from(await ours.content()).toString("utf8");
      const theirContent = Buffer.from(await theirs.content()).toString("utf8");
      const { mergedText, cleanMerge } = await mergeDriver({
        branches: [baseName, ourName, theirName],
        contents: [baseContent, ourContent, theirContent],
        path: path6
      });
      const oid = await _writeObject({
        fs,
        gitdir,
        type: "blob",
        object: Buffer.from(mergedText, "utf8"),
        dryRun
      });
      return { cleanMerge, mergeResult: { mode, path: path6, oid, type } };
    }
    __name(mergeBlobs, "mergeBlobs");
    async function _merge({
      fs,
      cache,
      dir,
      gitdir,
      ours,
      theirs,
      fastForward: fastForward2 = true,
      fastForwardOnly = false,
      dryRun = false,
      noUpdateBranch = false,
      abortOnConflict = true,
      message,
      author,
      committer,
      signingKey,
      onSign,
      mergeDriver,
      allowUnrelatedHistories = false
    }) {
      if (ours === void 0) {
        ours = await _currentBranch({ fs, gitdir, fullname: true });
      }
      ours = await GitRefManager.expand({
        fs,
        gitdir,
        ref: ours
      });
      theirs = await GitRefManager.expand({
        fs,
        gitdir,
        ref: theirs
      });
      const ourOid = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: ours
      });
      const theirOid = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: theirs
      });
      const baseOids = await _findMergeBase({
        fs,
        cache,
        gitdir,
        oids: [ourOid, theirOid]
      });
      if (baseOids.length !== 1) {
        if (baseOids.length === 0 && allowUnrelatedHistories) {
          baseOids.push("4b825dc642cb6eb9a060e54bf8d69288fbee4904");
        } else {
          throw new MergeNotSupportedError();
        }
      }
      const baseOid = baseOids[0];
      if (baseOid === theirOid) {
        return {
          oid: ourOid,
          alreadyMerged: true
        };
      }
      if (fastForward2 && baseOid === ourOid) {
        if (!dryRun && !noUpdateBranch) {
          await GitRefManager.writeRef({ fs, gitdir, ref: ours, value: theirOid });
        }
        return {
          oid: theirOid,
          fastForward: true
        };
      } else {
        if (fastForwardOnly) {
          throw new FastForwardError();
        }
        const tree = await GitIndexManager.acquire(
          { fs, gitdir, cache, allowUnmerged: false },
          async (index3) => {
            return mergeTree({
              fs,
              cache,
              dir,
              gitdir,
              index: index3,
              ourOid,
              theirOid,
              baseOid,
              ourName: abbreviateRef(ours),
              baseName: "base",
              theirName: abbreviateRef(theirs),
              dryRun,
              abortOnConflict,
              mergeDriver
            });
          }
        );
        if (tree instanceof MergeConflictError) throw tree;
        if (!message) {
          message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(
            ours
          )}`;
        }
        const oid = await _commit({
          fs,
          cache,
          gitdir,
          message,
          ref: ours,
          tree,
          parent: [ourOid, theirOid],
          author,
          committer,
          signingKey,
          onSign,
          dryRun,
          noUpdateBranch
        });
        return {
          oid,
          tree,
          mergeCommit: true
        };
      }
    }
    __name(_merge, "_merge");
    async function _pull({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      prune,
      pruneTags,
      fastForward: fastForward2,
      fastForwardOnly,
      corsProxy,
      singleBranch,
      headers,
      author,
      committer,
      signingKey
    }) {
      try {
        if (!ref) {
          const head = await _currentBranch({ fs, gitdir });
          if (!head) {
            throw new MissingParameterError("ref");
          }
          ref = head;
        }
        const { fetchHead, fetchHeadDescription } = await _fetch({
          fs,
          cache,
          http,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          gitdir,
          corsProxy,
          ref,
          url,
          remote,
          remoteRef,
          singleBranch,
          headers,
          prune,
          pruneTags
        });
        await _merge({
          fs,
          cache,
          gitdir,
          ours: ref,
          theirs: fetchHead,
          fastForward: fastForward2,
          fastForwardOnly,
          message: `Merge ${fetchHeadDescription}`,
          author,
          committer,
          signingKey,
          dryRun: false,
          noUpdateBranch: false
        });
        await _checkout({
          fs,
          cache,
          onProgress,
          dir,
          gitdir,
          ref,
          remote,
          noCheckout: false
        });
      } catch (err) {
        err.caller = "git.pull";
        throw err;
      }
    }
    __name(_pull, "_pull");
    async function fastForward({
      fs,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      url,
      remote,
      remoteRef,
      corsProxy,
      singleBranch,
      headers = {},
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("http", http);
        assertParameter("gitdir", gitdir);
        const thisWillNotBeUsed = {
          name: "",
          email: "",
          timestamp: Date.now(),
          timezoneOffset: 0
        };
        return await _pull({
          fs: new FileSystem(fs),
          cache,
          http,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          dir,
          gitdir,
          ref,
          url,
          remote,
          remoteRef,
          fastForwardOnly: true,
          corsProxy,
          singleBranch,
          headers,
          author: thisWillNotBeUsed,
          committer: thisWillNotBeUsed
        });
      } catch (err) {
        err.caller = "git.fastForward";
        throw err;
      }
    }
    __name(fastForward, "fastForward");
    async function fetch({
      fs,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      remote,
      remoteRef,
      url,
      corsProxy,
      depth = null,
      since = null,
      exclude = [],
      relative = false,
      tags = false,
      singleBranch = false,
      headers = {},
      prune = false,
      pruneTags = false,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("http", http);
        assertParameter("gitdir", gitdir);
        return await _fetch({
          fs: new FileSystem(fs),
          cache,
          http,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          gitdir,
          ref,
          remote,
          remoteRef,
          url,
          corsProxy,
          depth,
          since,
          exclude,
          relative,
          tags,
          singleBranch,
          headers,
          prune,
          pruneTags
        });
      } catch (err) {
        err.caller = "git.fetch";
        throw err;
      }
    }
    __name(fetch, "fetch");
    async function findMergeBase({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oids,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oids", oids);
        return await _findMergeBase({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          oids
        });
      } catch (err) {
        err.caller = "git.findMergeBase";
        throw err;
      }
    }
    __name(findMergeBase, "findMergeBase");
    async function _findRoot({ fs, filepath }) {
      if (await fs.exists(pathBrowserify.join(filepath, ".git"))) {
        return filepath;
      } else {
        const parent = dirname5(filepath);
        if (parent === filepath) {
          throw new NotFoundError(`git root for ${filepath}`);
        }
        return _findRoot({ fs, filepath: parent });
      }
    }
    __name(_findRoot, "_findRoot");
    async function findRoot({ fs, filepath }) {
      try {
        assertParameter("fs", fs);
        assertParameter("filepath", filepath);
        return await _findRoot({ fs: new FileSystem(fs), filepath });
      } catch (err) {
        err.caller = "git.findRoot";
        throw err;
      }
    }
    __name(findRoot, "findRoot");
    async function getConfig({ fs, dir, gitdir = pathBrowserify.join(dir, ".git"), path: path6 }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("path", path6);
        return await _getConfig({
          fs: new FileSystem(fs),
          gitdir,
          path: path6
        });
      } catch (err) {
        err.caller = "git.getConfig";
        throw err;
      }
    }
    __name(getConfig, "getConfig");
    async function _getConfigAll({ fs, gitdir, path: path6 }) {
      const config = await GitConfigManager.get({ fs, gitdir });
      return config.getall(path6);
    }
    __name(_getConfigAll, "_getConfigAll");
    async function getConfigAll({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      path: path6
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("path", path6);
        return await _getConfigAll({
          fs: new FileSystem(fs),
          gitdir,
          path: path6
        });
      } catch (err) {
        err.caller = "git.getConfigAll";
        throw err;
      }
    }
    __name(getConfigAll, "getConfigAll");
    async function getRemoteInfo({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      url,
      headers = {},
      forPush = false
    }) {
      try {
        assertParameter("http", http);
        assertParameter("url", url);
        const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
        const remote = await GitRemoteHTTP2.discover({
          http,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          corsProxy,
          service: forPush ? "git-receive-pack" : "git-upload-pack",
          url,
          headers,
          protocolVersion: 1
        });
        const result = {
          capabilities: [...remote.capabilities]
        };
        for (const [ref, oid] of remote.refs) {
          const parts = ref.split("/");
          const last = parts.pop();
          let o = result;
          for (const part of parts) {
            o[part] = o[part] || {};
            o = o[part];
          }
          o[last] = oid;
        }
        for (const [symref, ref] of remote.symrefs) {
          const parts = symref.split("/");
          const last = parts.pop();
          let o = result;
          for (const part of parts) {
            o[part] = o[part] || {};
            o = o[part];
          }
          o[last] = ref;
        }
        return result;
      } catch (err) {
        err.caller = "git.getRemoteInfo";
        throw err;
      }
    }
    __name(getRemoteInfo, "getRemoteInfo");
    function formatInfoRefs(remote, prefix, symrefs, peelTags) {
      const refs = [];
      for (const [key, value] of remote.refs) {
        if (prefix && !key.startsWith(prefix)) continue;
        if (key.endsWith("^{}")) {
          if (peelTags) {
            const _key = key.replace("^{}", "");
            const last = refs[refs.length - 1];
            const r = last.ref === _key ? last : refs.find((x) => x.ref === _key);
            if (r === void 0) {
              throw new Error("I did not expect this to happen");
            }
            r.peeled = value;
          }
          continue;
        }
        const ref = { ref: key, oid: value };
        if (symrefs) {
          if (remote.symrefs.has(key)) {
            ref.target = remote.symrefs.get(key);
          }
        }
        refs.push(ref);
      }
      return refs;
    }
    __name(formatInfoRefs, "formatInfoRefs");
    async function getRemoteInfo2({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      url,
      headers = {},
      forPush = false,
      protocolVersion = 2
    }) {
      try {
        assertParameter("http", http);
        assertParameter("url", url);
        const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
        const remote = await GitRemoteHTTP2.discover({
          http,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          corsProxy,
          service: forPush ? "git-receive-pack" : "git-upload-pack",
          url,
          headers,
          protocolVersion
        });
        if (remote.protocolVersion === 2) {
          return {
            protocolVersion: remote.protocolVersion,
            capabilities: remote.capabilities2
          };
        }
        const capabilities = {};
        for (const cap of remote.capabilities) {
          const [key, value] = cap.split("=");
          if (value) {
            capabilities[key] = value;
          } else {
            capabilities[key] = true;
          }
        }
        return {
          protocolVersion: 1,
          capabilities,
          refs: formatInfoRefs(remote, void 0, true, true)
        };
      } catch (err) {
        err.caller = "git.getRemoteInfo2";
        throw err;
      }
    }
    __name(getRemoteInfo2, "getRemoteInfo2");
    async function hashObject({
      type,
      object,
      format = "content",
      oid = void 0
    }) {
      if (format !== "deflated") {
        if (format !== "wrapped") {
          object = GitObject.wrap({ type, object });
        }
        oid = await shasum(object);
      }
      return { oid, object };
    }
    __name(hashObject, "hashObject");
    async function hashBlob({ object }) {
      try {
        assertParameter("object", object);
        if (typeof object === "string") {
          object = Buffer.from(object, "utf8");
        } else if (!(object instanceof Uint8Array)) {
          object = new Uint8Array(object);
        }
        const type = "blob";
        const { oid, object: _object } = await hashObject({
          type,
          format: "content",
          object
        });
        return { oid, type, object: _object, format: "wrapped" };
      } catch (err) {
        err.caller = "git.hashBlob";
        throw err;
      }
    }
    __name(hashBlob, "hashBlob");
    async function _indexPack({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      filepath
    }) {
      try {
        filepath = pathBrowserify.join(dir, filepath);
        const pack = await fs.read(filepath);
        const getExternalRefDelta = /* @__PURE__ */ __name((oid) => _readObject({ fs, cache, gitdir, oid }), "getExternalRefDelta");
        const idx = await GitPackIndex.fromPack({
          pack,
          getExternalRefDelta,
          onProgress
        });
        await fs.write(filepath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
        return {
          oids: [...idx.hashes]
        };
      } catch (err) {
        err.caller = "git.indexPack";
        throw err;
      }
    }
    __name(_indexPack, "_indexPack");
    async function indexPack({
      fs,
      onProgress,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      filepath,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("dir", dir);
        assertParameter("gitdir", dir);
        assertParameter("filepath", filepath);
        return await _indexPack({
          fs: new FileSystem(fs),
          cache,
          onProgress,
          dir,
          gitdir,
          filepath
        });
      } catch (err) {
        err.caller = "git.indexPack";
        throw err;
      }
    }
    __name(indexPack, "indexPack");
    async function init({
      fs,
      bare = false,
      dir,
      gitdir = bare ? dir : pathBrowserify.join(dir, ".git"),
      defaultBranch = "master"
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        if (!bare) {
          assertParameter("dir", dir);
        }
        return await _init({
          fs: new FileSystem(fs),
          bare,
          dir,
          gitdir,
          defaultBranch
        });
      } catch (err) {
        err.caller = "git.init";
        throw err;
      }
    }
    __name(init, "init");
    async function _isDescendent({
      fs,
      cache,
      gitdir,
      oid,
      ancestor,
      depth
    }) {
      const shallows = await GitShallowManager.read({ fs, gitdir });
      if (!oid) {
        throw new MissingParameterError("oid");
      }
      if (!ancestor) {
        throw new MissingParameterError("ancestor");
      }
      if (oid === ancestor) return false;
      const queue = [oid];
      const visited = /* @__PURE__ */ new Set();
      let searchdepth = 0;
      while (queue.length) {
        if (searchdepth++ === depth) {
          throw new MaxDepthError(depth);
        }
        const oid2 = queue.shift();
        const { type, object } = await _readObject({
          fs,
          cache,
          gitdir,
          oid: oid2
        });
        if (type !== "commit") {
          throw new ObjectTypeError(oid2, type, "commit");
        }
        const commit2 = GitCommit.from(object).parse();
        for (const parent of commit2.parent) {
          if (parent === ancestor) return true;
        }
        if (!shallows.has(oid2)) {
          for (const parent of commit2.parent) {
            if (!visited.has(parent)) {
              queue.push(parent);
              visited.add(parent);
            }
          }
        }
      }
      return false;
    }
    __name(_isDescendent, "_isDescendent");
    async function isDescendent({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oid,
      ancestor,
      depth = -1,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        assertParameter("ancestor", ancestor);
        return await _isDescendent({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          oid,
          ancestor,
          depth
        });
      } catch (err) {
        err.caller = "git.isDescendent";
        throw err;
      }
    }
    __name(isDescendent, "isDescendent");
    async function isIgnored({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      filepath
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("dir", dir);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        return GitIgnoreManager.isIgnored({
          fs: new FileSystem(fs),
          dir,
          gitdir,
          filepath
        });
      } catch (err) {
        err.caller = "git.isIgnored";
        throw err;
      }
    }
    __name(isIgnored, "isIgnored");
    async function listBranches({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      remote
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        return GitRefManager.listBranches({
          fs: new FileSystem(fs),
          gitdir,
          remote
        });
      } catch (err) {
        err.caller = "git.listBranches";
        throw err;
      }
    }
    __name(listBranches, "listBranches");
    async function _listFiles({ fs, gitdir, ref, cache }) {
      if (ref) {
        const oid = await GitRefManager.resolve({ gitdir, fs, ref });
        const filenames = [];
        await accumulateFilesFromOid({
          fs,
          cache,
          gitdir,
          oid,
          filenames,
          prefix: ""
        });
        return filenames;
      } else {
        return GitIndexManager.acquire({ fs, gitdir, cache }, async function(index3) {
          return index3.entries.map((x) => x.path);
        });
      }
    }
    __name(_listFiles, "_listFiles");
    async function accumulateFilesFromOid({
      fs,
      cache,
      gitdir,
      oid,
      filenames,
      prefix
    }) {
      const { tree } = await _readTree({ fs, cache, gitdir, oid });
      for (const entry of tree) {
        if (entry.type === "tree") {
          await accumulateFilesFromOid({
            fs,
            cache,
            gitdir,
            oid: entry.oid,
            filenames,
            prefix: pathBrowserify.join(prefix, entry.path)
          });
        } else {
          filenames.push(pathBrowserify.join(prefix, entry.path));
        }
      }
    }
    __name(accumulateFilesFromOid, "accumulateFilesFromOid");
    async function listFiles({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        return await _listFiles({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          ref
        });
      } catch (err) {
        err.caller = "git.listFiles";
        throw err;
      }
    }
    __name(listFiles, "listFiles");
    async function _listNotes({ fs, cache, gitdir, ref }) {
      let parent;
      try {
        parent = await GitRefManager.resolve({ gitdir, fs, ref });
      } catch (err) {
        if (err instanceof NotFoundError) {
          return [];
        }
      }
      const result = await _readTree({
        fs,
        cache,
        gitdir,
        oid: parent
      });
      const notes = result.tree.map((entry) => ({
        target: entry.path,
        note: entry.oid
      }));
      return notes;
    }
    __name(_listNotes, "_listNotes");
    async function listNotes({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref = "refs/notes/commits",
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        return await _listNotes({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          ref
        });
      } catch (err) {
        err.caller = "git.listNotes";
        throw err;
      }
    }
    __name(listNotes, "listNotes");
    async function listRefs({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      filepath
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        return GitRefManager.listRefs({ fs: new FileSystem(fs), gitdir, filepath });
      } catch (err) {
        err.caller = "git.listRefs";
        throw err;
      }
    }
    __name(listRefs, "listRefs");
    async function _listRemotes({ fs, gitdir }) {
      const config = await GitConfigManager.get({ fs, gitdir });
      const remoteNames = await config.getSubsections("remote");
      const remotes = Promise.all(
        remoteNames.map(async (remote) => {
          const url = await config.get(`remote.${remote}.url`);
          return { remote, url };
        })
      );
      return remotes;
    }
    __name(_listRemotes, "_listRemotes");
    async function listRemotes({ fs, dir, gitdir = pathBrowserify.join(dir, ".git") }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        return await _listRemotes({
          fs: new FileSystem(fs),
          gitdir
        });
      } catch (err) {
        err.caller = "git.listRemotes";
        throw err;
      }
    }
    __name(listRemotes, "listRemotes");
    async function parseListRefsResponse(stream) {
      const read = GitPktLine.streamReader(stream);
      const refs = [];
      let line;
      while (true) {
        line = await read();
        if (line === true) break;
        if (line === null) continue;
        line = line.toString("utf8").replace(/\n$/, "");
        const [oid, ref, ...attrs] = line.split(" ");
        const r = { ref, oid };
        for (const attr of attrs) {
          const [name, value] = attr.split(":");
          if (name === "symref-target") {
            r.target = value;
          } else if (name === "peeled") {
            r.peeled = value;
          }
        }
        refs.push(r);
      }
      return refs;
    }
    __name(parseListRefsResponse, "parseListRefsResponse");
    async function writeListRefsRequest({ prefix, symrefs, peelTags }) {
      const packstream = [];
      packstream.push(GitPktLine.encode("command=ls-refs\n"));
      packstream.push(GitPktLine.encode(`agent=${pkg.agent}
`));
      if (peelTags || symrefs || prefix) {
        packstream.push(GitPktLine.delim());
      }
      if (peelTags) packstream.push(GitPktLine.encode("peel"));
      if (symrefs) packstream.push(GitPktLine.encode("symrefs"));
      if (prefix) packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));
      packstream.push(GitPktLine.flush());
      return packstream;
    }
    __name(writeListRefsRequest, "writeListRefsRequest");
    async function listServerRefs({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      url,
      headers = {},
      forPush = false,
      protocolVersion = 2,
      prefix,
      symrefs,
      peelTags
    }) {
      try {
        assertParameter("http", http);
        assertParameter("url", url);
        const remote = await GitRemoteHTTP.discover({
          http,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          corsProxy,
          service: forPush ? "git-receive-pack" : "git-upload-pack",
          url,
          headers,
          protocolVersion
        });
        if (remote.protocolVersion === 1) {
          return formatInfoRefs(remote, prefix, symrefs, peelTags);
        }
        const body = await writeListRefsRequest({ prefix, symrefs, peelTags });
        const res = await GitRemoteHTTP.connect({
          http,
          auth: remote.auth,
          headers,
          corsProxy,
          service: forPush ? "git-receive-pack" : "git-upload-pack",
          url,
          body
        });
        return parseListRefsResponse(res.body);
      } catch (err) {
        err.caller = "git.listServerRefs";
        throw err;
      }
    }
    __name(listServerRefs, "listServerRefs");
    async function listTags({ fs, dir, gitdir = pathBrowserify.join(dir, ".git") }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        return GitRefManager.listTags({ fs: new FileSystem(fs), gitdir });
      } catch (err) {
        err.caller = "git.listTags";
        throw err;
      }
    }
    __name(listTags, "listTags");
    function compareAge(a, b) {
      return a.committer.timestamp - b.committer.timestamp;
    }
    __name(compareAge, "compareAge");
    var EMPTY_OID = "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";
    async function resolveFileIdInTree({ fs, cache, gitdir, oid, fileId }) {
      if (fileId === EMPTY_OID) return;
      const _oid = oid;
      let filepath;
      const result = await resolveTree({ fs, cache, gitdir, oid });
      const tree = result.tree;
      if (fileId === result.oid) {
        filepath = result.path;
      } else {
        filepath = await _resolveFileId({
          fs,
          cache,
          gitdir,
          tree,
          fileId,
          oid: _oid
        });
        if (Array.isArray(filepath)) {
          if (filepath.length === 0) filepath = void 0;
          else if (filepath.length === 1) filepath = filepath[0];
        }
      }
      return filepath;
    }
    __name(resolveFileIdInTree, "resolveFileIdInTree");
    async function _resolveFileId({
      fs,
      cache,
      gitdir,
      tree,
      fileId,
      oid,
      filepaths = [],
      parentPath = ""
    }) {
      const walks = tree.entries().map(function(entry) {
        let result;
        if (entry.oid === fileId) {
          result = pathBrowserify.join(parentPath, entry.path);
          filepaths.push(result);
        } else if (entry.type === "tree") {
          result = _readObject({
            fs,
            cache,
            gitdir,
            oid: entry.oid
          }).then(function({ object }) {
            return _resolveFileId({
              fs,
              cache,
              gitdir,
              tree: GitTree.from(object),
              fileId,
              oid,
              filepaths,
              parentPath: pathBrowserify.join(parentPath, entry.path)
            });
          });
        }
        return result;
      });
      await Promise.all(walks);
      return filepaths;
    }
    __name(_resolveFileId, "_resolveFileId");
    async function _log({
      fs,
      cache,
      gitdir,
      filepath,
      ref,
      depth,
      since,
      force,
      follow
    }) {
      const sinceTimestamp = typeof since === "undefined" ? void 0 : Math.floor(since.valueOf() / 1e3);
      const commits = [];
      const shallowCommits = await GitShallowManager.read({ fs, gitdir });
      const oid = await GitRefManager.resolve({ fs, gitdir, ref });
      const tips = [await _readCommit({ fs, cache, gitdir, oid })];
      let lastFileOid;
      let lastCommit;
      let isOk;
      function endCommit(commit2) {
        if (isOk && filepath) commits.push(commit2);
      }
      __name(endCommit, "endCommit");
      while (tips.length > 0) {
        const commit2 = tips.pop();
        if (sinceTimestamp !== void 0 && commit2.commit.committer.timestamp <= sinceTimestamp) {
          break;
        }
        if (filepath) {
          let vFileOid;
          try {
            vFileOid = await resolveFilepath({
              fs,
              cache,
              gitdir,
              oid: commit2.commit.tree,
              filepath
            });
            if (lastCommit && lastFileOid !== vFileOid) {
              commits.push(lastCommit);
            }
            lastFileOid = vFileOid;
            lastCommit = commit2;
            isOk = true;
          } catch (e) {
            if (e instanceof NotFoundError) {
              let found = follow && lastFileOid;
              if (found) {
                found = await resolveFileIdInTree({
                  fs,
                  cache,
                  gitdir,
                  oid: commit2.commit.tree,
                  fileId: lastFileOid
                });
                if (found) {
                  if (Array.isArray(found)) {
                    if (lastCommit) {
                      const lastFound = await resolveFileIdInTree({
                        fs,
                        cache,
                        gitdir,
                        oid: lastCommit.commit.tree,
                        fileId: lastFileOid
                      });
                      if (Array.isArray(lastFound)) {
                        found = found.filter((p) => lastFound.indexOf(p) === -1);
                        if (found.length === 1) {
                          found = found[0];
                          filepath = found;
                          if (lastCommit) commits.push(lastCommit);
                        } else {
                          found = false;
                          if (lastCommit) commits.push(lastCommit);
                          break;
                        }
                      }
                    }
                  } else {
                    filepath = found;
                    if (lastCommit) commits.push(lastCommit);
                  }
                }
              }
              if (!found) {
                if (isOk && lastFileOid) {
                  commits.push(lastCommit);
                  if (!force) break;
                }
                if (!force && !follow) throw e;
              }
              lastCommit = commit2;
              isOk = false;
            } else throw e;
          }
        } else {
          commits.push(commit2);
        }
        if (depth !== void 0 && commits.length === depth) {
          endCommit(commit2);
          break;
        }
        if (!shallowCommits.has(commit2.oid)) {
          for (const oid2 of commit2.commit.parent) {
            const commit3 = await _readCommit({ fs, cache, gitdir, oid: oid2 });
            if (!tips.map((commit4) => commit4.oid).includes(commit3.oid)) {
              tips.push(commit3);
            }
          }
        }
        if (tips.length === 0) {
          endCommit(commit2);
        }
        tips.sort((a, b) => compareAge(a.commit, b.commit));
      }
      return commits;
    }
    __name(_log, "_log");
    async function log({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      filepath,
      ref = "HEAD",
      depth,
      since,
      // Date
      force,
      follow,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        return await _log({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          filepath,
          ref,
          depth,
          since,
          force,
          follow
        });
      } catch (err) {
        err.caller = "git.log";
        throw err;
      }
    }
    __name(log, "log");
    async function merge({
      fs: _fs,
      onSign,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ours,
      theirs,
      fastForward: fastForward2 = true,
      fastForwardOnly = false,
      dryRun = false,
      noUpdateBranch = false,
      abortOnConflict = true,
      message,
      author: _author,
      committer: _committer,
      signingKey,
      cache = {},
      mergeDriver,
      allowUnrelatedHistories = false
    }) {
      try {
        assertParameter("fs", _fs);
        if (signingKey) {
          assertParameter("onSign", onSign);
        }
        const fs = new FileSystem(_fs);
        const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
        if (!author && (!fastForwardOnly || !fastForward2)) {
          throw new MissingNameError("author");
        }
        const committer = await normalizeCommitterObject({
          fs,
          gitdir,
          author,
          committer: _committer
        });
        if (!committer && (!fastForwardOnly || !fastForward2)) {
          throw new MissingNameError("committer");
        }
        return await _merge({
          fs,
          cache,
          dir,
          gitdir,
          ours,
          theirs,
          fastForward: fastForward2,
          fastForwardOnly,
          dryRun,
          noUpdateBranch,
          abortOnConflict,
          message,
          author,
          committer,
          signingKey,
          onSign,
          mergeDriver,
          allowUnrelatedHistories
        });
      } catch (err) {
        err.caller = "git.merge";
        throw err;
      }
    }
    __name(merge, "merge");
    var types = {
      commit: 16,
      tree: 32,
      blob: 48,
      tag: 64,
      ofs_delta: 96,
      ref_delta: 112
    };
    async function _pack({
      fs,
      cache,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oids
    }) {
      const hash = new Hash();
      const outputStream = [];
      function write(chunk, enc) {
        const buff = Buffer.from(chunk, enc);
        outputStream.push(buff);
        hash.update(buff);
      }
      __name(write, "write");
      async function writeObject2({ stype, object }) {
        const type = types[stype];
        let length = object.length;
        let multibyte = length > 15 ? 128 : 0;
        const lastFour = length & 15;
        length = length >>> 4;
        let byte = (multibyte | type | lastFour).toString(16);
        write(byte, "hex");
        while (multibyte) {
          multibyte = length > 127 ? 128 : 0;
          byte = multibyte | length & 127;
          write(padHex(2, byte), "hex");
          length = length >>> 7;
        }
        write(Buffer.from(await deflate(object)));
      }
      __name(writeObject2, "writeObject");
      write("PACK");
      write("00000002", "hex");
      write(padHex(8, oids.length), "hex");
      for (const oid of oids) {
        const { type, object } = await _readObject({ fs, cache, gitdir, oid });
        await writeObject2({ write, object, stype: type });
      }
      const digest = hash.digest();
      outputStream.push(digest);
      return outputStream;
    }
    __name(_pack, "_pack");
    async function _packObjects({ fs, cache, gitdir, oids, write }) {
      const buffers = await _pack({ fs, cache, gitdir, oids });
      const packfile = Buffer.from(await collect2(buffers));
      const packfileSha = packfile.slice(-20).toString("hex");
      const filename = `pack-${packfileSha}.pack`;
      if (write) {
        await fs.write(pathBrowserify.join(gitdir, `objects/pack/${filename}`), packfile);
        return { filename };
      }
      return {
        filename,
        packfile: new Uint8Array(packfile)
      };
    }
    __name(_packObjects, "_packObjects");
    async function packObjects({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oids,
      write = false,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oids", oids);
        return await _packObjects({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          oids,
          write
        });
      } catch (err) {
        err.caller = "git.packObjects";
        throw err;
      }
    }
    __name(packObjects, "packObjects");
    async function pull({
      fs: _fs,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      url,
      remote,
      remoteRef,
      prune = false,
      pruneTags = false,
      fastForward: fastForward2 = true,
      fastForwardOnly = false,
      corsProxy,
      singleBranch,
      headers = {},
      author: _author,
      committer: _committer,
      signingKey,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        const fs = new FileSystem(_fs);
        const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
        if (!author) throw new MissingNameError("author");
        const committer = await normalizeCommitterObject({
          fs,
          gitdir,
          author,
          committer: _committer
        });
        if (!committer) throw new MissingNameError("committer");
        return await _pull({
          fs,
          cache,
          http,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          dir,
          gitdir,
          ref,
          url,
          remote,
          remoteRef,
          fastForward: fastForward2,
          fastForwardOnly,
          corsProxy,
          singleBranch,
          headers,
          author,
          committer,
          signingKey,
          prune,
          pruneTags
        });
      } catch (err) {
        err.caller = "git.pull";
        throw err;
      }
    }
    __name(pull, "pull");
    async function listCommitsAndTags({
      fs,
      cache,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      start,
      finish
    }) {
      const shallows = await GitShallowManager.read({ fs, gitdir });
      const startingSet = /* @__PURE__ */ new Set();
      const finishingSet = /* @__PURE__ */ new Set();
      for (const ref of start) {
        startingSet.add(await GitRefManager.resolve({ fs, gitdir, ref }));
      }
      for (const ref of finish) {
        try {
          const oid = await GitRefManager.resolve({ fs, gitdir, ref });
          finishingSet.add(oid);
        } catch (err) {
        }
      }
      const visited = /* @__PURE__ */ new Set();
      async function walk2(oid) {
        visited.add(oid);
        const { type, object } = await _readObject({ fs, cache, gitdir, oid });
        if (type === "tag") {
          const tag2 = GitAnnotatedTag.from(object);
          const commit2 = tag2.headers().object;
          return walk2(commit2);
        }
        if (type !== "commit") {
          throw new ObjectTypeError(oid, type, "commit");
        }
        if (!shallows.has(oid)) {
          const commit2 = GitCommit.from(object);
          const parents = commit2.headers().parent;
          for (oid of parents) {
            if (!finishingSet.has(oid) && !visited.has(oid)) {
              await walk2(oid);
            }
          }
        }
      }
      __name(walk2, "walk");
      for (const oid of startingSet) {
        await walk2(oid);
      }
      return visited;
    }
    __name(listCommitsAndTags, "listCommitsAndTags");
    async function listObjects({
      fs,
      cache,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oids
    }) {
      const visited = /* @__PURE__ */ new Set();
      async function walk2(oid) {
        if (visited.has(oid)) return;
        visited.add(oid);
        const { type, object } = await _readObject({ fs, cache, gitdir, oid });
        if (type === "tag") {
          const tag2 = GitAnnotatedTag.from(object);
          const obj = tag2.headers().object;
          await walk2(obj);
        } else if (type === "commit") {
          const commit2 = GitCommit.from(object);
          const tree = commit2.headers().tree;
          await walk2(tree);
        } else if (type === "tree") {
          const tree = GitTree.from(object);
          for (const entry of tree) {
            if (entry.type === "blob") {
              visited.add(entry.oid);
            }
            if (entry.type === "tree") {
              await walk2(entry.oid);
            }
          }
        }
      }
      __name(walk2, "walk");
      for (const oid of oids) {
        await walk2(oid);
      }
      return visited;
    }
    __name(listObjects, "listObjects");
    async function parseReceivePackResponse(packfile) {
      const result = {};
      let response = "";
      const read = GitPktLine.streamReader(packfile);
      let line = await read();
      while (line !== true) {
        if (line !== null) response += line.toString("utf8") + "\n";
        line = await read();
      }
      const lines = response.toString("utf8").split("\n");
      line = lines.shift();
      if (!line.startsWith("unpack ")) {
        throw new ParseError('unpack ok" or "unpack [error message]', line);
      }
      result.ok = line === "unpack ok";
      if (!result.ok) {
        result.error = line.slice("unpack ".length);
      }
      result.refs = {};
      for (const line2 of lines) {
        if (line2.trim() === "") continue;
        const status2 = line2.slice(0, 2);
        const refAndMessage = line2.slice(3);
        let space = refAndMessage.indexOf(" ");
        if (space === -1) space = refAndMessage.length;
        const ref = refAndMessage.slice(0, space);
        const error = refAndMessage.slice(space + 1);
        result.refs[ref] = {
          ok: status2 === "ok",
          error
        };
      }
      return result;
    }
    __name(parseReceivePackResponse, "parseReceivePackResponse");
    async function writeReceivePackRequest({
      capabilities = [],
      triplets = []
    }) {
      const packstream = [];
      let capsFirstLine = `\0 ${capabilities.join(" ")}`;
      for (const trip of triplets) {
        packstream.push(
          GitPktLine.encode(
            `${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}
`
          )
        );
        capsFirstLine = "";
      }
      packstream.push(GitPktLine.flush());
      return packstream;
    }
    __name(writeReceivePackRequest, "writeReceivePackRequest");
    async function _push({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      onPrePush,
      gitdir,
      ref: _ref,
      remoteRef: _remoteRef,
      remote,
      url: _url,
      force = false,
      delete: _delete = false,
      corsProxy,
      headers = {}
    }) {
      const ref = _ref || await _currentBranch({ fs, gitdir });
      if (typeof ref === "undefined") {
        throw new MissingParameterError("ref");
      }
      const config = await GitConfigManager.get({ fs, gitdir });
      remote = remote || await config.get(`branch.${ref}.pushRemote`) || await config.get("remote.pushDefault") || await config.get(`branch.${ref}.remote`) || "origin";
      const url = _url || await config.get(`remote.${remote}.pushurl`) || await config.get(`remote.${remote}.url`);
      if (typeof url === "undefined") {
        throw new MissingParameterError("remote OR url");
      }
      const remoteRef = _remoteRef || await config.get(`branch.${ref}.merge`);
      if (typeof url === "undefined") {
        throw new MissingParameterError("remoteRef");
      }
      if (corsProxy === void 0) {
        corsProxy = await config.get("http.corsProxy");
      }
      const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
      const oid = _delete ? "0000000000000000000000000000000000000000" : await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
      const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
      const httpRemote = await GitRemoteHTTP2.discover({
        http,
        onAuth,
        onAuthSuccess,
        onAuthFailure,
        corsProxy,
        service: "git-receive-pack",
        url,
        headers,
        protocolVersion: 1
      });
      const auth = httpRemote.auth;
      let fullRemoteRef;
      if (!remoteRef) {
        fullRemoteRef = fullRef;
      } else {
        try {
          fullRemoteRef = await GitRefManager.expandAgainstMap({
            ref: remoteRef,
            map: httpRemote.refs
          });
        } catch (err) {
          if (err instanceof NotFoundError) {
            fullRemoteRef = remoteRef.startsWith("refs/") ? remoteRef : `refs/heads/${remoteRef}`;
          } else {
            throw err;
          }
        }
      }
      const oldoid = httpRemote.refs.get(fullRemoteRef) || "0000000000000000000000000000000000000000";
      if (onPrePush) {
        const hookCancel = await onPrePush({
          remote,
          url,
          localRef: { ref: _delete ? "(delete)" : fullRef, oid },
          remoteRef: { ref: fullRemoteRef, oid: oldoid }
        });
        if (!hookCancel) throw new UserCanceledError();
      }
      const thinPack = !httpRemote.capabilities.has("no-thin");
      let objects = /* @__PURE__ */ new Set();
      if (!_delete) {
        const finish = [...httpRemote.refs.values()];
        let skipObjects = /* @__PURE__ */ new Set();
        if (oldoid !== "0000000000000000000000000000000000000000") {
          const mergebase = await _findMergeBase({
            fs,
            cache,
            gitdir,
            oids: [oid, oldoid]
          });
          for (const oid2 of mergebase) finish.push(oid2);
          if (thinPack) {
            skipObjects = await listObjects({ fs, cache, gitdir, oids: mergebase });
          }
        }
        if (!finish.includes(oid)) {
          const commits = await listCommitsAndTags({
            fs,
            cache,
            gitdir,
            start: [oid],
            finish
          });
          objects = await listObjects({ fs, cache, gitdir, oids: commits });
        }
        if (thinPack) {
          try {
            const ref2 = await GitRefManager.resolve({
              fs,
              gitdir,
              ref: `refs/remotes/${remote}/HEAD`,
              depth: 2
            });
            const { oid: oid2 } = await GitRefManager.resolveAgainstMap({
              ref: ref2.replace(`refs/remotes/${remote}/`, ""),
              fullref: ref2,
              map: httpRemote.refs
            });
            const oids = [oid2];
            for (const oid3 of await listObjects({ fs, cache, gitdir, oids })) {
              skipObjects.add(oid3);
            }
          } catch (e) {
          }
          for (const oid2 of skipObjects) {
            objects.delete(oid2);
          }
        }
        if (oid === oldoid) force = true;
        if (!force) {
          if (fullRef.startsWith("refs/tags") && oldoid !== "0000000000000000000000000000000000000000") {
            throw new PushRejectedError("tag-exists");
          }
          if (oid !== "0000000000000000000000000000000000000000" && oldoid !== "0000000000000000000000000000000000000000" && !await _isDescendent({
            fs,
            cache,
            gitdir,
            oid,
            ancestor: oldoid,
            depth: -1
          })) {
            throw new PushRejectedError("not-fast-forward");
          }
        }
      }
      const capabilities = filterCapabilities(
        [...httpRemote.capabilities],
        ["report-status", "side-band-64k", `agent=${pkg.agent}`]
      );
      const packstream1 = await writeReceivePackRequest({
        capabilities,
        triplets: [{ oldoid, oid, fullRef: fullRemoteRef }]
      });
      const packstream2 = _delete ? [] : await _pack({
        fs,
        cache,
        gitdir,
        oids: [...objects]
      });
      const res = await GitRemoteHTTP2.connect({
        http,
        onProgress,
        corsProxy,
        service: "git-receive-pack",
        url,
        auth,
        headers,
        body: [...packstream1, ...packstream2]
      });
      const { packfile, progress } = await GitSideBand.demux(res.body);
      if (onMessage) {
        const lines = splitLines(progress);
        forAwait2(lines, async (line) => {
          await onMessage(line);
        });
      }
      const result = await parseReceivePackResponse(packfile);
      if (res.headers) {
        result.headers = res.headers;
      }
      if (remote && result.ok && result.refs[fullRemoteRef].ok && !fullRef.startsWith("refs/tags")) {
        const ref2 = `refs/remotes/${remote}/${fullRemoteRef.replace(
          "refs/heads",
          ""
        )}`;
        if (_delete) {
          await GitRefManager.deleteRef({ fs, gitdir, ref: ref2 });
        } else {
          await GitRefManager.writeRef({ fs, gitdir, ref: ref2, value: oid });
        }
      }
      if (result.ok && Object.values(result.refs).every((result2) => result2.ok)) {
        return result;
      } else {
        const prettyDetails = Object.entries(result.refs).filter(([k, v]) => !v.ok).map(([k, v]) => `
  - ${k}: ${v.error}`).join("");
        throw new GitPushError(prettyDetails, result);
      }
    }
    __name(_push, "_push");
    async function push({
      fs,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      onPrePush,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      remoteRef,
      remote = "origin",
      url,
      force = false,
      delete: _delete = false,
      corsProxy,
      headers = {},
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("http", http);
        assertParameter("gitdir", gitdir);
        return await _push({
          fs: new FileSystem(fs),
          cache,
          http,
          onProgress,
          onMessage,
          onAuth,
          onAuthSuccess,
          onAuthFailure,
          onPrePush,
          gitdir,
          ref,
          remoteRef,
          remote,
          url,
          force,
          delete: _delete,
          corsProxy,
          headers
        });
      } catch (err) {
        err.caller = "git.push";
        throw err;
      }
    }
    __name(push, "push");
    async function resolveBlob({ fs, cache, gitdir, oid }) {
      const { type, object } = await _readObject({ fs, cache, gitdir, oid });
      if (type === "tag") {
        oid = GitAnnotatedTag.from(object).parse().object;
        return resolveBlob({ fs, cache, gitdir, oid });
      }
      if (type !== "blob") {
        throw new ObjectTypeError(oid, type, "blob");
      }
      return { oid, blob: new Uint8Array(object) };
    }
    __name(resolveBlob, "resolveBlob");
    async function _readBlob({
      fs,
      cache,
      gitdir,
      oid,
      filepath = void 0
    }) {
      if (filepath !== void 0) {
        oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
      }
      const blob = await resolveBlob({
        fs,
        cache,
        gitdir,
        oid
      });
      return blob;
    }
    __name(_readBlob, "_readBlob");
    async function readBlob({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oid,
      filepath,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        return await _readBlob({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          oid,
          filepath
        });
      } catch (err) {
        err.caller = "git.readBlob";
        throw err;
      }
    }
    __name(readBlob, "readBlob");
    async function readCommit({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oid,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        return await _readCommit({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          oid
        });
      } catch (err) {
        err.caller = "git.readCommit";
        throw err;
      }
    }
    __name(readCommit, "readCommit");
    async function _readNote({
      fs,
      cache,
      gitdir,
      ref = "refs/notes/commits",
      oid
    }) {
      const parent = await GitRefManager.resolve({ gitdir, fs, ref });
      const { blob } = await _readBlob({
        fs,
        cache,
        gitdir,
        oid: parent,
        filepath: oid
      });
      return blob;
    }
    __name(_readNote, "_readNote");
    async function readNote({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref = "refs/notes/commits",
      oid,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        assertParameter("oid", oid);
        return await _readNote({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          ref,
          oid
        });
      } catch (err) {
        err.caller = "git.readNote";
        throw err;
      }
    }
    __name(readNote, "readNote");
    async function readObject({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oid,
      format = "parsed",
      filepath = void 0,
      encoding = void 0,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        const fs = new FileSystem(_fs);
        if (filepath !== void 0) {
          oid = await resolveFilepath({
            fs,
            cache,
            gitdir,
            oid,
            filepath
          });
        }
        const _format = format === "parsed" ? "content" : format;
        const result = await _readObject({
          fs,
          cache,
          gitdir,
          oid,
          format: _format
        });
        result.oid = oid;
        if (format === "parsed") {
          result.format = "parsed";
          switch (result.type) {
            case "commit":
              result.object = GitCommit.from(result.object).parse();
              break;
            case "tree":
              result.object = GitTree.from(result.object).entries();
              break;
            case "blob":
              if (encoding) {
                result.object = result.object.toString(encoding);
              } else {
                result.object = new Uint8Array(result.object);
                result.format = "content";
              }
              break;
            case "tag":
              result.object = GitAnnotatedTag.from(result.object).parse();
              break;
            default:
              throw new ObjectTypeError(
                result.oid,
                result.type,
                "blob|commit|tag|tree"
              );
          }
        } else if (result.format === "deflated" || result.format === "wrapped") {
          result.type = result.format;
        }
        return result;
      } catch (err) {
        err.caller = "git.readObject";
        throw err;
      }
    }
    __name(readObject, "readObject");
    async function _readTag({ fs, cache, gitdir, oid }) {
      const { type, object } = await _readObject({
        fs,
        cache,
        gitdir,
        oid,
        format: "content"
      });
      if (type !== "tag") {
        throw new ObjectTypeError(oid, type, "tag");
      }
      const tag2 = GitAnnotatedTag.from(object);
      const result = {
        oid,
        tag: tag2.parse(),
        payload: tag2.payload()
      };
      return result;
    }
    __name(_readTag, "_readTag");
    async function readTag({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oid,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        return await _readTag({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          oid
        });
      } catch (err) {
        err.caller = "git.readTag";
        throw err;
      }
    }
    __name(readTag, "readTag");
    async function readTree({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      oid,
      filepath = void 0,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        return await _readTree({
          fs: new FileSystem(fs),
          cache,
          gitdir,
          oid,
          filepath
        });
      } catch (err) {
        err.caller = "git.readTree";
        throw err;
      }
    }
    __name(readTree, "readTree");
    async function remove({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      filepath,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        await GitIndexManager.acquire(
          { fs: new FileSystem(_fs), gitdir, cache },
          async function(index3) {
            index3.delete({ filepath });
          }
        );
      } catch (err) {
        err.caller = "git.remove";
        throw err;
      }
    }
    __name(remove, "remove");
    async function _removeNote({
      fs,
      cache,
      onSign,
      gitdir,
      ref = "refs/notes/commits",
      oid,
      author,
      committer,
      signingKey
    }) {
      let parent;
      try {
        parent = await GitRefManager.resolve({ gitdir, fs, ref });
      } catch (err) {
        if (!(err instanceof NotFoundError)) {
          throw err;
        }
      }
      const result = await _readTree({
        fs,
        gitdir,
        oid: parent || "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
      });
      let tree = result.tree;
      tree = tree.filter((entry) => entry.path !== oid);
      const treeOid = await _writeTree({
        fs,
        gitdir,
        tree
      });
      const commitOid = await _commit({
        fs,
        cache,
        onSign,
        gitdir,
        ref,
        tree: treeOid,
        parent: parent && [parent],
        message: `Note removed by 'isomorphic-git removeNote'
`,
        author,
        committer,
        signingKey
      });
      return commitOid;
    }
    __name(_removeNote, "_removeNote");
    async function removeNote({
      fs: _fs,
      onSign,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref = "refs/notes/commits",
      oid,
      author: _author,
      committer: _committer,
      signingKey,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("oid", oid);
        const fs = new FileSystem(_fs);
        const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
        if (!author) throw new MissingNameError("author");
        const committer = await normalizeCommitterObject({
          fs,
          gitdir,
          author,
          committer: _committer
        });
        if (!committer) throw new MissingNameError("committer");
        return await _removeNote({
          fs,
          cache,
          onSign,
          gitdir,
          ref,
          oid,
          author,
          committer,
          signingKey
        });
      } catch (err) {
        err.caller = "git.removeNote";
        throw err;
      }
    }
    __name(removeNote, "removeNote");
    async function _renameBranch({
      fs,
      gitdir,
      oldref,
      ref,
      checkout: checkout2 = false
    }) {
      if (!validRef(ref, true)) {
        throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));
      }
      if (!validRef(oldref, true)) {
        throw new InvalidRefNameError(oldref, cleanGitRef.clean(oldref));
      }
      const fulloldref = `refs/heads/${oldref}`;
      const fullnewref = `refs/heads/${ref}`;
      const newexist = await GitRefManager.exists({ fs, gitdir, ref: fullnewref });
      if (newexist) {
        throw new AlreadyExistsError("branch", ref, false);
      }
      const value = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: fulloldref,
        depth: 1
      });
      await GitRefManager.writeRef({ fs, gitdir, ref: fullnewref, value });
      await GitRefManager.deleteRef({ fs, gitdir, ref: fulloldref });
      const fullCurrentBranchRef = await _currentBranch({
        fs,
        gitdir,
        fullname: true
      });
      const isCurrentBranch = fullCurrentBranchRef === fulloldref;
      if (checkout2 || isCurrentBranch) {
        await GitRefManager.writeSymbolicRef({
          fs,
          gitdir,
          ref: "HEAD",
          value: fullnewref
        });
      }
    }
    __name(_renameBranch, "_renameBranch");
    async function renameBranch({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      oldref,
      checkout: checkout2 = false
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        assertParameter("oldref", oldref);
        return await _renameBranch({
          fs: new FileSystem(fs),
          gitdir,
          ref,
          oldref,
          checkout: checkout2
        });
      } catch (err) {
        err.caller = "git.renameBranch";
        throw err;
      }
    }
    __name(renameBranch, "renameBranch");
    async function hashObject$1({ gitdir, type, object }) {
      return shasum(GitObject.wrap({ type, object }));
    }
    __name(hashObject$1, "hashObject$1");
    async function resetIndex({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      filepath,
      ref,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        const fs = new FileSystem(_fs);
        let oid;
        let workdirOid;
        try {
          oid = await GitRefManager.resolve({ fs, gitdir, ref: ref || "HEAD" });
        } catch (e) {
          if (ref) {
            throw e;
          }
        }
        if (oid) {
          try {
            oid = await resolveFilepath({
              fs,
              cache,
              gitdir,
              oid,
              filepath
            });
          } catch (e) {
            oid = null;
          }
        }
        let stats = {
          ctime: /* @__PURE__ */ new Date(0),
          mtime: /* @__PURE__ */ new Date(0),
          dev: 0,
          ino: 0,
          mode: 0,
          uid: 0,
          gid: 0,
          size: 0
        };
        const object = dir && await fs.read(pathBrowserify.join(dir, filepath));
        if (object) {
          workdirOid = await hashObject$1({
            gitdir,
            type: "blob",
            object
          });
          if (oid === workdirOid) {
            stats = await fs.lstat(pathBrowserify.join(dir, filepath));
          }
        }
        await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index3) {
          index3.delete({ filepath });
          if (oid) {
            index3.insert({ filepath, stats, oid });
          }
        });
      } catch (err) {
        err.caller = "git.reset";
        throw err;
      }
    }
    __name(resetIndex, "resetIndex");
    async function resolveRef({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      depth
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        const oid = await GitRefManager.resolve({
          fs: new FileSystem(fs),
          gitdir,
          ref,
          depth
        });
        return oid;
      } catch (err) {
        err.caller = "git.resolveRef";
        throw err;
      }
    }
    __name(resolveRef, "resolveRef");
    async function setConfig({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      path: path6,
      value,
      append = false
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("path", path6);
        const fs = new FileSystem(_fs);
        const config = await GitConfigManager.get({ fs, gitdir });
        if (append) {
          await config.append(path6, value);
        } else {
          await config.set(path6, value);
        }
        await GitConfigManager.save({ fs, gitdir, config });
      } catch (err) {
        err.caller = "git.setConfig";
        throw err;
      }
    }
    __name(setConfig, "setConfig");
    async function _writeCommit({ fs, gitdir, commit: commit2 }) {
      const object = GitCommit.from(commit2).toObject();
      const oid = await _writeObject({
        fs,
        gitdir,
        type: "commit",
        object,
        format: "content"
      });
      return oid;
    }
    __name(_writeCommit, "_writeCommit");
    var _GitRefStash = class _GitRefStash {
      // constructor removed
      static get timezoneOffsetForRefLogEntry() {
        const offsetMinutes = (/* @__PURE__ */ new Date()).getTimezoneOffset();
        const offsetHours = Math.abs(Math.floor(offsetMinutes / 60));
        const offsetMinutesFormatted = Math.abs(offsetMinutes % 60).toString().padStart(2, "0");
        const sign = offsetMinutes > 0 ? "-" : "+";
        return `${sign}${offsetHours.toString().padStart(2, "0")}${offsetMinutesFormatted}`;
      }
      static createStashReflogEntry(author, stashCommit, message) {
        const nameNoSpace = author.name.replace(/\s/g, "");
        const z40 = "0000000000000000000000000000000000000000";
        const timestamp = Math.floor(Date.now() / 1e3);
        const timezoneOffset = _GitRefStash.timezoneOffsetForRefLogEntry;
        return `${z40} ${stashCommit} ${nameNoSpace} ${author.email} ${timestamp} ${timezoneOffset}	${message}
`;
      }
      static getStashReflogEntry(reflogString, parsed = false) {
        const reflogLines = reflogString.split("\n");
        const entries = reflogLines.filter((l) => l).reverse().map(
          (line, idx) => parsed ? `stash@{${idx}}: ${line.split("	")[1]}` : line
        );
        return entries;
      }
    };
    __name(_GitRefStash, "GitRefStash");
    var GitRefStash = _GitRefStash;
    var _TreeMap = {
      stage: STAGE,
      workdir: WORKDIR
    };
    var lock$3;
    async function acquireLock$1(ref, callback) {
      if (lock$3 === void 0) lock$3 = new AsyncLock();
      return lock$3.acquire(ref, callback);
    }
    __name(acquireLock$1, "acquireLock$1");
    async function checkAndWriteBlob(fs, gitdir, dir, filepath, oid = null) {
      const currentFilepath = pathBrowserify.join(dir, filepath);
      const stats = await fs.lstat(currentFilepath);
      if (!stats) throw new NotFoundError(currentFilepath);
      if (stats.isDirectory())
        throw new InternalError(
          `${currentFilepath}: file expected, but found directory`
        );
      const objContent = oid ? await readObjectLoose({ fs, gitdir, oid }) : void 0;
      let retOid = objContent ? oid : void 0;
      if (!objContent) {
        await acquireLock$1({ fs, gitdir, currentFilepath }, async () => {
          const object = stats.isSymbolicLink() ? await fs.readlink(currentFilepath).then(posixifyPathBuffer) : await fs.read(currentFilepath);
          if (object === null) throw new NotFoundError(currentFilepath);
          retOid = await _writeObject({ fs, gitdir, type: "blob", object });
        });
      }
      return retOid;
    }
    __name(checkAndWriteBlob, "checkAndWriteBlob");
    async function processTreeEntries({ fs, dir, gitdir, entries }) {
      async function processTreeEntry(entry) {
        if (entry.type === "tree") {
          if (!entry.oid) {
            const children = await Promise.all(entry.children.map(processTreeEntry));
            entry.oid = await _writeTree({
              fs,
              gitdir,
              tree: children
            });
            entry.mode = 16384;
          }
        } else if (entry.type === "blob") {
          entry.oid = await checkAndWriteBlob(
            fs,
            gitdir,
            dir,
            entry.path,
            entry.oid
          );
          entry.mode = 33188;
        }
        entry.path = entry.path.split("/").pop();
        return entry;
      }
      __name(processTreeEntry, "processTreeEntry");
      return Promise.all(entries.map(processTreeEntry));
    }
    __name(processTreeEntries, "processTreeEntries");
    async function writeTreeChanges({
      fs,
      dir,
      gitdir,
      treePair
      // [TREE({ ref: 'HEAD' }), 'STAGE'] would be the equivalent of `git write-tree`
    }) {
      const isStage = treePair[1] === "stage";
      const trees = treePair.map((t) => typeof t === "string" ? _TreeMap[t]() : t);
      const changedEntries = [];
      const map = /* @__PURE__ */ __name(async (filepath, [head, stage]) => {
        if (filepath === "." || await GitIgnoreManager.isIgnored({ fs, dir, gitdir, filepath })) {
          return;
        }
        if (stage) {
          if (!head || await head.oid() !== await stage.oid() && await stage.oid() !== void 0) {
            changedEntries.push([head, stage]);
          }
          return {
            mode: await stage.mode(),
            path: filepath,
            oid: await stage.oid(),
            type: await stage.type()
          };
        }
      }, "map");
      const reduce = /* @__PURE__ */ __name(async (parent, children) => {
        children = children.filter(Boolean);
        if (!parent) {
          return children.length > 0 ? children : void 0;
        } else {
          parent.children = children;
          return parent;
        }
      }, "reduce");
      const iterate = /* @__PURE__ */ __name(async (walk2, children) => {
        const filtered = [];
        for (const child of children) {
          const [head, stage] = child;
          if (isStage) {
            if (stage) {
              if (await fs.exists(`${dir}/${stage.toString()}`)) {
                filtered.push(child);
              } else {
                changedEntries.push([null, stage]);
              }
            }
          } else if (head) {
            if (!stage) {
              changedEntries.push([head, null]);
            } else {
              filtered.push(child);
            }
          }
        }
        return filtered.length ? Promise.all(filtered.map(walk2)) : [];
      }, "iterate");
      const entries = await _walk({
        fs,
        cache: {},
        dir,
        gitdir,
        trees,
        map,
        reduce,
        iterate
      });
      if (changedEntries.length === 0 || entries.length === 0) {
        return null;
      }
      const processedEntries = await processTreeEntries({
        fs,
        dir,
        gitdir,
        entries
      });
      const treeEntries = processedEntries.filter(Boolean).map((entry) => ({
        mode: entry.mode,
        path: entry.path,
        oid: entry.oid,
        type: entry.type
      }));
      return _writeTree({ fs, gitdir, tree: treeEntries });
    }
    __name(writeTreeChanges, "writeTreeChanges");
    async function applyTreeChanges({
      fs,
      dir,
      gitdir,
      stashCommit,
      parentCommit,
      wasStaged
    }) {
      const dirRemoved = [];
      const stageUpdated = [];
      const ops = await _walk({
        fs,
        cache: {},
        dir,
        gitdir,
        trees: [TREE({ ref: parentCommit }), TREE({ ref: stashCommit })],
        map: /* @__PURE__ */ __name(async (filepath, [parent, stash2]) => {
          if (filepath === "." || await GitIgnoreManager.isIgnored({ fs, dir, gitdir, filepath })) {
            return;
          }
          const type = stash2 ? await stash2.type() : await parent.type();
          if (type !== "tree" && type !== "blob") {
            return;
          }
          if (!stash2 && parent) {
            const method = type === "tree" ? "rmdir" : "rm";
            if (type === "tree") dirRemoved.push(filepath);
            if (type === "blob" && wasStaged)
              stageUpdated.push({ filepath, oid: await parent.oid() });
            return { method, filepath };
          }
          const oid = await stash2.oid();
          if (!parent || await parent.oid() !== oid) {
            if (type === "tree") {
              return { method: "mkdir", filepath };
            } else {
              if (wasStaged)
                stageUpdated.push({
                  filepath,
                  oid,
                  stats: await fs.lstat(pathBrowserify.join(dir, filepath))
                });
              return {
                method: "write",
                filepath,
                oid
              };
            }
          }
        }, "map")
      });
      await acquireLock$1({ fs, gitdir, dirRemoved, ops }, async () => {
        for (const op of ops) {
          const currentFilepath = pathBrowserify.join(dir, op.filepath);
          switch (op.method) {
            case "rmdir":
              await fs.rmdir(currentFilepath);
              break;
            case "mkdir":
              await fs.mkdir(currentFilepath);
              break;
            case "rm":
              await fs.rm(currentFilepath);
              break;
            case "write":
              if (!dirRemoved.some(
                (removedDir) => currentFilepath.startsWith(removedDir)
              )) {
                const { object } = await _readObject({
                  fs,
                  cache: {},
                  gitdir,
                  oid: op.oid
                });
                if (await fs.exists(currentFilepath)) {
                  await fs.rm(currentFilepath);
                }
                await fs.write(currentFilepath, object);
              }
              break;
          }
        }
      });
      await GitIndexManager.acquire({ fs, gitdir, cache: {} }, async (index3) => {
        stageUpdated.forEach(({ filepath, stats, oid }) => {
          index3.insert({ filepath, stats, oid });
        });
      });
    }
    __name(applyTreeChanges, "applyTreeChanges");
    var _GitStashManager = class _GitStashManager {
      /**
       * Creates an instance of GitStashManager.
       *
       * @param {Object} args
       * @param {FSClient} args.fs - A file system implementation.
       * @param {string} args.dir - The working directory.
       * @param {string}[args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
       */
      constructor({ fs, dir, gitdir = pathBrowserify.join(dir, ".git") }) {
        Object.assign(this, {
          fs,
          dir,
          gitdir,
          _author: null
        });
      }
      /**
       * Gets the reference name for the stash.
       *
       * @returns {string} - The stash reference name.
       */
      static get refStash() {
        return "refs/stash";
      }
      /**
       * Gets the reference name for the stash reflogs.
       *
       * @returns {string} - The stash reflogs reference name.
       */
      static get refLogsStash() {
        return "logs/refs/stash";
      }
      /**
       * Gets the file path for the stash reference.
       *
       * @returns {string} - The file path for the stash reference.
       */
      get refStashPath() {
        return pathBrowserify.join(this.gitdir, _GitStashManager.refStash);
      }
      /**
       * Gets the file path for the stash reflogs.
       *
       * @returns {string} - The file path for the stash reflogs.
       */
      get refLogsStashPath() {
        return pathBrowserify.join(this.gitdir, _GitStashManager.refLogsStash);
      }
      /**
       * Retrieves the author information for the stash.
       *
       * @returns {Promise<Object>} - The author object.
       * @throws {MissingNameError} - If the author name is missing.
       */
      async getAuthor() {
        if (!this._author) {
          this._author = await normalizeAuthorObject({
            fs: this.fs,
            gitdir: this.gitdir,
            author: {}
          });
          if (!this._author) throw new MissingNameError("author");
        }
        return this._author;
      }
      /**
       * Gets the SHA of a stash entry by its index.
       *
       * @param {number} refIdx - The index of the stash entry.
       * @param {string[]} [stashEntries] - Optional preloaded stash entries.
       * @returns {Promise<string|null>} - The SHA of the stash entry or `null` if not found.
       */
      async getStashSHA(refIdx, stashEntries) {
        if (!await this.fs.exists(this.refStashPath)) {
          return null;
        }
        const entries = stashEntries || await this.readStashReflogs({ parsed: false });
        return entries[refIdx].split(" ")[1];
      }
      /**
       * Writes a stash commit to the repository.
       *
       * @param {Object} args
       * @param {string} args.message - The commit message.
       * @param {string} args.tree - The tree object ID.
       * @param {string[]} args.parent - The parent commit object IDs.
       * @returns {Promise<string>} - The object ID of the written commit.
       */
      async writeStashCommit({ message, tree, parent }) {
        return _writeCommit({
          fs: this.fs,
          gitdir: this.gitdir,
          commit: {
            message,
            tree,
            parent,
            author: await this.getAuthor(),
            committer: await this.getAuthor()
          }
        });
      }
      /**
       * Reads a stash commit by its index.
       *
       * @param {number} refIdx - The index of the stash entry.
       * @returns {Promise<Object>} - The stash commit object.
       * @throws {InvalidRefNameError} - If the index is invalid.
       */
      async readStashCommit(refIdx) {
        const stashEntries = await this.readStashReflogs({ parsed: false });
        if (refIdx !== 0) {
          if (refIdx < 0 || refIdx > stashEntries.length - 1) {
            throw new InvalidRefNameError(
              `stash@${refIdx}`,
              "number that is in range of [0, num of stash pushed]"
            );
          }
        }
        const stashSHA = await this.getStashSHA(refIdx, stashEntries);
        if (!stashSHA) {
          return {};
        }
        return _readCommit({
          fs: this.fs,
          cache: {},
          gitdir: this.gitdir,
          oid: stashSHA
        });
      }
      /**
       * Writes a stash reference to the repository.
       *
       * @param {string} stashCommit - The object ID of the stash commit.
       * @returns {Promise<void>}
       */
      async writeStashRef(stashCommit) {
        return GitRefManager.writeRef({
          fs: this.fs,
          gitdir: this.gitdir,
          ref: _GitStashManager.refStash,
          value: stashCommit
        });
      }
      /**
       * Writes a reflog entry for a stash commit.
       *
       * @param {Object} args
       * @param {string} args.stashCommit - The object ID of the stash commit.
       * @param {string} args.message - The reflog message.
       * @returns {Promise<void>}
       */
      async writeStashReflogEntry({ stashCommit, message }) {
        const author = await this.getAuthor();
        const entry = GitRefStash.createStashReflogEntry(
          author,
          stashCommit,
          message
        );
        const filepath = this.refLogsStashPath;
        await acquireLock$1({ filepath, entry }, async () => {
          const appendTo = await this.fs.exists(filepath) ? await this.fs.read(filepath, "utf8") : "";
          await this.fs.write(filepath, appendTo + entry, "utf8");
        });
      }
      /**
       * Reads the stash reflogs.
       *
       * @param {Object} args
       * @param {boolean} [args.parsed=false] - Whether to parse the reflog entries.
       * @returns {Promise<string[]|Object[]>} - The reflog entries as strings or parsed objects.
       */
      async readStashReflogs({ parsed = false }) {
        if (!await this.fs.exists(this.refLogsStashPath)) {
          return [];
        }
        const reflogString = await this.fs.read(this.refLogsStashPath, "utf8");
        return GitRefStash.getStashReflogEntry(reflogString, parsed);
      }
    };
    __name(_GitStashManager, "GitStashManager");
    var GitStashManager = _GitStashManager;
    async function _createStashCommit({ fs, dir, gitdir, message = "" }) {
      const stashMgr = new GitStashManager({ fs, dir, gitdir });
      await stashMgr.getAuthor();
      const branch2 = await _currentBranch({
        fs,
        gitdir,
        fullname: false
      });
      const headCommit = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: "HEAD"
      });
      const headCommitObj = await readCommit({ fs, dir, gitdir, oid: headCommit });
      const headMsg = headCommitObj.commit.message;
      const stashCommitParents = [headCommit];
      let stashCommitTree = null;
      let workDirCompareBase = TREE({ ref: "HEAD" });
      const indexTree = await writeTreeChanges({
        fs,
        dir,
        gitdir,
        treePair: [TREE({ ref: "HEAD" }), "stage"]
      });
      if (indexTree) {
        const stashCommitOne = await stashMgr.writeStashCommit({
          message: `stash-Index: WIP on ${branch2} - ${(/* @__PURE__ */ new Date()).toISOString()}`,
          tree: indexTree,
          parent: stashCommitParents
        });
        stashCommitParents.push(stashCommitOne);
        stashCommitTree = indexTree;
        workDirCompareBase = STAGE();
      }
      const workingTree = await writeTreeChanges({
        fs,
        dir,
        gitdir,
        treePair: [workDirCompareBase, "workdir"]
      });
      if (workingTree) {
        const workingHeadCommit = await stashMgr.writeStashCommit({
          message: `stash-WorkDir: WIP on ${branch2} - ${(/* @__PURE__ */ new Date()).toISOString()}`,
          tree: workingTree,
          parent: [stashCommitParents[stashCommitParents.length - 1]]
        });
        stashCommitParents.push(workingHeadCommit);
        stashCommitTree = workingTree;
      }
      if (!stashCommitTree || !indexTree && !workingTree) {
        throw new NotFoundError("changes, nothing to stash");
      }
      const stashMsg = (message.trim() || `WIP on ${branch2}`) + `: ${headCommit.substring(0, 7)} ${headMsg}`;
      const stashCommit = await stashMgr.writeStashCommit({
        message: stashMsg,
        tree: stashCommitTree,
        parent: stashCommitParents
      });
      return { stashCommit, stashMsg, branch: branch2, stashMgr };
    }
    __name(_createStashCommit, "_createStashCommit");
    async function _stashPush({ fs, dir, gitdir, message = "" }) {
      const { stashCommit, stashMsg, branch: branch2, stashMgr } = await _createStashCommit({
        fs,
        dir,
        gitdir,
        message
      });
      await stashMgr.writeStashRef(stashCommit);
      await stashMgr.writeStashReflogEntry({
        stashCommit,
        message: stashMsg
      });
      await checkout({
        fs,
        dir,
        gitdir,
        ref: branch2,
        track: false,
        force: true
        // force checkout to discard changes
      });
      return stashCommit;
    }
    __name(_stashPush, "_stashPush");
    async function _stashCreate({ fs, dir, gitdir, message = "" }) {
      const { stashCommit } = await _createStashCommit({
        fs,
        dir,
        gitdir,
        message
      });
      return stashCommit;
    }
    __name(_stashCreate, "_stashCreate");
    async function _stashApply({ fs, dir, gitdir, refIdx = 0 }) {
      const stashMgr = new GitStashManager({ fs, dir, gitdir });
      const stashCommit = await stashMgr.readStashCommit(refIdx);
      const { parent: stashParents = null } = stashCommit.commit ? stashCommit.commit : {};
      if (!stashParents || !Array.isArray(stashParents)) {
        return;
      }
      for (let i = 0; i < stashParents.length - 1; i++) {
        const applyingCommit = await _readCommit({
          fs,
          cache: {},
          gitdir,
          oid: stashParents[i + 1]
        });
        const wasStaged = applyingCommit.commit.message.startsWith("stash-Index");
        await applyTreeChanges({
          fs,
          dir,
          gitdir,
          stashCommit: stashParents[i + 1],
          parentCommit: stashParents[i],
          wasStaged
        });
      }
    }
    __name(_stashApply, "_stashApply");
    async function _stashDrop({ fs, dir, gitdir, refIdx = 0 }) {
      const stashMgr = new GitStashManager({ fs, dir, gitdir });
      const stashCommit = await stashMgr.readStashCommit(refIdx);
      if (!stashCommit.commit) {
        return;
      }
      const stashRefPath = stashMgr.refStashPath;
      await acquireLock$1(stashRefPath, async () => {
        if (await fs.exists(stashRefPath)) {
          await fs.rm(stashRefPath);
        }
      });
      const reflogEntries = await stashMgr.readStashReflogs({ parsed: false });
      if (!reflogEntries.length) {
        return;
      }
      reflogEntries.splice(refIdx, 1);
      const stashReflogPath = stashMgr.refLogsStashPath;
      await acquireLock$1({ reflogEntries, stashReflogPath, stashMgr }, async () => {
        if (reflogEntries.length) {
          await fs.write(
            stashReflogPath,
            reflogEntries.reverse().join("\n") + "\n",
            "utf8"
          );
          const lastStashCommit = reflogEntries[reflogEntries.length - 1].split(
            " "
          )[1];
          await stashMgr.writeStashRef(lastStashCommit);
        } else {
          await fs.rm(stashReflogPath);
        }
      });
    }
    __name(_stashDrop, "_stashDrop");
    async function _stashList({ fs, dir, gitdir }) {
      const stashMgr = new GitStashManager({ fs, dir, gitdir });
      return stashMgr.readStashReflogs({ parsed: true });
    }
    __name(_stashList, "_stashList");
    async function _stashClear({ fs, dir, gitdir }) {
      const stashMgr = new GitStashManager({ fs, dir, gitdir });
      const stashRefPath = [stashMgr.refStashPath, stashMgr.refLogsStashPath];
      await acquireLock$1(stashRefPath, async () => {
        await Promise.all(
          stashRefPath.map(async (path6) => {
            if (await fs.exists(path6)) {
              return fs.rm(path6);
            }
          })
        );
      });
    }
    __name(_stashClear, "_stashClear");
    async function _stashPop({ fs, dir, gitdir, refIdx = 0 }) {
      await _stashApply({ fs, dir, gitdir, refIdx });
      await _stashDrop({ fs, dir, gitdir, refIdx });
    }
    __name(_stashPop, "_stashPop");
    async function stash({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      op = "push",
      message = "",
      refIdx = 0
    }) {
      assertParameter("fs", fs);
      assertParameter("dir", dir);
      assertParameter("gitdir", gitdir);
      assertParameter("op", op);
      const stashMap = {
        push: _stashPush,
        apply: _stashApply,
        drop: _stashDrop,
        list: _stashList,
        clear: _stashClear,
        pop: _stashPop,
        create: _stashCreate
      };
      const opsNeedRefIdx = ["apply", "drop", "pop"];
      try {
        const _fs = new FileSystem(fs);
        const folders = ["refs", "logs", "logs/refs"];
        folders.map((f) => pathBrowserify.join(gitdir, f)).forEach(async (folder) => {
          if (!await _fs.exists(folder)) {
            await _fs.mkdir(folder);
          }
        });
        const opFunc = stashMap[op];
        if (opFunc) {
          if (opsNeedRefIdx.includes(op) && refIdx < 0) {
            throw new InvalidRefNameError(
              `stash@${refIdx}`,
              "number that is in range of [0, num of stash pushed]"
            );
          }
          return await opFunc({ fs: _fs, dir, gitdir, message, refIdx });
        }
        throw new Error(`To be implemented: ${op}`);
      } catch (err) {
        err.caller = "git.stash";
        throw err;
      }
    }
    __name(stash, "stash");
    async function status({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      filepath,
      cache = {}
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        const fs = new FileSystem(_fs);
        const ignored = await GitIgnoreManager.isIgnored({
          fs,
          gitdir,
          dir,
          filepath
        });
        if (ignored) {
          return "ignored";
        }
        const headTree = await getHeadTree({ fs, cache, gitdir });
        const treeOid = await getOidAtPath({
          fs,
          cache,
          gitdir,
          tree: headTree,
          path: filepath
        });
        const indexEntry = await GitIndexManager.acquire(
          { fs, gitdir, cache },
          async function(index3) {
            for (const entry of index3) {
              if (entry.path === filepath) return entry;
            }
            return null;
          }
        );
        const stats = await fs.lstat(pathBrowserify.join(dir, filepath));
        const H = treeOid !== null;
        const I = indexEntry !== null;
        const W = stats !== null;
        const getWorkdirOid = /* @__PURE__ */ __name(async () => {
          if (I && !compareStats(indexEntry, stats)) {
            return indexEntry.oid;
          } else {
            const object = await fs.read(pathBrowserify.join(dir, filepath));
            const workdirOid = await hashObject$1({
              gitdir,
              type: "blob",
              object
            });
            if (I && indexEntry.oid === workdirOid) {
              if (stats.size !== -1) {
                GitIndexManager.acquire({ fs, gitdir, cache }, async function(index3) {
                  index3.insert({ filepath, stats, oid: workdirOid });
                });
              }
            }
            return workdirOid;
          }
        }, "getWorkdirOid");
        if (!H && !W && !I) return "absent";
        if (!H && !W && I) return "*absent";
        if (!H && W && !I) return "*added";
        if (!H && W && I) {
          const workdirOid = await getWorkdirOid();
          return workdirOid === indexEntry.oid ? "added" : "*added";
        }
        if (H && !W && !I) return "deleted";
        if (H && !W && I) {
          return treeOid === indexEntry.oid ? "*deleted" : "*deleted";
        }
        if (H && W && !I) {
          const workdirOid = await getWorkdirOid();
          return workdirOid === treeOid ? "*undeleted" : "*undeletemodified";
        }
        if (H && W && I) {
          const workdirOid = await getWorkdirOid();
          if (workdirOid === treeOid) {
            return workdirOid === indexEntry.oid ? "unmodified" : "*unmodified";
          } else {
            return workdirOid === indexEntry.oid ? "modified" : "*modified";
          }
        }
      } catch (err) {
        err.caller = "git.status";
        throw err;
      }
    }
    __name(status, "status");
    async function getOidAtPath({ fs, cache, gitdir, tree, path: path6 }) {
      if (typeof path6 === "string") path6 = path6.split("/");
      const dirname6 = path6.shift();
      for (const entry of tree) {
        if (entry.path === dirname6) {
          if (path6.length === 0) {
            return entry.oid;
          }
          const { type, object } = await _readObject({
            fs,
            cache,
            gitdir,
            oid: entry.oid
          });
          if (type === "tree") {
            const tree2 = GitTree.from(object);
            return getOidAtPath({ fs, cache, gitdir, tree: tree2, path: path6 });
          }
          if (type === "blob") {
            throw new ObjectTypeError(entry.oid, type, "blob", path6.join("/"));
          }
        }
      }
      return null;
    }
    __name(getOidAtPath, "getOidAtPath");
    async function getHeadTree({ fs, cache, gitdir }) {
      let oid;
      try {
        oid = await GitRefManager.resolve({ fs, gitdir, ref: "HEAD" });
      } catch (e) {
        if (e instanceof NotFoundError) {
          return [];
        }
      }
      const { tree } = await _readTree({ fs, cache, gitdir, oid });
      return tree;
    }
    __name(getHeadTree, "getHeadTree");
    async function statusMatrix({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref = "HEAD",
      filepaths = ["."],
      filter,
      cache = {},
      ignored: shouldIgnore = false
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        const fs = new FileSystem(_fs);
        return await _walk({
          fs,
          cache,
          dir,
          gitdir,
          trees: [TREE({ ref }), WORKDIR(), STAGE()],
          map: /* @__PURE__ */ __name(async function(filepath, [head, workdir, stage]) {
            if (!head && !stage && workdir) {
              if (!shouldIgnore) {
                const isIgnored2 = await GitIgnoreManager.isIgnored({
                  fs,
                  dir,
                  filepath
                });
                if (isIgnored2) {
                  return null;
                }
              }
            }
            if (!filepaths.some((base) => worthWalking(filepath, base))) {
              return null;
            }
            if (filter) {
              if (!filter(filepath)) return;
            }
            const [headType, workdirType, stageType] = await Promise.all([
              head && head.type(),
              workdir && workdir.type(),
              stage && stage.type()
            ]);
            const isBlob = [headType, workdirType, stageType].includes("blob");
            if ((headType === "tree" || headType === "special") && !isBlob) return;
            if (headType === "commit") return null;
            if ((workdirType === "tree" || workdirType === "special") && !isBlob)
              return;
            if (stageType === "commit") return null;
            if ((stageType === "tree" || stageType === "special") && !isBlob) return;
            const headOid = headType === "blob" ? await head.oid() : void 0;
            const stageOid = stageType === "blob" ? await stage.oid() : void 0;
            let workdirOid;
            if (headType !== "blob" && workdirType === "blob" && stageType !== "blob") {
              workdirOid = "42";
            } else if (workdirType === "blob") {
              workdirOid = await workdir.oid();
            }
            const entry = [void 0, headOid, workdirOid, stageOid];
            const result = entry.map((value) => entry.indexOf(value));
            result.shift();
            return [filepath, ...result];
          }, "map")
        });
      } catch (err) {
        err.caller = "git.statusMatrix";
        throw err;
      }
    }
    __name(statusMatrix, "statusMatrix");
    async function tag({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      object,
      force = false
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        const fs = new FileSystem(_fs);
        if (ref === void 0) {
          throw new MissingParameterError("ref");
        }
        ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
        const value = await GitRefManager.resolve({
          fs,
          gitdir,
          ref: object || "HEAD"
        });
        if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
          throw new AlreadyExistsError("tag", ref);
        }
        await GitRefManager.writeRef({ fs, gitdir, ref, value });
      } catch (err) {
        err.caller = "git.tag";
        throw err;
      }
    }
    __name(tag, "tag");
    async function updateIndex$1({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      cache = {},
      filepath,
      oid,
      mode,
      add: add2,
      remove: remove2,
      force
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("filepath", filepath);
        const fs = new FileSystem(_fs);
        if (remove2) {
          return await GitIndexManager.acquire(
            { fs, gitdir, cache },
            async function(index3) {
              if (!force) {
                const fileStats2 = await fs.lstat(pathBrowserify.join(dir, filepath));
                if (fileStats2) {
                  if (fileStats2.isDirectory()) {
                    throw new InvalidFilepathError("directory");
                  }
                  return;
                }
              }
              if (index3.has({ filepath })) {
                index3.delete({
                  filepath
                });
              }
            }
          );
        }
        let fileStats;
        if (!oid) {
          fileStats = await fs.lstat(pathBrowserify.join(dir, filepath));
          if (!fileStats) {
            throw new NotFoundError(
              `file at "${filepath}" on disk and "remove" not set`
            );
          }
          if (fileStats.isDirectory()) {
            throw new InvalidFilepathError("directory");
          }
        }
        return await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index3) {
          if (!add2 && !index3.has({ filepath })) {
            throw new NotFoundError(
              `file at "${filepath}" in index and "add" not set`
            );
          }
          let stats;
          if (!oid) {
            stats = fileStats;
            const object = stats.isSymbolicLink() ? await fs.readlink(pathBrowserify.join(dir, filepath)) : await fs.read(pathBrowserify.join(dir, filepath));
            oid = await _writeObject({
              fs,
              gitdir,
              type: "blob",
              format: "content",
              object
            });
          } else {
            stats = {
              ctime: /* @__PURE__ */ new Date(0),
              mtime: /* @__PURE__ */ new Date(0),
              dev: 0,
              ino: 0,
              mode,
              uid: 0,
              gid: 0,
              size: 0
            };
          }
          index3.insert({
            filepath,
            oid,
            stats
          });
          return oid;
        });
      } catch (err) {
        err.caller = "git.updateIndex";
        throw err;
      }
    }
    __name(updateIndex$1, "updateIndex$1");
    function version() {
      try {
        return pkg.version;
      } catch (err) {
        err.caller = "git.version";
        throw err;
      }
    }
    __name(version, "version");
    async function walk({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      trees,
      map,
      reduce,
      iterate,
      cache = {}
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("trees", trees);
        return await _walk({
          fs: new FileSystem(fs),
          cache,
          dir,
          gitdir,
          trees,
          map,
          reduce,
          iterate
        });
      } catch (err) {
        err.caller = "git.walk";
        throw err;
      }
    }
    __name(walk, "walk");
    async function writeBlob({ fs, dir, gitdir = pathBrowserify.join(dir, ".git"), blob }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("blob", blob);
        return await _writeObject({
          fs: new FileSystem(fs),
          gitdir,
          type: "blob",
          object: blob,
          format: "content"
        });
      } catch (err) {
        err.caller = "git.writeBlob";
        throw err;
      }
    }
    __name(writeBlob, "writeBlob");
    async function writeCommit({
      fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      commit: commit2
    }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("commit", commit2);
        return await _writeCommit({
          fs: new FileSystem(fs),
          gitdir,
          commit: commit2
        });
      } catch (err) {
        err.caller = "git.writeCommit";
        throw err;
      }
    }
    __name(writeCommit, "writeCommit");
    async function writeObject({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      type,
      object,
      format = "parsed",
      oid,
      encoding = void 0
    }) {
      try {
        const fs = new FileSystem(_fs);
        if (format === "parsed") {
          switch (type) {
            case "commit":
              object = GitCommit.from(object).toObject();
              break;
            case "tree":
              object = GitTree.from(object).toObject();
              break;
            case "blob":
              object = Buffer.from(object, encoding);
              break;
            case "tag":
              object = GitAnnotatedTag.from(object).toObject();
              break;
            default:
              throw new ObjectTypeError(oid || "", type, "blob|commit|tag|tree");
          }
          format = "content";
        }
        oid = await _writeObject({
          fs,
          gitdir,
          type,
          object,
          oid,
          format
        });
        return oid;
      } catch (err) {
        err.caller = "git.writeObject";
        throw err;
      }
    }
    __name(writeObject, "writeObject");
    async function writeRef({
      fs: _fs,
      dir,
      gitdir = pathBrowserify.join(dir, ".git"),
      ref,
      value,
      force = false,
      symbolic = false
    }) {
      try {
        assertParameter("fs", _fs);
        assertParameter("gitdir", gitdir);
        assertParameter("ref", ref);
        assertParameter("value", value);
        const fs = new FileSystem(_fs);
        if (!validRef(ref, true)) {
          throw new InvalidRefNameError(ref, cleanGitRef.clean(ref));
        }
        if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
          throw new AlreadyExistsError("ref", ref);
        }
        if (symbolic) {
          await GitRefManager.writeSymbolicRef({
            fs,
            gitdir,
            ref,
            value
          });
        } else {
          value = await GitRefManager.resolve({
            fs,
            gitdir,
            ref: value
          });
          await GitRefManager.writeRef({
            fs,
            gitdir,
            ref,
            value
          });
        }
      } catch (err) {
        err.caller = "git.writeRef";
        throw err;
      }
    }
    __name(writeRef, "writeRef");
    async function _writeTag({ fs, gitdir, tag: tag2 }) {
      const object = GitAnnotatedTag.from(tag2).toObject();
      const oid = await _writeObject({
        fs,
        gitdir,
        type: "tag",
        object,
        format: "content"
      });
      return oid;
    }
    __name(_writeTag, "_writeTag");
    async function writeTag({ fs, dir, gitdir = pathBrowserify.join(dir, ".git"), tag: tag2 }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("tag", tag2);
        return await _writeTag({
          fs: new FileSystem(fs),
          gitdir,
          tag: tag2
        });
      } catch (err) {
        err.caller = "git.writeTag";
        throw err;
      }
    }
    __name(writeTag, "writeTag");
    async function writeTree({ fs, dir, gitdir = pathBrowserify.join(dir, ".git"), tree }) {
      try {
        assertParameter("fs", fs);
        assertParameter("gitdir", gitdir);
        assertParameter("tree", tree);
        return await _writeTree({
          fs: new FileSystem(fs),
          gitdir,
          tree
        });
      } catch (err) {
        err.caller = "git.writeTree";
        throw err;
      }
    }
    __name(writeTree, "writeTree");
    var index2 = {
      Errors,
      STAGE,
      TREE,
      WORKDIR,
      add,
      abortMerge,
      addNote,
      addRemote,
      annotatedTag,
      branch,
      checkout,
      clone,
      commit,
      getConfig,
      getConfigAll,
      setConfig,
      currentBranch: currentBranch2,
      deleteBranch,
      deleteRef,
      deleteRemote,
      deleteTag,
      expandOid,
      expandRef,
      fastForward,
      fetch,
      findMergeBase,
      findRoot,
      getRemoteInfo,
      getRemoteInfo2,
      hashBlob,
      indexPack,
      init,
      isDescendent,
      isIgnored,
      listBranches,
      listFiles,
      listNotes,
      listRefs,
      listRemotes,
      listServerRefs,
      listTags,
      log,
      merge,
      packObjects,
      pull,
      push,
      readBlob,
      readCommit,
      readNote,
      readObject,
      readTag,
      readTree,
      remove,
      removeNote,
      renameBranch,
      resetIndex,
      updateIndex: updateIndex$1,
      resolveRef,
      status,
      statusMatrix,
      tag,
      version,
      walk,
      writeBlob,
      writeCommit,
      writeObject,
      writeRef,
      writeTag,
      writeTree,
      stash
    };
    exports.Errors = Errors;
    exports.STAGE = STAGE;
    exports.TREE = TREE;
    exports.WORKDIR = WORKDIR;
    exports.abortMerge = abortMerge;
    exports.add = add;
    exports.addNote = addNote;
    exports.addRemote = addRemote;
    exports.annotatedTag = annotatedTag;
    exports.branch = branch;
    exports.checkout = checkout;
    exports.clone = clone;
    exports.commit = commit;
    exports.currentBranch = currentBranch2;
    exports.default = index2;
    exports.deleteBranch = deleteBranch;
    exports.deleteRef = deleteRef;
    exports.deleteRemote = deleteRemote;
    exports.deleteTag = deleteTag;
    exports.expandOid = expandOid;
    exports.expandRef = expandRef;
    exports.fastForward = fastForward;
    exports.fetch = fetch;
    exports.findMergeBase = findMergeBase;
    exports.findRoot = findRoot;
    exports.getConfig = getConfig;
    exports.getConfigAll = getConfigAll;
    exports.getRemoteInfo = getRemoteInfo;
    exports.getRemoteInfo2 = getRemoteInfo2;
    exports.hashBlob = hashBlob;
    exports.indexPack = indexPack;
    exports.init = init;
    exports.isDescendent = isDescendent;
    exports.isIgnored = isIgnored;
    exports.listBranches = listBranches;
    exports.listFiles = listFiles;
    exports.listNotes = listNotes;
    exports.listRefs = listRefs;
    exports.listRemotes = listRemotes;
    exports.listServerRefs = listServerRefs;
    exports.listTags = listTags;
    exports.log = log;
    exports.merge = merge;
    exports.packObjects = packObjects;
    exports.pull = pull;
    exports.push = push;
    exports.readBlob = readBlob;
    exports.readCommit = readCommit;
    exports.readNote = readNote;
    exports.readObject = readObject;
    exports.readTag = readTag;
    exports.readTree = readTree;
    exports.remove = remove;
    exports.removeNote = removeNote;
    exports.renameBranch = renameBranch;
    exports.resetIndex = resetIndex;
    exports.resolveRef = resolveRef;
    exports.setConfig = setConfig;
    exports.stash = stash;
    exports.status = status;
    exports.statusMatrix = statusMatrix;
    exports.tag = tag;
    exports.updateIndex = updateIndex$1;
    exports.version = version;
    exports.walk = walk;
    exports.writeBlob = writeBlob;
    exports.writeCommit = writeCommit;
    exports.writeObject = writeObject;
    exports.writeRef = writeRef;
    exports.writeTag = writeTag;
    exports.writeTree = writeTree;
  }
});

// ../../node_modules/.pnpm/simple-concat@1.0.1/node_modules/simple-concat/index.js
var require_simple_concat = __commonJS({
  "../../node_modules/.pnpm/simple-concat@1.0.1/node_modules/simple-concat/index.js"(exports, module) {
    module.exports = function(stream, cb) {
      var chunks = [];
      stream.on("data", function(chunk) {
        chunks.push(chunk);
      });
      stream.once("end", function() {
        if (cb) cb(null, Buffer.concat(chunks));
        cb = null;
      });
      stream.once("error", function(err) {
        if (cb) cb(err);
        cb = null;
      });
    };
  }
});

// (disabled):../../node_modules/.pnpm/decompress-response@6.0.0/node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "(disabled):../../node_modules/.pnpm/decompress-response@6.0.0/node_modules/decompress-response/index.js"() {
  }
});

// ../../node_modules/.pnpm/stream-http@3.2.0/node_modules/stream-http/lib/capability.js
var require_capability = __commonJS({
  "../../node_modules/.pnpm/stream-http@3.2.0/node_modules/stream-http/lib/capability.js"(exports) {
    exports.fetch = isFunction(globalThis.fetch) && isFunction(globalThis.ReadableStream);
    exports.writableStream = isFunction(globalThis.WritableStream);
    exports.abortController = isFunction(globalThis.AbortController);
    var xhr;
    function getXHR() {
      if (xhr !== void 0) return xhr;
      if (globalThis.XMLHttpRequest) {
        xhr = new globalThis.XMLHttpRequest();
        try {
          xhr.open("GET", globalThis.XDomainRequest ? "/" : "https://example.com");
        } catch (e) {
          xhr = null;
        }
      } else {
        xhr = null;
      }
      return xhr;
    }
    __name(getXHR, "getXHR");
    function checkTypeSupport(type) {
      var xhr2 = getXHR();
      if (!xhr2) return false;
      try {
        xhr2.responseType = type;
        return xhr2.responseType === type;
      } catch (e) {
      }
      return false;
    }
    __name(checkTypeSupport, "checkTypeSupport");
    exports.arraybuffer = exports.fetch || checkTypeSupport("arraybuffer");
    exports.msstream = !exports.fetch && checkTypeSupport("ms-stream");
    exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport("moz-chunked-arraybuffer");
    exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);
    function isFunction(value) {
      return typeof value === "function";
    }
    __name(isFunction, "isFunction");
    xhr = null;
  }
});

// ../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "../../node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// ../../node_modules/.pnpm/stream-http@3.2.0/node_modules/stream-http/lib/response.js
var require_response = __commonJS({
  "../../node_modules/.pnpm/stream-http@3.2.0/node_modules/stream-http/lib/response.js"(exports) {
    var capability = require_capability();
    var inherits = require_inherits_browser();
    var stream = require_readable_browser();
    var rStates = exports.readyStates = {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    };
    var IncomingMessage = exports.IncomingMessage = function(xhr, response, mode, resetTimers) {
      var self2 = this;
      stream.Readable.call(self2);
      self2._mode = mode;
      self2.headers = {};
      self2.rawHeaders = [];
      self2.trailers = {};
      self2.rawTrailers = [];
      self2.on("end", function() {
        process.nextTick(function() {
          self2.emit("close");
        });
      });
      if (mode === "fetch") {
        let read2 = function() {
          reader.read().then(function(result) {
            if (self2._destroyed)
              return;
            resetTimers(result.done);
            if (result.done) {
              self2.push(null);
              return;
            }
            self2.push(Buffer.from(result.value));
            read2();
          }).catch(function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          });
        };
        var read = read2;
        __name(read2, "read");
        self2._fetchResponse = response;
        self2.url = response.url;
        self2.statusCode = response.status;
        self2.statusMessage = response.statusText;
        response.headers.forEach(function(header, key) {
          self2.headers[key.toLowerCase()] = header;
          self2.rawHeaders.push(key, header);
        });
        if (capability.writableStream) {
          var writable = new WritableStream({
            write: /* @__PURE__ */ __name(function(chunk) {
              resetTimers(false);
              return new Promise(function(resolve, reject) {
                if (self2._destroyed) {
                  reject();
                } else if (self2.push(Buffer.from(chunk))) {
                  resolve();
                } else {
                  self2._resumeFetch = resolve;
                }
              });
            }, "write"),
            close: /* @__PURE__ */ __name(function() {
              resetTimers(true);
              if (!self2._destroyed)
                self2.push(null);
            }, "close"),
            abort: /* @__PURE__ */ __name(function(err) {
              resetTimers(true);
              if (!self2._destroyed)
                self2.emit("error", err);
            }, "abort")
          });
          try {
            response.body.pipeTo(writable).catch(function(err) {
              resetTimers(true);
              if (!self2._destroyed)
                self2.emit("error", err);
            });
            return;
          } catch (e) {
          }
        }
        var reader = response.body.getReader();
        read2();
      } else {
        self2._xhr = xhr;
        self2._pos = 0;
        self2.url = xhr.responseURL;
        self2.statusCode = xhr.status;
        self2.statusMessage = xhr.statusText;
        var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
        headers.forEach(function(header) {
          var matches = header.match(/^([^:]+):\s*(.*)/);
          if (matches) {
            var key = matches[1].toLowerCase();
            if (key === "set-cookie") {
              if (self2.headers[key] === void 0) {
                self2.headers[key] = [];
              }
              self2.headers[key].push(matches[2]);
            } else if (self2.headers[key] !== void 0) {
              self2.headers[key] += ", " + matches[2];
            } else {
              self2.headers[key] = matches[2];
            }
            self2.rawHeaders.push(matches[1], matches[2]);
          }
        });
        self2._charset = "x-user-defined";
        if (!capability.overrideMimeType) {
          var mimeType = self2.rawHeaders["mime-type"];
          if (mimeType) {
            var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
            if (charsetMatch) {
              self2._charset = charsetMatch[1].toLowerCase();
            }
          }
          if (!self2._charset)
            self2._charset = "utf-8";
        }
      }
    };
    inherits(IncomingMessage, stream.Readable);
    IncomingMessage.prototype._read = function() {
      var self2 = this;
      var resolve = self2._resumeFetch;
      if (resolve) {
        self2._resumeFetch = null;
        resolve();
      }
    };
    IncomingMessage.prototype._onXHRProgress = function(resetTimers) {
      var self2 = this;
      var xhr = self2._xhr;
      var response = null;
      switch (self2._mode) {
        case "text":
          response = xhr.responseText;
          if (response.length > self2._pos) {
            var newData = response.substr(self2._pos);
            if (self2._charset === "x-user-defined") {
              var buffer = Buffer.alloc(newData.length);
              for (var i = 0; i < newData.length; i++)
                buffer[i] = newData.charCodeAt(i) & 255;
              self2.push(buffer);
            } else {
              self2.push(newData, self2._charset);
            }
            self2._pos = response.length;
          }
          break;
        case "arraybuffer":
          if (xhr.readyState !== rStates.DONE || !xhr.response)
            break;
          response = xhr.response;
          self2.push(Buffer.from(new Uint8Array(response)));
          break;
        case "moz-chunked-arraybuffer":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING || !response)
            break;
          self2.push(Buffer.from(new Uint8Array(response)));
          break;
        case "ms-stream":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING)
            break;
          var reader = new globalThis.MSStreamReader();
          reader.onprogress = function() {
            if (reader.result.byteLength > self2._pos) {
              self2.push(Buffer.from(new Uint8Array(reader.result.slice(self2._pos))));
              self2._pos = reader.result.byteLength;
            }
          };
          reader.onload = function() {
            resetTimers(true);
            self2.push(null);
          };
          reader.readAsArrayBuffer(response);
          break;
      }
      if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
        resetTimers(true);
        self2.push(null);
      }
    };
  }
});

// ../../node_modules/.pnpm/stream-http@3.2.0/node_modules/stream-http/lib/request.js
var require_request = __commonJS({
  "../../node_modules/.pnpm/stream-http@3.2.0/node_modules/stream-http/lib/request.js"(exports, module) {
    var capability = require_capability();
    var inherits = require_inherits_browser();
    var response = require_response();
    var stream = require_readable_browser();
    var IncomingMessage = response.IncomingMessage;
    var rStates = response.readyStates;
    function decideMode(preferBinary, useFetch) {
      if (capability.fetch && useFetch) {
        return "fetch";
      } else if (capability.mozchunkedarraybuffer) {
        return "moz-chunked-arraybuffer";
      } else if (capability.msstream) {
        return "ms-stream";
      } else if (capability.arraybuffer && preferBinary) {
        return "arraybuffer";
      } else {
        return "text";
      }
    }
    __name(decideMode, "decideMode");
    var ClientRequest = module.exports = function(opts) {
      var self2 = this;
      stream.Writable.call(self2);
      self2._opts = opts;
      self2._body = [];
      self2._headers = {};
      if (opts.auth)
        self2.setHeader("Authorization", "Basic " + Buffer.from(opts.auth).toString("base64"));
      Object.keys(opts.headers).forEach(function(name) {
        self2.setHeader(name, opts.headers[name]);
      });
      var preferBinary;
      var useFetch = true;
      if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
        useFetch = false;
        preferBinary = true;
      } else if (opts.mode === "prefer-streaming") {
        preferBinary = false;
      } else if (opts.mode === "allow-wrong-content-type") {
        preferBinary = !capability.overrideMimeType;
      } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
        preferBinary = true;
      } else {
        throw new Error("Invalid value for opts.mode");
      }
      self2._mode = decideMode(preferBinary, useFetch);
      self2._fetchTimer = null;
      self2._socketTimeout = null;
      self2._socketTimer = null;
      self2.on("finish", function() {
        self2._onFinish();
      });
    };
    inherits(ClientRequest, stream.Writable);
    ClientRequest.prototype.setHeader = function(name, value) {
      var self2 = this;
      var lowerName = name.toLowerCase();
      if (unsafeHeaders.indexOf(lowerName) !== -1)
        return;
      self2._headers[lowerName] = {
        name,
        value
      };
    };
    ClientRequest.prototype.getHeader = function(name) {
      var header = this._headers[name.toLowerCase()];
      if (header)
        return header.value;
      return null;
    };
    ClientRequest.prototype.removeHeader = function(name) {
      var self2 = this;
      delete self2._headers[name.toLowerCase()];
    };
    ClientRequest.prototype._onFinish = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      var opts = self2._opts;
      if ("timeout" in opts && opts.timeout !== 0) {
        self2.setTimeout(opts.timeout);
      }
      var headersObj = self2._headers;
      var body = null;
      if (opts.method !== "GET" && opts.method !== "HEAD") {
        body = new Blob(self2._body, {
          type: (headersObj["content-type"] || {}).value || ""
        });
      }
      var headersList = [];
      Object.keys(headersObj).forEach(function(keyName) {
        var name = headersObj[keyName].name;
        var value = headersObj[keyName].value;
        if (Array.isArray(value)) {
          value.forEach(function(v) {
            headersList.push([name, v]);
          });
        } else {
          headersList.push([name, value]);
        }
      });
      if (self2._mode === "fetch") {
        var signal = null;
        if (capability.abortController) {
          var controller = new AbortController();
          signal = controller.signal;
          self2._fetchAbortController = controller;
          if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
            self2._fetchTimer = globalThis.setTimeout(function() {
              self2.emit("requestTimeout");
              if (self2._fetchAbortController)
                self2._fetchAbortController.abort();
            }, opts.requestTimeout);
          }
        }
        globalThis.fetch(self2._opts.url, {
          method: self2._opts.method,
          headers: headersList,
          body: body || void 0,
          mode: "cors",
          credentials: opts.withCredentials ? "include" : "same-origin",
          signal
        }).then(function(response2) {
          self2._fetchResponse = response2;
          self2._resetTimers(false);
          self2._connect();
        }, function(reason) {
          self2._resetTimers(true);
          if (!self2._destroyed)
            self2.emit("error", reason);
        });
      } else {
        var xhr = self2._xhr = new globalThis.XMLHttpRequest();
        try {
          xhr.open(self2._opts.method, self2._opts.url, true);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
        if ("responseType" in xhr)
          xhr.responseType = self2._mode;
        if ("withCredentials" in xhr)
          xhr.withCredentials = !!opts.withCredentials;
        if (self2._mode === "text" && "overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        if ("requestTimeout" in opts) {
          xhr.timeout = opts.requestTimeout;
          xhr.ontimeout = function() {
            self2.emit("requestTimeout");
          };
        }
        headersList.forEach(function(header) {
          xhr.setRequestHeader(header[0], header[1]);
        });
        self2._response = null;
        xhr.onreadystatechange = function() {
          switch (xhr.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self2._onXHRProgress();
              break;
          }
        };
        if (self2._mode === "moz-chunked-arraybuffer") {
          xhr.onprogress = function() {
            self2._onXHRProgress();
          };
        }
        xhr.onerror = function() {
          if (self2._destroyed)
            return;
          self2._resetTimers(true);
          self2.emit("error", new Error("XHR error"));
        };
        try {
          xhr.send(body);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
      }
    };
    function statusValid(xhr) {
      try {
        var status = xhr.status;
        return status !== null && status !== 0;
      } catch (e) {
        return false;
      }
    }
    __name(statusValid, "statusValid");
    ClientRequest.prototype._onXHRProgress = function() {
      var self2 = this;
      self2._resetTimers(false);
      if (!statusValid(self2._xhr) || self2._destroyed)
        return;
      if (!self2._response)
        self2._connect();
      self2._response._onXHRProgress(self2._resetTimers.bind(self2));
    };
    ClientRequest.prototype._connect = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
      self2._response.on("error", function(err) {
        self2.emit("error", err);
      });
      self2.emit("response", self2._response);
    };
    ClientRequest.prototype._write = function(chunk, encoding, cb) {
      var self2 = this;
      self2._body.push(chunk);
      cb();
    };
    ClientRequest.prototype._resetTimers = function(done) {
      var self2 = this;
      globalThis.clearTimeout(self2._socketTimer);
      self2._socketTimer = null;
      if (done) {
        globalThis.clearTimeout(self2._fetchTimer);
        self2._fetchTimer = null;
      } else if (self2._socketTimeout) {
        self2._socketTimer = globalThis.setTimeout(function() {
          self2.emit("timeout");
        }, self2._socketTimeout);
      }
    };
    ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function(err) {
      var self2 = this;
      self2._destroyed = true;
      self2._resetTimers(true);
      if (self2._response)
        self2._response._destroyed = true;
      if (self2._xhr)
        self2._xhr.abort();
      else if (self2._fetchAbortController)
        self2._fetchAbortController.abort();
      if (err)
        self2.emit("error", err);
    };
    ClientRequest.prototype.end = function(data, encoding, cb) {
      var self2 = this;
      if (typeof data === "function") {
        cb = data;
        data = void 0;
      }
      stream.Writable.prototype.end.call(self2, data, encoding, cb);
    };
    ClientRequest.prototype.setTimeout = function(timeout, cb) {
      var self2 = this;
      if (cb)
        self2.once("timeout", cb);
      self2._socketTimeout = timeout;
      self2._resetTimers(false);
    };
    ClientRequest.prototype.flushHeaders = function() {
    };
    ClientRequest.prototype.setNoDelay = function() {
    };
    ClientRequest.prototype.setSocketKeepAlive = function() {
    };
    var unsafeHeaders = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "cookie",
      "cookie2",
      "date",
      "dnt",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "via"
    ];
  }
});

// ../../node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "../../node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
    __name(extend, "extend");
  }
});

// ../../node_modules/.pnpm/builtin-status-codes@3.0.0/node_modules/builtin-status-codes/browser.js
var require_browser2 = __commonJS({
  "../../node_modules/.pnpm/builtin-status-codes@3.0.0/node_modules/builtin-status-codes/browser.js"(exports, module) {
    module.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// ../../node_modules/.pnpm/stream-http@3.2.0/node_modules/stream-http/index.js
var require_stream_http = __commonJS({
  "../../node_modules/.pnpm/stream-http@3.2.0/node_modules/stream-http/index.js"(exports) {
    var ClientRequest = require_request();
    var response = require_response();
    var extend = require_immutable();
    var statusCodes = require_browser2();
    var url = require_url();
    var http = exports;
    http.request = function(opts, cb) {
      if (typeof opts === "string")
        opts = url.parse(opts);
      else
        opts = extend(opts);
      var defaultProtocol = globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
      var protocol = opts.protocol || defaultProtocol;
      var host = opts.hostname || opts.host;
      var port = opts.port;
      var path6 = opts.path || "/";
      if (host && host.indexOf(":") !== -1)
        host = "[" + host + "]";
      opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path6;
      opts.method = (opts.method || "GET").toUpperCase();
      opts.headers = opts.headers || {};
      var req = new ClientRequest(opts);
      if (cb)
        req.on("response", cb);
      return req;
    };
    http.get = /* @__PURE__ */ __name(function get2(opts, cb) {
      var req = http.request(opts, cb);
      req.end();
      return req;
    }, "get");
    http.ClientRequest = ClientRequest;
    http.IncomingMessage = response.IncomingMessage;
    http.Agent = function() {
    };
    http.Agent.defaultMaxSockets = 4;
    http.globalAgent = new http.Agent();
    http.STATUS_CODES = statusCodes;
    http.METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
  }
});

// ../../node_modules/.pnpm/https-browserify@1.0.0/node_modules/https-browserify/index.js
var require_https_browserify = __commonJS({
  "../../node_modules/.pnpm/https-browserify@1.0.0/node_modules/https-browserify/index.js"(exports, module) {
    var http = require_stream_http();
    var url = require_url();
    var https = module.exports;
    for (key in http) {
      if (http.hasOwnProperty(key)) https[key] = http[key];
    }
    var key;
    https.request = function(params, cb) {
      params = validateParams(params);
      return http.request.call(this, params, cb);
    };
    https.get = function(params, cb) {
      params = validateParams(params);
      return http.get.call(this, params, cb);
    };
    function validateParams(params) {
      if (typeof params === "string") {
        params = url.parse(params);
      }
      if (!params.protocol) {
        params.protocol = "https:";
      }
      if (params.protocol !== "https:") {
        throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
      }
      return params;
    }
    __name(validateParams, "validateParams");
  }
});

// ../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports, module) {
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb) return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
      __name(wrapper, "wrapper");
    }
    __name(wrappy, "wrappy");
  }
});

// ../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS({
  "../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once);
    module.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: /* @__PURE__ */ __name(function() {
          return once(this);
        }, "value"),
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: /* @__PURE__ */ __name(function() {
          return onceStrict(this);
        }, "value"),
        configurable: true
      });
    });
    function once(fn) {
      var f = /* @__PURE__ */ __name(function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      }, "f");
      f.called = false;
      return f;
    }
    __name(once, "once");
    function onceStrict(fn) {
      var f = /* @__PURE__ */ __name(function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      }, "f");
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
    __name(onceStrict, "onceStrict");
  }
});

// ../../node_modules/.pnpm/querystring-es3@0.2.1/node_modules/querystring-es3/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/querystring-es3@0.2.1/node_modules/querystring-es3/decode.js"(exports, module) {
    "use strict";
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    __name(hasOwnProperty, "hasOwnProperty");
    module.exports = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = "";
        }
        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }
      return obj;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../../node_modules/.pnpm/querystring-es3@0.2.1/node_modules/querystring-es3/encode.js
var require_encode = __commonJS({
  "../../node_modules/.pnpm/querystring-es3@0.2.1/node_modules/querystring-es3/encode.js"(exports, module) {
    "use strict";
    var stringifyPrimitive = /* @__PURE__ */ __name(function(v) {
      switch (typeof v) {
        case "string":
          return v;
        case "boolean":
          return v ? "true" : "false";
        case "number":
          return isFinite(v) ? v : "";
        default:
          return "";
      }
    }, "stringifyPrimitive");
    module.exports = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return map(objectKeys(obj), function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (isArray(obj[k])) {
            return map(obj[k], function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
      }
      if (!name) return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
    function map(xs, f) {
      if (xs.map) return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
      }
      return res;
    }
    __name(map, "map");
    var objectKeys = Object.keys || function(obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
      }
      return res;
    };
  }
});

// ../../node_modules/.pnpm/querystring-es3@0.2.1/node_modules/querystring-es3/index.js
var require_querystring_es3 = __commonJS({
  "../../node_modules/.pnpm/querystring-es3@0.2.1/node_modules/querystring-es3/index.js"(exports) {
    "use strict";
    exports.decode = exports.parse = require_decode();
    exports.encode = exports.stringify = require_encode();
  }
});

// ../../node_modules/.pnpm/simple-get@4.0.1/node_modules/simple-get/index.js
var require_simple_get = __commonJS({
  "../../node_modules/.pnpm/simple-get@4.0.1/node_modules/simple-get/index.js"(exports, module) {
    module.exports = simpleGet;
    var concat = require_simple_concat();
    var decompressResponse = require_decompress_response();
    var http = require_stream_http();
    var https = require_https_browserify();
    var once = require_once();
    var querystring = require_querystring_es3();
    var url = require_url();
    var isStream = /* @__PURE__ */ __name((o) => o !== null && typeof o === "object" && typeof o.pipe === "function", "isStream");
    function simpleGet(opts, cb) {
      opts = Object.assign({ maxRedirects: 10 }, typeof opts === "string" ? { url: opts } : opts);
      cb = once(cb);
      if (opts.url) {
        const { hostname, port, protocol: protocol2, auth, path: path6 } = url.parse(opts.url);
        delete opts.url;
        if (!hostname && !port && !protocol2 && !auth) opts.path = path6;
        else Object.assign(opts, { hostname, port, protocol: protocol2, auth, path: path6 });
      }
      const headers = { "accept-encoding": "gzip, deflate" };
      if (opts.headers) Object.keys(opts.headers).forEach((k) => headers[k.toLowerCase()] = opts.headers[k]);
      opts.headers = headers;
      let body;
      if (opts.body) {
        body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body;
      } else if (opts.form) {
        body = typeof opts.form === "string" ? opts.form : querystring.stringify(opts.form);
        opts.headers["content-type"] = "application/x-www-form-urlencoded";
      }
      if (body) {
        if (!opts.method) opts.method = "POST";
        if (!isStream(body)) opts.headers["content-length"] = Buffer.byteLength(body);
        if (opts.json && !opts.form) opts.headers["content-type"] = "application/json";
      }
      delete opts.body;
      delete opts.form;
      if (opts.json) opts.headers.accept = "application/json";
      if (opts.method) opts.method = opts.method.toUpperCase();
      const originalHost = opts.hostname;
      const protocol = opts.protocol === "https:" ? https : http;
      const req = protocol.request(opts, (res) => {
        if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
          opts.url = res.headers.location;
          delete opts.headers.host;
          res.resume();
          const redirectHost = url.parse(opts.url).hostname;
          if (redirectHost !== null && redirectHost !== originalHost) {
            delete opts.headers.cookie;
            delete opts.headers.authorization;
          }
          if (opts.method === "POST" && [301, 302].includes(res.statusCode)) {
            opts.method = "GET";
            delete opts.headers["content-length"];
            delete opts.headers["content-type"];
          }
          if (opts.maxRedirects-- === 0) return cb(new Error("too many redirects"));
          else return simpleGet(opts, cb);
        }
        const tryUnzip = typeof decompressResponse === "function" && opts.method !== "HEAD";
        cb(null, tryUnzip ? decompressResponse(res) : res);
      });
      req.on("timeout", () => {
        req.abort();
        cb(new Error("Request timed out"));
      });
      req.on("error", cb);
      if (isStream(body)) body.on("error", cb).pipe(req);
      else req.end(body);
      return req;
    }
    __name(simpleGet, "simpleGet");
    simpleGet.concat = (opts, cb) => {
      return simpleGet(opts, (err, res) => {
        if (err) return cb(err);
        concat(res, (err2, data) => {
          if (err2) return cb(err2);
          if (opts.json) {
            try {
              data = JSON.parse(data.toString());
            } catch (err3) {
              return cb(err3, res, data);
            }
          }
          cb(null, res, data);
        });
      });
    };
    ["get", "post", "put", "patch", "head", "delete"].forEach((method) => {
      simpleGet[method] = (opts, cb) => {
        if (typeof opts === "string") opts = { url: opts };
        return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb);
      };
    });
  }
});

// src/compositeFs/CompositeFs.ts
var path3 = __toESM(require_path_browserify(), 1);

// src/compositeFs/CompositeFsDir.ts
var _CompositeFsDir = class _CompositeFsDir {
  constructor(compositFs, dirPath) {
    __publicField(this, "entries", []);
    __publicField(this, "currentIndex", 0);
    __publicField(this, "closed", false);
    __publicField(this, "compositFs");
    __publicField(this, "dirPath");
    __publicField(this, "initialized", false);
    this.compositFs = compositFs;
    this.dirPath = dirPath;
  }
  async initialize() {
    if (this.initialized) return;
    const fileNames = /* @__PURE__ */ new Set();
    for (const fileSystem of [...this.compositFs.subFilesystems].reverse()) {
      const subFsDirEntries = await fileSystem.readdir(this.dirPath);
      for (const fileName of subFsDirEntries) {
        fileNames.add(fileName);
      }
    }
    for (const fileName of Array.from(fileNames)) {
      const fullPath = this.dirPath + "/" + fileName;
      if (!await this.compositFs.hiddenFilesFileSystem?.responsible(fullPath)) {
        this.entries.push({
          name: fileName,
          path: fullPath
        });
      }
    }
    this.initialized = true;
  }
  async *[Symbol.asyncIterator]() {
    await this.initialize();
    while (this.currentIndex < this.entries.length && !this.closed) {
      const entry = this.entries[this.currentIndex++];
      try {
        const stats = await this.compositFs.stat(entry.path);
        const dirent = {
          name: entry.name,
          isFile: /* @__PURE__ */ __name(() => stats.isFile(), "isFile"),
          isDirectory: /* @__PURE__ */ __name(() => stats.isDirectory(), "isDirectory"),
          isBlockDevice: /* @__PURE__ */ __name(() => stats.isBlockDevice(), "isBlockDevice"),
          isCharacterDevice: /* @__PURE__ */ __name(() => stats.isCharacterDevice(), "isCharacterDevice"),
          isSymbolicLink: /* @__PURE__ */ __name(() => stats.isSymbolicLink(), "isSymbolicLink"),
          isFIFO: /* @__PURE__ */ __name(() => stats.isFIFO(), "isFIFO"),
          isSocket: /* @__PURE__ */ __name(() => stats.isSocket(), "isSocket")
        };
        yield dirent;
      } catch (error) {
        console.debug(`Failed to stat ${entry.path}:`, error);
      }
    }
  }
  async read() {
    if (this.closed) {
      throw new Error("Directory handle is closed");
    }
    await this.initialize();
    if (this.currentIndex >= this.entries.length) {
      return null;
    }
    const entry = this.entries[this.currentIndex++];
    try {
      const stats = await this.compositFs.stat(entry.path);
      const dirent = {
        name: entry.name,
        isFile: /* @__PURE__ */ __name(() => stats.isFile(), "isFile"),
        isDirectory: /* @__PURE__ */ __name(() => stats.isDirectory(), "isDirectory"),
        isBlockDevice: /* @__PURE__ */ __name(() => stats.isBlockDevice(), "isBlockDevice"),
        isCharacterDevice: /* @__PURE__ */ __name(() => stats.isCharacterDevice(), "isCharacterDevice"),
        isSymbolicLink: /* @__PURE__ */ __name(() => stats.isSymbolicLink(), "isSymbolicLink"),
        isFIFO: /* @__PURE__ */ __name(() => stats.isFIFO(), "isFIFO"),
        isSocket: /* @__PURE__ */ __name(() => stats.isSocket(), "isSocket")
      };
      return dirent;
    } catch (error) {
      return this.read();
    }
  }
  async close() {
    this.closed = true;
    this.entries = [];
  }
  get path() {
    return this.dirPath;
  }
};
__name(_CompositeFsDir, "CompositeFsDir");
var CompositeFsDir = _CompositeFsDir;

// src/compositeFs/CompositeFsFileHandle.ts
var _CompositFsFileHandle = class _CompositFsFileHandle {
  constructor(args) {
    __publicField(this, "delegate");
    // private async _openFd(flags: any): Promise<IFileHandle> {
    //   const path = this._fs.resolvePath(this._fd);
    //   return (await this._fs.open(path, flags)) as unknown as IFileHandle;
    // }
    // the filedescriptor from the sub fs
    __publicField(this, "_subFsFileDescriptor");
    /**
     * a file in a subsystem might be represented by multiple files within the parent fs
     * this array contains the filedescriptor pointing to the open files in the parent fs
     *
     * NOTE in case of virtual files - the parentfs might not have any file representing the file
     */
    __publicField(this, "_parentFsFileDescriptors");
    __publicField(this, "handleType", "file");
    __publicField(this, "_compositFsFileDescriptor", -1);
    this.delegate = args.fs;
    this._subFsFileDescriptor = args.subFsFileDescriptor;
    this._parentFsFileDescriptors = args.parentFsFileDescriptors;
    this._compositFsFileDescriptor = -1;
    let typeNumber = args.fs.fileType();
    const fd = this._subFsFileDescriptor;
  }
  get fsType() {
    return this.delegate.fileType();
  }
  get subFsFileDescriptor() {
    return this._subFsFileDescriptor;
  }
  get fd() {
    return this._compositFsFileDescriptor;
  }
  realize(compositeFd) {
    if (this._compositFsFileDescriptor !== -1) {
      throw new Error("was already realized");
    }
    this._compositFsFileDescriptor = compositeFd;
  }
  readableWebStream(options) {
    throw new Error("Method not implemented.");
  }
  async appendFile(data, options) {
    return await this.delegate.appendFile(this, data, options);
  }
  async chmod(mode) {
    return this.delegate.fchmod(this, mode);
  }
  async chown(uid, gid) {
    return this.delegate.fchown(this, uid, gid);
  }
  async close() {
    return this.delegate.close(this);
  }
  async datasync() {
    return this.delegate.dataSync(this);
  }
  async read(buffer, offset, length, position) {
    return await this.delegate.read(this, buffer, offset, length, position);
  }
  readv(buffers, position) {
    return this.delegate.readv(this, buffers, position);
  }
  // async readFile(options?: IReadFileOptions | string): Promise<TDataOut> {
  //   return this._fs.readFile(this, options);
  // }
  async stat(options) {
    return this.delegate.fstat(this, options);
  }
  async truncate(len) {
    return this.delegate.ftruncate(this, len);
  }
  async utimes(atime, mtime) {
    return this.delegate.futimes(this, atime, mtime);
  }
  async write(buffer, offset, length, position) {
    return this.delegate.write(this, buffer, offset, length, position);
  }
  async writev(buffers, position) {
    return this.delegate.writev(this, buffers, position);
  }
  async sync() {
    return this.delegate.dataSync(this);
  }
};
__name(_CompositFsFileHandle, "CompositFsFileHandle");
var CompositFsFileHandle = _CompositFsFileHandle;

// src/compositeFs/subsystems/PassThroughSubFs.ts
var path = __toESM(require_path_browserify(), 1);
var import_memfs = __toESM(require_lib4(), 1);

// src/compositeFs/subsystems/BaseCompositeSubFs.ts
var _BaseCompositeSubFs = class _BaseCompositeSubFs {
  constructor({
    parentFs,
    gitRoot
  }) {
    __publicField(this, "compositFs");
    __publicField(this, "gitRoot");
    this.compositFs = parentFs;
    this.gitRoot = gitRoot;
  }
  toStr(p) {
    if (typeof p === "string") return p;
    if (Buffer.isBuffer(p)) return p.toString();
    if (p && typeof p === "object" && "fd" in p)
      return `FileHandle(fd=${p.fd})`;
    return String(p);
  }
  async open(path6, flags, mode) {
    throw new Error(`open not implemented for: ${this.toStr(path6)}`);
  }
  async access(path6, mode) {
    throw new Error(`access not implemented for: ${this.toStr(path6)}`);
  }
  async stat(path6, opts) {
    throw new Error(`lstat not implemented for: ${this.toStr(path6)}`);
  }
  async lstat(path6, opts) {
    throw new Error(`lstat not implemented for: ${this.toStr(path6)}`);
  }
  async opendir(path6, options) {
    throw new Error(`opendir not implemented for: ${this.toStr(path6)}`);
  }
  async link(existingPath, newPath) {
    throw new Error(`link not implemented for: ${this.toStr(existingPath)}`);
  }
  async mkdir(path6, options) {
    throw new Error(`mkdir not implemented for: ${this.toStr(path6)}`);
  }
  async readdir(path6, options) {
    throw new Error(`readdir not implemented for: ${this.toStr(path6)}`);
  }
  async readlink(path6, ...args) {
    throw new Error(`readlink not implemented for: ${this.toStr(path6)}`);
  }
  async unlink(path6) {
    throw new Error(`unlink not implemented for: ${this.toStr(path6)}`);
  }
  async rename(oldPath, newPath) {
    throw new Error(`rename not implemented for: ${this.toStr(oldPath)}`);
  }
  async rmdir(path6, ...args) {
    throw new Error(`rmdir not implemented for: ${this.toStr(path6)}`);
  }
  async symlink(target, path6, type) {
    throw new Error(`symlink not implemented for: ${this.toStr(path6)}`);
  }
  async lookup(filePath) {
    throw new Error(`lookup not implemented for: ${this.toStr(filePath)}`);
  }
  resolvePath(fd) {
    throw new Error(`resolvePath not implemented for fd: ${fd}`);
  }
  async close(fh) {
    this.compositFs.close(fh);
  }
  async dataSync(fh) {
    throw new Error(`dataSync not implemented for: ${fh.subFsFileDescriptor}`);
  }
  async read(fh, buffer, offset, length, position) {
    throw new Error(`read not implemented for: ${fh.subFsFileDescriptor}`);
  }
  async appendFile(fh, data, options) {
    throw new Error(
      `appendFile not implemented for: ${fh.subFsFileDescriptor}`
    );
  }
  async fchmod(fh, mode) {
    throw new Error(`fchmod not implemented for: ${fh.subFsFileDescriptor}`);
  }
  async fchown(fh, uid, gid) {
    throw new Error(`fchown not implemented for: ${fh.subFsFileDescriptor}`);
  }
  async ftruncate(fh, len) {
    throw new Error(`ftruncate not implemented for: ${fh.subFsFileDescriptor}`);
  }
  async fstat(fh, options) {
    throw new Error(`fstat not implemented for: ${fh.subFsFileDescriptor}`);
  }
  async futimes(fh, atime, mtime) {
    throw new Error(`futimes not implemented for: ${fh.subFsFileDescriptor}`);
  }
  async write(fh, buffer, offset, length, position) {
    throw new Error(`write not implemented for: ${fh.subFsFileDescriptor}`);
  }
  async writev(fh, buffers, position) {
    throw new Error(`writev not implemented for: ${fh.subFsFileDescriptor}`);
  }
  async readv(fh, buffers, position) {
    throw new Error(`readv not implemented for: ${fh.subFsFileDescriptor}`);
  }
  async readFile(path6, options) {
    throw new Error(`readFile not implemented for: ${this.toStr(path6)}`);
  }
  async writeFile(path6, data, options) {
    throw new Error(`writeFile not implemented for: ${this.toStr(path6)}`);
  }
};
__name(_BaseCompositeSubFs, "BaseCompositeSubFs");
var BaseCompositeSubFs = _BaseCompositeSubFs;

// src/compositeFs/subsystems/PassThroughSubFs.ts
var _PassThroughSubFs = class _PassThroughSubFs extends BaseCompositeSubFs {
  constructor({
    parentFs,
    gitRoot
  }) {
    super({
      parentFs,
      gitRoot
    });
    __publicField(this, "openFh", /* @__PURE__ */ new Map());
    __publicField(this, "memFs", (0, import_memfs.createFsFromVolume)(new import_memfs.Volume()));
    __publicField(this, "targetFs");
    this.compositFs = parentFs;
    this.gitRoot = gitRoot;
    if (this.compositFs.parentFs === void 0) {
      throw new Error("PassThroughSubFs not allowed in root fs");
    }
    this.targetFs = this.compositFs.parentFs;
  }
  async responsible(filePath) {
    return true;
  }
  fileType() {
    return 4;
  }
  async open(filePath, flags, mode) {
    const parentPath = path.dirname(filePath);
    const fh = await this.targetFs.promises.open(filePath, flags, mode);
    this.openFh.set(fh.fd, fh);
    const filehandle = new CompositFsFileHandle({
      fs: this,
      subFsFileDescriptor: fh.fd,
      parentFsFileDescriptors: [fh.fd]
    });
    return filehandle;
  }
  async access(filePath, mode) {
    return await this.targetFs.promises.access(filePath, mode);
  }
  async stat(path6, opts) {
    return this.targetFs.promises.stat(path6, {
      // NOTE we don't support bigint for now
      bigint: false
    });
  }
  async lstat(path6, opts) {
    return this.targetFs.promises.lstat(path6, {
      // NOTE we don't support bigint for now
      bigint: false
    });
  }
  async opendir(folderPath, options) {
    return await this.targetFs.promises.opendir(folderPath, options);
  }
  async link(existingPath, newPath) {
    return await this.targetFs.promises.link(existingPath, newPath);
  }
  async mkdir(dirPath, options) {
    const pathStr = typeof dirPath === "string" ? dirPath : dirPath.toString();
    return await this.targetFs.promises.mkdir(pathStr, options);
  }
  async readdir(path6, ...args) {
    return this.targetFs.promises.readdir(path6, ...args);
  }
  async readlink(path6, ...args) {
    throw new Error("not implemented");
  }
  async unlink(path6) {
    return await this.targetFs.promises.unlink(path6);
  }
  async rename(oldPath, newPath) {
    return await this.targetFs.promises.rename(oldPath, newPath);
  }
  async rmdir(path6, options) {
    return await this.targetFs.promises.rmdir(path6, options);
  }
  async symlink(target, path6, type) {
    return await this.targetFs.promises.symlink(target, path6, type);
  }
  async lookup(filePath) {
    throw new Error(`lookup is not implemented for: ${this.toStr(filePath)}`);
  }
  async close(fh) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      await fileHandle.close();
      this.openFh.delete(fh.subFsFileDescriptor);
    }
    this.compositFs.close(fh);
  }
  async dataSync(fh) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.sync();
    }
  }
  async read(fh, buffer, offset, length, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.read(buffer, offset, length, position);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async fchmod(fh, mode) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.chmod(mode);
    }
  }
  async fchown(fh, uid, gid) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.chown(uid, gid);
    }
  }
  async write(fh, buffer, offset, length, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.write(
        buffer,
        offset,
        length,
        position
      );
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async ftruncate(fh, len) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.truncate(len);
    }
  }
  resolvePath(fd) {
    throw new Error(`resolvePath is not implemented: resolvePath(${fd})`);
  }
  async fstat(fh, options) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.stat(options);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async futimes(fh, atime, mtime) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.utimes(atime, mtime);
    }
  }
  async writev(fh, buffers, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.writev(buffers, position ?? void 0);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async readv(fh, buffers, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.readv(buffers, position ?? void 0);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async readFile(path6, options) {
    if (typeof path6 === "string" || Buffer.isBuffer(path6)) {
      return this.targetFs.readFile(path6.toString(), options);
    }
    return super.readFile(path6, options);
  }
  async writeFile(path6, data, options) {
    const flags = typeof options === "object" && options.flag ? options.flag : "w";
    const fh = await this.targetFs.open(path6, flags);
    try {
      let buffer;
      if (typeof data === "string") {
        const encoding = typeof options === "object" && options.encoding ? options.encoding : "utf8";
        buffer = Buffer.from(data, encoding);
      } else if (Buffer.isBuffer(data)) {
        buffer = data;
      } else {
        buffer = Buffer.from(data);
      }
      await fh.write(buffer, 0, buffer.length, 0);
    } finally {
      await this.targetFs.close(fh);
    }
  }
};
__name(_PassThroughSubFs, "PassThroughSubFs");
var PassThroughSubFs = _PassThroughSubFs;

// src/compositeFs/subsystems/PassThroughToAsyncFsSubFs.ts
var path2 = __toESM(require_path_browserify(), 1);
var import_memfs2 = __toESM(require_lib4(), 1);
var _PassThroughToAsyncFsSubFs = class _PassThroughToAsyncFsSubFs extends BaseCompositeSubFs {
  constructor({
    parentFs,
    gitRoot,
    passThroughFs
  }) {
    super({
      parentFs,
      gitRoot
    });
    __publicField(this, "openFh", /* @__PURE__ */ new Map());
    __publicField(this, "memFs", (0, import_memfs2.createFsFromVolume)(new import_memfs2.Volume()));
    __publicField(this, "targetFs");
    this.compositFs = parentFs;
    this.gitRoot = gitRoot;
    this.targetFs = passThroughFs;
  }
  async responsible(filePath) {
    return true;
  }
  fileType() {
    return 4;
  }
  async open(filePath, flags, mode) {
    const parentPath = path2.dirname(filePath);
    const fh = await this.targetFs.promises.open(filePath, flags, mode);
    this.openFh.set(fh.fd, fh);
    const filehandle = new CompositFsFileHandle({
      fs: this,
      subFsFileDescriptor: fh.fd,
      parentFsFileDescriptors: []
    });
    return filehandle;
  }
  async access(filePath, mode) {
    return await this.targetFs.promises.access(filePath, mode);
  }
  async stat(path6, ...args) {
    return this.targetFs.promises.stat(path6, {
      // NOTE we don't support bigint for now
      bigint: false
    });
  }
  async lstat(path6, ...args) {
    return this.targetFs.promises.lstat(path6, {
      // NOTE we don't support bigint for now
      bigint: false
    });
  }
  async opendir(folderPath, options) {
    const dir = await this.targetFs.promises.opendir(folderPath, options);
    return new CompositeFsDir(this.compositFs, folderPath.toString());
  }
  async link(existingPath, newPath) {
    return await this.targetFs.promises.link(existingPath, newPath);
  }
  async mkdir(path6, options) {
    await this.targetFs.promises.mkdir(path6, options);
  }
  async readdir(path6, ...args) {
    return this.targetFs.promises.readdir(path6, ...args);
  }
  async readlink(path6, ...args) {
    throw new Error("not implemented");
  }
  async unlink(path6) {
    return await this.targetFs.promises.unlink(path6);
  }
  async rename(oldPath, newPath) {
    return await this.targetFs.promises.rename(oldPath, newPath);
  }
  async rmdir(path6, options) {
    return await this.targetFs.promises.rmdir(path6, options);
  }
  async symlink(target, path6, type) {
    return await this.targetFs.promises.symlink(target, path6, type);
  }
  async lookup(filePath) {
    throw new Error(`lookup is not implemented for: ${this.toStr(filePath)}`);
  }
  async close(fh) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      await fileHandle.close();
      this.openFh.delete(fh.subFsFileDescriptor);
    }
    this.compositFs.close(fh);
  }
  async dataSync(fh) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.sync();
    }
  }
  async read(fh, buffer, offset, length, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.read(buffer, offset, length, position);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async fchmod(fh, mode) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.chmod(mode);
    }
  }
  async fchown(fh, uid, gid) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.chown(uid, gid);
    }
  }
  async write(fh, buffer, offset, length, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.write(
        buffer,
        offset,
        length,
        position
      );
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async ftruncate(fh, len) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.truncate(len);
    }
  }
  resolvePath(fd) {
    throw new Error(`resolvePath is not implemented: resolvePath(${fd})`);
  }
  async fstat(fh, options) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.stat(options);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async futimes(fh, atime, mtime) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.utimes(atime, mtime);
    }
  }
  async writev(fh, buffers, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.writev(buffers, position ?? void 0);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async readv(fh, buffers, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.readv(buffers, position ?? void 0);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async readFile(path6, options) {
    return this.targetFs.promises.readFile(path6, options);
  }
  async writeFile(path6, data, options) {
    return this.targetFs.promises.writeFile(path6, data, options);
  }
};
__name(_PassThroughToAsyncFsSubFs, "PassThroughToAsyncFsSubFs");
var PassThroughToAsyncFsSubFs = _PassThroughToAsyncFsSubFs;

// src/compositeFs/CompositeFs.ts
var _CompositeFs = class _CompositeFs {
  constructor({
    name,
    parentFs,
    storageFs,
    gitRoot
  }) {
    __publicField(this, "gitRoot");
    __publicField(this, "ephemeralFilesFileSystem");
    __publicField(this, "hiddenFilesFileSystem");
    __publicField(this, "passThroughFileSystem");
    __publicField(this, "subFilesystems", []);
    __publicField(this, "parentFs");
    __publicField(this, "name");
    __publicField(this, "pathToFileDescriptors", /* @__PURE__ */ new Map());
    __publicField(this, "openFileHandles", /* @__PURE__ */ new Map());
    __publicField(this, "promises", {
      access: this.access.bind(this),
      opendir: this.opendir.bind(this),
      mkdir: this.mkdir.bind(this),
      readdir: this.readdir.bind(this),
      open: this.open.bind(this),
      stat: this.stat.bind(this),
      lstat: this.lstat.bind(this),
      link: this.link.bind(this),
      readlink: this.readlink.bind(this),
      unlink: this.unlink.bind(this),
      rename: this.rename.bind(this),
      rmdir: this.rmdir.bind(this),
      symlink: this.symlink.bind(this),
      readFile: this.readFile.bind(this),
      writeFile: this.writeFile.bind(this),
      getFilehandle: this.getFilehandle.bind(this)
    });
    this.name = name;
    this.parentFs = parentFs;
    this.gitRoot = gitRoot;
    if (!parentFs && storageFs) {
      this.passThroughFileSystem = new PassThroughToAsyncFsSubFs({
        passThroughFs: storageFs,
        gitRoot,
        parentFs: this
      });
      return;
    }
    if (!storageFs && parentFs) {
      this.passThroughFileSystem = new PassThroughSubFs({
        parentFs: this,
        gitRoot
      });
      return;
    }
    throw new Error("invalid configuration");
  }
  getNextFileDescriptor() {
    const fds = Array.from(this.openFileHandles.keys());
    return fds.length === 0 ? 1 : Math.max(...fds) + 1;
  }
  getFilehandle(fd) {
    return this.openFileHandles.get(fd);
  }
  setEphemeralFilesSubFs(subFs) {
    this.ephemeralFilesFileSystem = subFs;
  }
  setHiddenFilesSubFs(subFs) {
    this.hiddenFilesFileSystem = subFs;
  }
  addSubFs(subFs) {
    this.subFilesystems.push(subFs);
  }
  /**
   * TODO this might be a leftover from nf3 - check useage
   * @param path
   */
  async lookup(path6) {
    throw new Error("lookup - not implemented");
  }
  async resolvePath(fd) {
    throw new Error("resolvePath - not implemented");
  }
  async getResponsibleFs(filePath) {
    if (!filePath.toString().startsWith(this.gitRoot) && // TODO fix path for browserfs
    this.gitRoot !== "./") {
      throw new Error(
        "tried to access a file (" + filePath + ") outside of the legit folder: " + this.gitRoot
      );
    }
    if (!this.hiddenFilesFileSystem) {
      throw new Error(this.name + " intialize hidden fs first!");
    }
    if (!this.ephemeralFilesFileSystem) {
      throw new Error(this.name + " intialize ephemeral fs first!");
    }
    if (await this.hiddenFilesFileSystem.responsible(filePath.toString())) {
      return this.hiddenFilesFileSystem;
    }
    if (await this.ephemeralFilesFileSystem.responsible(filePath.toString())) {
      return this.ephemeralFilesFileSystem;
    }
    for (const fileSystem of this.subFilesystems) {
      if (await fileSystem.responsible(filePath.toString())) {
        return fileSystem;
      }
    }
    return this.passThroughFileSystem;
  }
  async access(filePath, mode) {
    const fsToUse = await this.getResponsibleFs(filePath);
    return fsToUse.access(filePath, mode);
  }
  async opendir(dirPath, options) {
    const dirPathStr = dirPath.toString();
    if (!dirPathStr.startsWith(this.gitRoot)) {
      throw new Error(
        "tried to access a directory (" + dirPathStr + ") outside of the legit folder: " + this.gitRoot
      );
    }
    return new CompositeFsDir(this, dirPathStr);
  }
  async mkdir(dirPath, options) {
    const fsToUse = await this.getResponsibleFs(dirPath);
    return fsToUse.mkdir(dirPath, options);
  }
  /**
   * Read dir needs to check if one subfs takes control.
   *
   * TODO also implement the option to return stats
   *
   * @param dirPath
   * @param options
   * @returns
   */
  async readdir(dirPath, options) {
    const fsToUse = await this.getResponsibleFs(dirPath);
    if (fsToUse !== this.passThroughFileSystem) {
      return fsToUse.readdir(dirPath, options);
    }
    const fileNames = /* @__PURE__ */ new Set();
    for (const fileSystem of [...this.subFilesystems].reverse()) {
      const subFsdirEntries = await fileSystem.readdir(dirPath, options);
      for (const fileName of subFsdirEntries) {
        if (!await this.ephemeralFilesFileSystem?.responsible(
          (dirPath == "/" ? "" : dirPath) + "/" + fileName
        )) {
          fileNames.add(fileName);
        }
      }
    }
    const passthroughEntries = await this.passThroughFileSystem.readdir(
      dirPath,
      options
    );
    for (const fileName of passthroughEntries) {
      if (!await this.ephemeralFilesFileSystem?.responsible(
        (dirPath == "/" ? "" : dirPath) + "/" + fileName
      )) {
        fileNames.add(fileName);
      }
    }
    try {
      const ephemeralEntries = await this.ephemeralFilesFileSystem.readdir(
        dirPath,
        options
      );
      for (const fileName of ephemeralEntries) {
        fileNames.add(fileName);
      }
    } catch (err) {
      console.log(err.code);
    }
    for (const fileName of fileNames) {
      const fullPath = (dirPath == "/" ? "" : dirPath) + "/" + fileName;
      if (await this.hiddenFilesFileSystem.responsible(fullPath)) {
        fileNames.delete(fileName);
      }
    }
    return Array.from(fileNames);
  }
  async open(filePath, flags, mode) {
    const fsToUse = await this.getResponsibleFs(filePath);
    const fileHandle = await fsToUse.open(filePath, flags, mode);
    const nextDescriptor = this.getNextFileDescriptor();
    fileHandle.realize(nextDescriptor);
    this.openFileHandles.set(nextDescriptor, fileHandle);
    if (!this.pathToFileDescriptors.get(filePath)) {
      this.pathToFileDescriptors.set(filePath, []);
    }
    this.pathToFileDescriptors.get(filePath).push(nextDescriptor);
    return fileHandle;
  }
  async close(fh) {
    for (const [filePath, handles] of this.pathToFileDescriptors.entries()) {
      const index2 = handles.indexOf(fh.fd);
      if (index2 !== -1) {
        handles.splice(index2, 1);
        if (handles.length === 0) {
          this.pathToFileDescriptors.delete(filePath);
        }
        break;
      }
    }
  }
  async stat(path6, opts) {
    const pathStr = path6.toString();
    const fsToUse = await this.getResponsibleFs(path6);
    return fsToUse.stat(path6);
  }
  async lstat(path6, opts) {
    const fsToUse = await this.getResponsibleFs(path6);
    return fsToUse.lstat(path6, opts);
  }
  async link(existingPath, newPath) {
    throw new Error("not implemented");
  }
  async readlink(path6, options) {
    throw new Error("not implemented");
  }
  async unlink(filePath) {
    const fsToUse = await this.getResponsibleFs(filePath);
    return fsToUse.unlink(filePath);
  }
  async rename(oldPath, newPath) {
    if (this.hiddenFilesFileSystem) {
      if (await this.hiddenFilesFileSystem.responsible(
        path3.basename(oldPath.toString())
      )) {
        throw new Error("Renaming of hidden Files is not allowed " + oldPath);
      }
      if (await this.hiddenFilesFileSystem.responsible(
        path3.basename(newPath.toString())
      )) {
        throw new Error("Renaming to hidden Files is not allowed " + newPath);
      }
    }
    const oldFs = await this.getResponsibleFs(oldPath);
    const newFs = await this.getResponsibleFs(newPath);
    if (oldFs === newFs) {
      return oldFs.rename(oldPath, newPath);
    }
    const fh = await oldFs.open(oldPath.toString(), "r");
    try {
      const stats = await oldFs.fstat(fh);
      const buffer = Buffer.alloc(stats.size);
      await oldFs.read(fh, buffer, 0, stats.size, 0);
      await oldFs.close(fh);
      await newFs.writeFile(newPath.toString(), buffer, "utf8");
      await oldFs.unlink(oldPath);
    } catch (error) {
      try {
        await oldFs.close(fh);
      } catch (closeError) {
      }
      throw error;
    }
  }
  async rmdir(dirPath, options) {
    const fsToUse = await this.getResponsibleFs(dirPath);
    return fsToUse.rmdir(dirPath, options);
  }
  async symlink(target, path6, type) {
    throw new Error("not implemented");
  }
  async readFile(path6, options) {
    let closeAfter = true;
    let fileHandle;
    if (typeof path6 === "number") {
      closeAfter = false;
      const fh = this.getFilehandle(path6);
      if (!fh) {
        throw new Error("Invalid file descriptor");
      }
      fileHandle = fh;
    } else if (typeof path6 === "string") {
      fileHandle = await this.open(path6, "r");
    } else {
      throw new Error("only filehandle and path are supported atm");
    }
    try {
      const stat = await fileHandle.stat();
      let length = stat.size;
      if (typeof length === "bigint") {
        if (length > BigInt(Number.MAX_SAFE_INTEGER)) {
          throw new Error("File too large to read into buffer");
        }
        length = Number(length);
      }
      const buffer = Buffer.alloc(length);
      const { bytesRead } = await fileHandle.read(buffer, 0, length, 0);
      if (options && typeof options.encoding === "string") {
        return buffer.slice(0, bytesRead).toString(options.encoding);
      }
      if (typeof options === "string") {
        if (options === "utf8" || options === "utf-8") {
          return buffer.slice(0, bytesRead).toString(options);
        } else {
          throw new Error("Unsupported encoding: " + options);
        }
      }
      return buffer.slice(0, bytesRead);
    } finally {
      if (fileHandle && closeAfter) {
        await fileHandle.close();
      }
    }
  }
  async writeFile(file, data, options) {
    let closeAfter = typeof file !== "number";
    let fileHandle;
    let encoding;
    let mode;
    let flag = "w";
    if (typeof options === "string") {
      encoding = options;
    } else if (options && typeof options === "object") {
      encoding = options.encoding;
      mode = options.mode;
      flag = options.flag || "w";
    }
    if (typeof file === "number") {
      const fh = this.getFilehandle(file);
      if (!fh) {
        throw new Error("Invalid file descriptor");
      }
      fileHandle = fh;
    } else if (typeof file === "string") {
      fileHandle = await this.open(file, flag, mode);
    } else {
      throw new Error("only filehandle and path are supported atm");
    }
    try {
      let buffer;
      if (typeof data === "string") {
        buffer = Buffer.from(data, encoding || "utf8");
      } else if (data instanceof Buffer) {
        buffer = data;
      } else if (data instanceof Uint8Array) {
        buffer = Buffer.from(data);
      } else {
        throw new Error("Invalid data type for writeFile");
      }
      let written = 0;
      while (written < buffer.length) {
        const { bytesWritten } = await fileHandle.write(
          buffer,
          written,
          buffer.length - written,
          written
        );
        written += bytesWritten;
      }
    } finally {
      if (fileHandle && closeAfter) {
        await fileHandle.close();
      }
    }
  }
};
__name(_CompositeFs, "CompositeFs");
var CompositeFs = _CompositeFs;

// src/compositeFs/subsystems/HiddenFileSubFs.ts
var import_ignore = __toESM(require_ignore(), 1);
var _HiddenFileSubFs = class _HiddenFileSubFs extends BaseCompositeSubFs {
  constructor({
    parentFs,
    gitRoot,
    hiddenFiles
  }) {
    super({
      parentFs,
      gitRoot
    });
    __publicField(this, "ig");
    this.ig = (0, import_ignore.default)();
    this.ig.add(hiddenFiles);
  }
  async responsible(filePath) {
    const normalized = filePath.replace(/\\/g, "/");
    let relative = normalized.startsWith("./") ? normalized.slice(2) : normalized;
    relative = relative.startsWith("/") ? relative.slice(1) : relative;
    if (relative === "" || relative === ".") {
      return false;
    }
    const ignores = this.ig.ignores(relative);
    return ignores;
  }
  fileType() {
    return 255;
  }
  error(path6) {
    return new Error(
      `Access to hidden file is not allowed: ${this.toStr(path6)}`
    );
  }
  async open(path6, flags, mode) {
    throw this.error(path6);
  }
  async access(path6) {
    throw this.error(path6);
  }
  async stat(path6) {
    throw this.error(path6);
  }
  async lstat(path6) {
    throw this.error(path6);
  }
  async opendir(path6) {
    throw this.error(path6);
  }
  async link(existingPath) {
    throw this.error(existingPath);
  }
  async mkdir(path6) {
    throw this.error(path6);
  }
  async readdir(path6) {
    throw this.error(path6);
  }
  async readlink(path6) {
    throw this.error(path6);
  }
  async unlink(path6) {
    throw this.error(path6);
  }
  async rename(oldPath) {
    throw this.error(oldPath);
  }
  async rmdir(path6) {
    throw this.error(path6);
  }
  async symlink(_target, path6) {
    throw this.error(path6);
  }
  async lookup(filePath) {
    throw this.error(filePath);
  }
  resolvePath(fd) {
    throw new Error(`Access to hidden file is not allowed: resolvePath(${fd})`);
  }
  async close(fh) {
    throw new Error(
      "Access to hidden file is not allowed: close: " + fh.subFsFileDescriptor
    );
  }
  async dataSync(fh) {
    throw new Error(
      "Access to hidden file is not allowed: dataSync: " + fh.subFsFileDescriptor
    );
  }
  async read(fh, buffer, offset, length, position) {
    throw new Error(
      "Access to hidden file is not allowed: readFileHandle: " + fh.subFsFileDescriptor
    );
  }
};
__name(_HiddenFileSubFs, "HiddenFileSubFs");
var HiddenFileSubFs = _HiddenFileSubFs;

// src/compositeFs/subsystems/EphemeralFileSubFs.ts
var path4 = __toESM(require_path_browserify(), 1);
var import_memfs3 = __toESM(require_lib4(), 1);
var import_ignore2 = __toESM(require_ignore(), 1);
var _EphemeralSubFs = class _EphemeralSubFs extends BaseCompositeSubFs {
  constructor({
    parentFs,
    gitRoot,
    ephemeralPatterns
  }) {
    super({
      parentFs,
      gitRoot
    });
    __publicField(this, "openFh", /* @__PURE__ */ new Map());
    __publicField(this, "memFs", (0, import_memfs3.createFsFromVolume)(new import_memfs3.Volume()));
    __publicField(this, "ig");
    __publicField(this, "patterns");
    this.compositFs = parentFs;
    this.gitRoot = gitRoot;
    this.ig = (0, import_ignore2.default)();
    this.ig.add(ephemeralPatterns);
    this.patterns = ephemeralPatterns;
  }
  normalizePath(filePath) {
    const pathStr = typeof filePath === "string" ? filePath : filePath.toString();
    if (!pathStr.startsWith("/")) {
      return "/" + pathStr;
    }
    return pathStr;
  }
  async responsible(filePath) {
    const normalized = filePath.replace(/\\/g, "/");
    let relative = normalized.startsWith("./") ? normalized.slice(2) : normalized;
    relative = relative.startsWith("/") ? relative.slice(1) : relative;
    if (relative === "" || relative === ".") {
      return false;
    }
    const ignores = this.ig.ignores(relative);
    return ignores;
  }
  fileType() {
    return 5;
  }
  async open(filePath, flags, mode) {
    const normalizedPath = this.normalizePath(filePath);
    const parentPath = path4.dirname(normalizedPath);
    if (parentPath && parentPath !== "/" && parentPath !== ".") {
      await this.memFs.promises.mkdir(parentPath, { recursive: true });
    }
    const fh = await this.memFs.promises.open(normalizedPath, flags, mode);
    this.openFh.set(fh.fd, fh);
    const filehandle = new CompositFsFileHandle({
      fs: this,
      subFsFileDescriptor: fh.fd,
      parentFsFileDescriptors: [fh.fd]
    });
    return filehandle;
  }
  async access(filePath, mode) {
    const normalizedPath = this.normalizePath(filePath);
    return await this.memFs.promises.access(normalizedPath, mode);
  }
  async stat(path6, opts) {
    const normalizedPath = this.normalizePath(path6);
    return this.memFs.promises.stat(normalizedPath, {
      // NOTE we don't support bigint for now
      bigint: false
    });
  }
  async lstat(path6, opts) {
    const normalizedPath = this.normalizePath(path6);
    return this.memFs.promises.lstat(normalizedPath, {
      // NOTE we don't support bigint for now
      bigint: false
    });
  }
  async opendir(folderPath, options) {
    const normalizedPath = this.normalizePath(folderPath);
    return await this.memFs.promises.opendir(normalizedPath, options);
  }
  async link(existingPath, newPath) {
    const normalizedExisting = this.normalizePath(existingPath);
    const normalizedNew = this.normalizePath(newPath);
    return await this.memFs.promises.link(normalizedExisting, normalizedNew);
  }
  async mkdir(dirPath, options) {
    const normalizedPath = this.normalizePath(dirPath);
    const isRecursive = typeof options === "object" && options && "recursive" in options && options.recursive;
    if (!isRecursive) {
      const parentPath = path4.dirname(normalizedPath);
      if (parentPath && parentPath !== "/" && parentPath !== ".") {
        try {
          await this.memFs.promises.stat(parentPath);
        } catch (e) {
          await this.memFs.promises.mkdir(parentPath, { recursive: true });
        }
      }
    }
    await this.memFs.promises.mkdir(normalizedPath, options);
  }
  async readdir(path6, ...args) {
    const normalizedPath = this.normalizePath(path6);
    const dirs = await this.memFs.promises.readdir(
      normalizedPath,
      ...args
    );
    console.log("EPHEMERAL: READDIR: ", dirs);
    return dirs;
  }
  async readlink(path6) {
    throw new Error("readlink is not implemented for EphemeralFileSubFs");
  }
  async unlink(path6) {
    const normalizedPath = this.normalizePath(path6);
    return await this.memFs.promises.unlink(normalizedPath);
  }
  async rename(oldPath, newPath) {
    const normalizedOld = this.normalizePath(oldPath);
    const normalizedNew = this.normalizePath(newPath);
    return await this.memFs.promises.rename(normalizedOld, normalizedNew);
  }
  async rmdir(path6, options) {
    const normalizedPath = this.normalizePath(path6);
    return await this.memFs.promises.rmdir(normalizedPath, options);
  }
  async symlink(target, path6, type) {
    const normalizedTarget = this.normalizePath(target);
    const normalizedPath = this.normalizePath(path6);
    return await this.memFs.promises.symlink(
      normalizedTarget,
      normalizedPath,
      type
    );
  }
  async lookup(filePath) {
    throw new Error(`lookup is not implemented for: ${this.toStr(filePath)}`);
  }
  async close(fh) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      await fileHandle.close();
      this.openFh.delete(fh.subFsFileDescriptor);
    }
  }
  async dataSync(fh) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.datasync();
    }
  }
  async read(fh, buffer, offset, length, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.read(buffer, offset, length, position);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async fchmod(fh, mode) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.chmod(mode);
    }
  }
  async fchown(fh, uid, gid) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.chown(uid, gid);
    }
  }
  async write(fh, buffer, offset, length, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.write(
        buffer,
        offset,
        length,
        position
      );
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async ftruncate(fh, len) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.truncate(len);
    }
  }
  resolvePath(fd) {
    throw new Error(`resolvePath is not implemented: resolvePath(${fd})`);
  }
  async fstat(fh, options) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.stat(options);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async futimes(fh, atime, mtime) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.utimes(atime, mtime);
    }
  }
  async writev(fh, buffers, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.writev(buffers, position ?? void 0);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async readv(fh, buffers, position) {
    const fileHandle = this.openFh.get(fh.subFsFileDescriptor);
    if (fileHandle) {
      return await fileHandle.readv(buffers, position ?? void 0);
    }
    throw new Error(`File handle not found: ${fh.subFsFileDescriptor}`);
  }
  async readFile(path6, options) {
    if (typeof path6 === "string" || Buffer.isBuffer(path6)) {
      const normalizedPath = this.normalizePath(path6);
      return this.memFs.promises.readFile(normalizedPath, options);
    }
    return super.readFile(path6, options);
  }
  async writeFile(filePath, data, options) {
    const normalizedPath = this.normalizePath(filePath);
    const parentPath = path4.dirname(normalizedPath);
    if (parentPath && parentPath !== "/" && parentPath !== ".") {
      await this.memFs.promises.mkdir(parentPath, { recursive: true });
    }
    return this.memFs.promises.writeFile(normalizedPath, data, options);
  }
};
__name(_EphemeralSubFs, "EphemeralSubFs");
var EphemeralSubFs = _EphemeralSubFs;

// src/compositeFs/subsystems/git/GitSubFs.ts
var path5 = __toESM(require_path_browserify(), 1);
var import_memfs4 = __toESM(require_lib4(), 1);

// src/compositeFs/subsystems/git/virtualFiles/gitBranchesListVirtualFile.ts
var import_isomorphic_git = __toESM(require_isomorphic_git(), 1);
var gitBranchesListVirtualFile = {
  type: "gitBranchesListVirtualFile",
  getStats: /* @__PURE__ */ __name(async ({ gitRoot, nodeFs }) => {
    const gitDir = gitRoot + "/.git";
    try {
      const gitStats = await nodeFs.stat(gitDir);
      return gitStats;
    } catch (err) {
      throw new Error(`ENOENT: no such file or directory, stat '${gitDir}'`);
    }
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async ({ gitRoot, nodeFs }) => {
    try {
      const branches = await import_isomorphic_git.default.listBranches({ fs: nodeFs, dir: gitRoot });
      const currentBranch2 = await import_isomorphic_git.default.currentBranch({
        fs: nodeFs,
        dir: gitRoot
      });
      const branchesInfo = await Promise.all(
        branches.map(async (branch) => {
          const oid = await import_isomorphic_git.default.resolveRef({
            fs: nodeFs,
            dir: gitRoot,
            ref: branch
          });
          return branch;
        })
      );
      return {
        type: "directory",
        content: branchesInfo,
        mode: 493,
        size: branchesInfo
      };
    } catch (error) {
      throw error;
    }
  }, "getFile"),
  rename: /* @__PURE__ */ __name(async (args) => {
    throw new Error("not implemented");
  }, "rename"),
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/gitBranchFileVirtualFile.ts
var import_isomorphic_git3 = __toESM(require_isomorphic_git(), 1);

// src/compositeFs/subsystems/git/virtualFiles/utils.ts
var import_isomorphic_git2 = __toESM(require_isomorphic_git(), 1);
async function tryResolveRef(fs, gitRoot, refName) {
  try {
    const branchCommit = await import_isomorphic_git2.default.resolveRef({
      fs,
      dir: gitRoot,
      ref: `refs/heads/${refName}`
    });
    return branchCommit;
  } catch (e) {
    return void 0;
  }
}
__name(tryResolveRef, "tryResolveRef");
async function buildUpdatedTree({
  dir,
  fs,
  treeOid: currentOid,
  deletePathParts,
  addPathParts,
  addObj
}) {
  const [currentPathPartAdded, ...restPathPartsAdded] = addPathParts ?? [];
  const [currentPathPartDeleted, ...restPathPartsDeleted] = deletePathParts ?? [];
  let newEntries = [];
  if (currentOid) {
    const { tree } = await import_isomorphic_git2.default.readTree({ fs, dir, oid: currentOid });
    newEntries = [...tree];
  }
  if (currentPathPartAdded === currentPathPartDeleted) {
    const currentPart = currentPathPartAdded;
    if (currentPart === void 0) {
      throw new Error("illegal arguement - called with out a path part");
    }
    if (restPathPartsAdded.length === 0) {
      throw new Error("can not move into it self");
    }
    if (restPathPartsDeleted.length === 0) {
      throw new Error("can not move from it self");
    }
    const idx = newEntries.findIndex((e) => e.path === currentPart);
    const entry = idx !== -1 ? newEntries[idx] : void 0;
    let subtreeOid = entry?.oid;
    const newSubtreeOid = await buildUpdatedTree({
      dir,
      fs,
      treeOid: subtreeOid,
      addPathParts: restPathPartsAdded,
      deletePathParts: restPathPartsDeleted,
      addObj
    });
    if (newSubtreeOid === void 0) {
      throw new Error(
        "on the same path we expect an update - respectivly a newly created subTreeOid"
      );
    }
    let updated = false;
    if (newSubtreeOid !== subtreeOid) {
      updated = true;
      const treeEntry = {
        mode: "040000",
        path: currentPart,
        oid: newSubtreeOid,
        type: "tree"
      };
      if (idx !== -1) {
        newEntries[idx] = treeEntry;
      } else {
        newEntries.push(treeEntry);
      }
    }
    if (currentOid == void 0 && !updated) {
      throw new Error(
        "Illegal state - if the currentOid is undefined - a new tree should have been created (an update should have happened)"
      );
    }
    if (updated) {
      const newOid = await import_isomorphic_git2.default.writeTree({ fs, dir, tree: newEntries });
      return newOid;
    } else {
      if (currentOid === void 0) {
        throw new Error(
          "currentOid should be set - since the sub tree didn't exist and "
        );
      }
      return currentOid;
    }
  } else {
    let updated = false;
    let entryToMove;
    if (currentPathPartDeleted) {
      const idx = newEntries.findIndex((e) => e.path === currentPathPartDeleted);
      const entry = idx !== -1 ? newEntries[idx] : void 0;
      if (entry === void 0) {
        throw new Error("Element doesnt exist in tree");
      }
      if (restPathPartsDeleted.length > 0) {
        if (entry && entry.type !== "tree") {
          throw new Error(
            "SubPart of the path for the obj to delete is not a tree"
          );
        }
        const newSubtreeOid = await buildUpdatedTree({
          dir,
          fs,
          treeOid: entry.oid,
          addPathParts: void 0,
          // passing undefined to delete in this folderbranch only
          deletePathParts: restPathPartsDeleted,
          addObj
        });
        if (newSubtreeOid === entry.oid) {
          throw new Error(
            "in case of a delete we expect a different subtree oid"
          );
        }
        updated = true;
        if (newSubtreeOid === void 0) {
          newEntries.splice(idx, 1);
        } else {
          newEntries[idx] = {
            mode: "040000",
            path: currentPathPartDeleted,
            oid: newSubtreeOid,
            type: "tree"
          };
        }
      } else {
        updated = true;
        newEntries.splice(idx, 1);
      }
      entryToMove = entry;
    }
    if (currentPathPartAdded) {
      const idx = newEntries.findIndex((e) => e.path === currentPathPartAdded);
      const entry = idx !== -1 ? newEntries[idx] : void 0;
      if (restPathPartsAdded.length > 0) {
        if (entry && entry.type !== "tree") {
          throw new Error(
            "SubPart of the path for the obj to add is not a tree"
          );
        }
        const newSubtreeOid = await buildUpdatedTree({
          dir,
          fs,
          treeOid: entry?.oid,
          // might be undefined - to signal creation,
          addPathParts: restPathPartsAdded,
          // passing undefined to delete in this folderbranch only
          deletePathParts: void 0,
          addObj
        });
        if (newSubtreeOid === void 0) {
          throw new Error(
            "in case we add, we expect an update - respectivly a newly created subTreeOid"
          );
        }
        if (newSubtreeOid !== entry?.oid) {
          updated = true;
          const treeEntry = {
            mode: "040000",
            path: currentPathPartAdded,
            oid: newSubtreeOid,
            type: "tree"
          };
          if (idx !== -1) {
            newEntries[idx] = treeEntry;
          } else {
            newEntries.push(treeEntry);
          }
        }
      } else {
        updated = true;
        const treeEntry = {
          mode: addObj.type === "tree" ? "040000" : "100644",
          // mode for file
          path: currentPathPartAdded,
          oid: addObj.oid,
          type: addObj.type
        };
        if (idx !== -1) {
          newEntries[idx] = treeEntry;
        } else {
          newEntries.push(treeEntry);
        }
      }
    }
    if (newEntries.length === 0) {
      return void 0;
    }
    if (updated) {
      const newOid = await import_isomorphic_git2.default.writeTree({ fs, dir, tree: newEntries });
      return newOid;
    } else {
      if (currentOid === void 0) {
        throw new Error(
          "currentOid should be set - since the sub tree didn't exist and "
        );
      }
      return currentOid;
    }
  }
}
__name(buildUpdatedTree, "buildUpdatedTree");
async function resolveGitObjAtPath({
  filePath,
  gitRoot,
  nodeFs,
  commitSha,
  pathParams
}) {
  if (!pathParams.filePath) {
    const tree = await import_isomorphic_git2.default.readTree({
      fs: nodeFs,
      dir: gitRoot,
      oid: commitSha
    });
    const entries = tree.tree.map((entry) => entry.path);
    return {
      type: "tree",
      entries,
      oid: tree.oid
    };
  }
  const results = await import_isomorphic_git2.default.walk({
    fs: nodeFs,
    dir: gitRoot,
    trees: [import_isomorphic_git2.default.TREE({ ref: commitSha })],
    map: /* @__PURE__ */ __name(async (filepath, [entry]) => {
      if (filepath === pathParams.filePath && entry) {
        const type = await entry.type();
        if (type === "blob") {
          return {
            type: "blob",
            oid: await entry.oid()
          };
        } else if (type == "tree") {
          const tree = await import_isomorphic_git2.default.readTree({
            fs: nodeFs,
            dir: gitRoot,
            oid: await entry.oid()
          });
          const entries = tree.tree.map((entry2) => entry2.path);
          return {
            type: "tree",
            entries,
            oid: tree.oid
          };
        }
      }
      return;
    }, "map")
  });
  const fileOrFolder = results.find(
    (r) => r !== void 0
  );
  return fileOrFolder;
}
__name(resolveGitObjAtPath, "resolveGitObjAtPath");

// src/compositeFs/errors/ENOENTError.ts
var _ENOENTError = class _ENOENTError extends Error {
  constructor(message, path6) {
    super(message);
    __publicField(this, "code", "ENOENT");
    __publicField(this, "path");
    this.name = "ENOENTError";
    this.path = path6;
    Object.setPrototypeOf(this, _ENOENTError.prototype);
  }
};
__name(_ENOENTError, "ENOENTError");
var ENOENTError = _ENOENTError;

// src/compositeFs/subsystems/git/virtualFiles/gitBranchFileVirtualFile.ts
async function buildTreeWithoutFile(compositFs, gitRoot, treeOid, pathParts) {
  const [currentPart, ...restParts] = pathParts;
  if (!currentPart) {
    return treeOid;
  }
  const { tree } = await import_isomorphic_git3.default.readTree({
    fs: compositFs,
    dir: gitRoot,
    oid: treeOid
  });
  let newEntries = [...tree];
  const entryIndex = newEntries.findIndex((e) => e.path === currentPart);
  if (entryIndex === -1) {
    return treeOid;
  }
  if (restParts.length === 0) {
    newEntries.splice(entryIndex, 1);
  } else {
    const entry = newEntries[entryIndex];
    if (entry && entry.type === "tree") {
      const newSubtreeOid = await buildTreeWithoutFile(
        compositFs,
        gitRoot,
        entry.oid,
        restParts
      );
      if (newSubtreeOid !== entry.oid) {
        newEntries[entryIndex] = {
          mode: entry.mode,
          path: entry.path,
          type: entry.type,
          oid: newSubtreeOid
        };
      } else {
        return treeOid;
      }
    } else {
      return treeOid;
    }
  }
  return await import_isomorphic_git3.default.writeTree({
    fs: compositFs,
    dir: gitRoot,
    tree: newEntries
  });
}
__name(buildTreeWithoutFile, "buildTreeWithoutFile");
var gitBranchFileVirtualFile = {
  type: "gitBranchFileVirtualFile",
  getStats: /* @__PURE__ */ __name(async ({ gitRoot, nodeFs, filePath, cacheFs, pathParams }) => {
    if (pathParams.branchName === void 0) {
      throw new Error("branchName should be in pathParams");
    }
    let branchCommit = await tryResolveRef(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    if (!branchCommit) {
      throw new ENOENTError(
        `ENOENT: no such file or directory, stat '${filePath}'`,
        filePath
      );
    }
    const fileOrFolder = await resolveGitObjAtPath({
      filePath,
      gitRoot,
      nodeFs,
      commitSha: branchCommit,
      pathParams
    });
    if (!fileOrFolder) {
      throw new ENOENTError(
        `ENOENT: no such file or directory, stat '${filePath}'`,
        filePath
      );
    }
    const commit = await import_isomorphic_git3.default.readCommit({
      fs: nodeFs,
      dir: gitRoot,
      oid: branchCommit
    });
    const { commit: commitObj } = commit;
    const commitTimeMs = commitObj.committer.timestamp * 1e3;
    if (fileOrFolder.type === "tree") {
      return {
        mode: 420,
        size: 0,
        // start with no time,
        isFile: /* @__PURE__ */ __name(() => true, "isFile"),
        isDirectory: /* @__PURE__ */ __name(() => true, "isDirectory"),
        isSymbolicLink: /* @__PURE__ */ __name(() => false, "isSymbolicLink"),
        isBlockDevice: /* @__PURE__ */ __name(() => false, "isBlockDevice"),
        isCharacterDevice: /* @__PURE__ */ __name(() => false, "isCharacterDevice"),
        isSocket: /* @__PURE__ */ __name(() => false, "isSocket"),
        isFIFO: /* @__PURE__ */ __name(() => false, "isFIFO"),
        isFileSync: /* @__PURE__ */ __name(() => true, "isFileSync"),
        isDirectorySync: /* @__PURE__ */ __name(() => false, "isDirectorySync"),
        dev: 0,
        ino: 0,
        nlink: 1,
        uid: 0,
        gid: 0,
        rdev: 0,
        blksize: 4096,
        blocks: 0,
        atimeMs: commitTimeMs,
        mtimeMs: commitTimeMs,
        ctimeMs: commitTimeMs,
        birthtimeMs: commitTimeMs,
        atime: new Date(commitTimeMs),
        mtime: new Date(commitTimeMs),
        ctime: new Date(commitTimeMs),
        birthtime: new Date(commitTimeMs)
      };
    } else {
      const { blob } = await import_isomorphic_git3.default.readBlob({
        fs: nodeFs,
        dir: gitRoot,
        oid: fileOrFolder.oid
      });
      return {
        mode: 420,
        size: blob.length,
        isFile: /* @__PURE__ */ __name(() => true, "isFile"),
        isDirectory: /* @__PURE__ */ __name(() => false, "isDirectory"),
        isSymbolicLink: /* @__PURE__ */ __name(() => false, "isSymbolicLink"),
        isBlockDevice: /* @__PURE__ */ __name(() => false, "isBlockDevice"),
        isCharacterDevice: /* @__PURE__ */ __name(() => false, "isCharacterDevice"),
        isSocket: /* @__PURE__ */ __name(() => false, "isSocket"),
        isFIFO: /* @__PURE__ */ __name(() => false, "isFIFO"),
        isFileSync: /* @__PURE__ */ __name(() => true, "isFileSync"),
        isDirectorySync: /* @__PURE__ */ __name(() => false, "isDirectorySync"),
        dev: 0,
        ino: 0,
        nlink: 1,
        uid: 0,
        gid: 0,
        rdev: 0,
        blksize: 4096,
        blocks: Math.ceil(blob.length / 4096),
        atimeMs: commitTimeMs,
        mtimeMs: commitTimeMs,
        ctimeMs: commitTimeMs,
        birthtimeMs: commitTimeMs,
        atime: new Date(commitTimeMs),
        mtime: new Date(commitTimeMs),
        ctime: new Date(commitTimeMs),
        birthtime: new Date(commitTimeMs)
      };
    }
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async ({ filePath, gitRoot, nodeFs, cacheFs, pathParams }) => {
    if (pathParams.branchName === void 0) {
      throw new Error("branchName should be in pathParams");
    }
    let memoryDirEntries = [];
    try {
      let branchCommit = await tryResolveRef(
        nodeFs,
        gitRoot,
        pathParams.branchName
      );
      let refbranchCommit = await tryResolveRef(
        nodeFs,
        gitRoot,
        "refs/heads/" + pathParams.branchName
      );
      if (!branchCommit) {
        const currentHead = await import_isomorphic_git3.default.resolveRef({
          fs: nodeFs,
          dir: gitRoot,
          ref: "HEAD"
        });
        await import_isomorphic_git3.default.branch({
          fs: nodeFs,
          dir: gitRoot,
          ref: pathParams.branchName,
          object: currentHead
        });
        branchCommit = await import_isomorphic_git3.default.resolveRef({
          fs: nodeFs,
          ref: `refs/heads/${pathParams.branchName}`,
          dir: gitRoot
        });
      }
      const fileOrFolder = await resolveGitObjAtPath({
        filePath,
        gitRoot,
        nodeFs,
        commitSha: branchCommit,
        pathParams
      });
      if (!fileOrFolder) {
        return void 0;
      }
      if (fileOrFolder.type === "blob") {
        const { blob } = await import_isomorphic_git3.default.readBlob({
          fs: nodeFs,
          dir: gitRoot,
          oid: fileOrFolder.oid
        });
        return {
          type: "file",
          content: Buffer.from(blob),
          mode: 420,
          size: blob.length,
          oid: fileOrFolder.oid
        };
      } else {
        const cacheEntries = [];
        try {
          const stat = await cacheFs.promises.stat(filePath);
          if (stat && stat.isDirectory()) {
            const cached = await cacheFs.promises.readdir(filePath, {
              withFileTypes: false,
              encoding: "utf-8"
            });
            cacheEntries.push(
              ...cached.filter((v) => v !== ".keep")
            );
          }
        } catch (e) {
        }
        const allEntries = Array.from(
          /* @__PURE__ */ new Set([
            ...fileOrFolder.entries.filter((v) => v !== ".keep"),
            ...cacheEntries
          ])
        );
        return {
          type: "directory",
          content: allEntries,
          mode: 493
        };
      }
    } catch (error) {
      return void 0;
    }
  }, "getFile"),
  // TODO move to vfile
  unlink: /* @__PURE__ */ __name(async ({ filePath, gitRoot, nodeFs, cacheFs, pathParams }) => {
    if (!pathParams.branchName) {
      throw new Error("branchName should be in pathParams");
    }
    if (!pathParams.filePath) {
      throw new Error("filePath should be in pathParams");
    }
    const branchCommit = await import_isomorphic_git3.default.resolveRef({
      fs: nodeFs,
      dir: gitRoot,
      ref: pathParams.branchName
    });
    const currentTree = await import_isomorphic_git3.default.readTree({
      fs: nodeFs,
      dir: gitRoot,
      oid: branchCommit
    });
    const newTreeOid = await buildTreeWithoutFile(
      nodeFs,
      gitRoot,
      currentTree.oid,
      pathParams.filePath.split("/")
    );
    if (newTreeOid !== currentTree.oid) {
      const newCommitOid = await import_isomorphic_git3.default.commit({
        fs: nodeFs,
        dir: gitRoot,
        message: `Delete ${pathParams.filePath}`,
        tree: newTreeOid,
        noUpdateBranch: true,
        parent: [branchCommit],
        author: {
          name: "GitLegitFs",
          email: "gitlegit@example.com",
          timestamp: Math.floor(Date.now() / 1e3),
          timezoneOffset: 0
        }
      });
      await import_isomorphic_git3.default.writeRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${pathParams.branchName}`,
        value: newCommitOid,
        force: true
      });
    }
  }, "unlink"),
  writeFile: /* @__PURE__ */ __name(async ({
    filePath,
    gitRoot,
    nodeFs,
    content,
    cacheFs,
    pathParams
  }) => {
    if (pathParams.branchName === void 0) {
      throw new Error("branchName should be in pathParams");
    }
    if (pathParams.filePath === void 0) {
      throw new Error("filePath should be in pathParams");
    }
    let blob;
    if (typeof content === "string") {
      blob = new TextEncoder().encode(content);
    } else {
      blob = new Uint8Array(content);
    }
    const newOid = await import_isomorphic_git3.default.writeBlob({
      fs: nodeFs,
      dir: gitRoot,
      blob
    });
    let branchCommit = await tryResolveRef(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    if (!branchCommit) {
      const currentHead = await import_isomorphic_git3.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: "HEAD"
      });
      await import_isomorphic_git3.default.branch({
        fs: nodeFs,
        dir: gitRoot,
        ref: pathParams.branchName,
        object: currentHead
      });
      branchCommit = await import_isomorphic_git3.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${pathParams.branchName}`
      });
    }
    const currentTree = await import_isomorphic_git3.default.readTree({
      fs: nodeFs,
      dir: gitRoot,
      oid: branchCommit
    });
    const newTreeOid = await buildUpdatedTree({
      dir: gitRoot,
      fs: nodeFs,
      treeOid: currentTree.oid,
      addPathParts: pathParams.filePath.split("/"),
      deletePathParts: void 0,
      addObj: { type: "blob", oid: newOid }
    });
    if (newTreeOid !== currentTree.oid) {
      const newCommitOid = await import_isomorphic_git3.default.commit({
        fs: nodeFs,
        dir: gitRoot,
        message: `\u{1F4BE} Change '${pathParams.filePath}'`,
        tree: newTreeOid,
        noUpdateBranch: true,
        parent: [branchCommit],
        author: {
          name: "GitLegitFs",
          email: "gitlegit@example.com",
          timestamp: Math.floor(Date.now() / 1e3),
          timezoneOffset: 0
        }
      });
      await import_isomorphic_git3.default.writeRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${pathParams.branchName}`,
        value: newCommitOid,
        force: true
      });
    }
  }, "writeFile"),
  rename: /* @__PURE__ */ __name(async function({
    filePath,
    newPath,
    gitRoot,
    nodeFs,
    pathParams,
    newPathParams
  }) {
    if (pathParams.branchName === void 0) {
      throw new Error("branchName should be in pathParams");
    }
    if (pathParams.filePath === void 0) {
      throw new Error("filePath should be in pathParams");
    }
    if (newPathParams.branchName === void 0) {
      throw new Error("branchName should be in newPathParams");
    }
    if (newPathParams.filePath === void 0) {
      throw new Error("filePath should be in newPathParams");
    }
    const oldBranchCommit = await tryResolveRef(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    if (!oldBranchCommit) {
      throw new Error("Invalid branch file path - source branch must exist");
    }
    let currentBranchCommit = await tryResolveRef(
      nodeFs,
      gitRoot,
      newPathParams.branchName
    );
    if (!currentBranchCommit) {
      const currentHead = await import_isomorphic_git3.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: "HEAD"
      });
      await import_isomorphic_git3.default.branch({
        fs: nodeFs,
        dir: gitRoot,
        ref: newPathParams.branchName,
        object: currentHead
      });
      currentBranchCommit = await import_isomorphic_git3.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${newPathParams.branchName}`
      });
    }
    if (newPathParams.branchName !== pathParams.branchName) {
      throw new Error("cross branch move not implemented yet");
    }
    const existingAtOldPath = await resolveGitObjAtPath({
      gitRoot,
      nodeFs,
      commitSha: oldBranchCommit,
      filePath,
      pathParams
    });
    if (existingAtOldPath === void 0) {
      throw new Error("no obj at path exists");
    }
    const newTreeOid = await buildUpdatedTree({
      dir: gitRoot,
      fs: nodeFs,
      deletePathParts: pathParams.filePath.split("/"),
      addPathParts: newPathParams.filePath.split("/"),
      addObj: existingAtOldPath,
      treeOid: currentBranchCommit
    });
    const currentTree = await import_isomorphic_git3.default.readTree({
      fs: nodeFs,
      dir: gitRoot,
      oid: oldBranchCommit
    });
    if (newTreeOid !== currentTree.oid) {
      const newCommitOid = await import_isomorphic_git3.default.commit({
        fs: nodeFs,
        dir: gitRoot,
        message: `\u{1F500} Rename '${pathParams.filePath}' to '${newPathParams.filePath}'`,
        tree: newTreeOid,
        noUpdateBranch: true,
        parent: [currentBranchCommit],
        author: {
          name: "GitLegitFs",
          email: "gitlegit@example.com",
          timestamp: Math.floor(Date.now() / 1e3),
          timezoneOffset: 0
        }
      });
      await import_isomorphic_git3.default.writeRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${newPathParams.branchName}`,
        value: newCommitOid,
        force: true
      });
    }
  }, "rename"),
  mkdir: /* @__PURE__ */ __name(async function(args) {
    try {
      await gitBranchFileVirtualFile.getStats(args);
      throw new Error("Folder exists");
    } catch (err) {
    }
    if (args.filePath.endsWith("/")) {
      args.filePath = args.filePath.replace(/\/+$/, "");
    }
    if (args.pathParams && typeof args.pathParams.filePath === "string") {
      args.pathParams.filePath = args.pathParams.filePath.replace(/\/+$/, "");
    }
    const createFileArgs = {
      ...args,
      filePath: args.filePath += ".keep",
      content: ""
    };
    createFileArgs.pathParams.filePath += "/.keep";
    await gitBranchFileVirtualFile.writeFile(createFileArgs);
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/gitBranchHeadVirtualFile.ts
var import_isomorphic_git4 = __toESM(require_isomorphic_git(), 1);
var gitBranchHeadVirtualFile = {
  type: "gitBranchHeadVirtualFile",
  getStats: /* @__PURE__ */ __name(async ({ gitRoot, nodeFs, pathParams }) => {
    if (pathParams.branchName === void 0) {
      throw new Error("branchName should be in pathParams");
    }
    let headCommit;
    try {
      headCommit = await import_isomorphic_git4.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: pathParams.branchName
      });
    } catch {
      headCommit = await import_isomorphic_git4.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${pathParams.branchName}`
      });
    }
    const commit = await import_isomorphic_git4.default.readCommit({
      fs: nodeFs,
      dir: gitRoot,
      oid: headCommit
    });
    const { commit: commitObj } = commit;
    const commitTimeMs = commitObj.committer.timestamp * 1e3;
    return {
      mode: 420,
      size: 40,
      isFile: /* @__PURE__ */ __name(() => true, "isFile"),
      isDirectory: /* @__PURE__ */ __name(() => false, "isDirectory"),
      isSymbolicLink: /* @__PURE__ */ __name(() => false, "isSymbolicLink"),
      isBlockDevice: /* @__PURE__ */ __name(() => false, "isBlockDevice"),
      isCharacterDevice: /* @__PURE__ */ __name(() => false, "isCharacterDevice"),
      isSocket: /* @__PURE__ */ __name(() => false, "isSocket"),
      isFIFO: /* @__PURE__ */ __name(() => false, "isFIFO"),
      isFileSync: /* @__PURE__ */ __name(() => true, "isFileSync"),
      isDirectorySync: /* @__PURE__ */ __name(() => false, "isDirectorySync"),
      dev: 0,
      ino: 0,
      nlink: 1,
      uid: 0,
      gid: 0,
      rdev: 0,
      blksize: 4096,
      blocks: Math.ceil(40 / 4096),
      atimeMs: commitTimeMs,
      mtimeMs: commitTimeMs,
      ctimeMs: commitTimeMs,
      birthtimeMs: commitTimeMs,
      atime: new Date(commitTimeMs),
      mtime: new Date(commitTimeMs),
      ctime: new Date(commitTimeMs),
      birthtime: new Date(commitTimeMs)
    };
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async ({ gitRoot, nodeFs, pathParams }) => {
    if (pathParams.branchName === void 0) {
      throw new Error("branchName should be in pathParams");
    }
    try {
      let headCommit;
      try {
        headCommit = await import_isomorphic_git4.default.resolveRef({
          fs: nodeFs,
          dir: gitRoot,
          ref: pathParams.branchName
        });
      } catch {
        headCommit = await import_isomorphic_git4.default.resolveRef({
          fs: nodeFs,
          dir: gitRoot,
          ref: `refs/heads/${pathParams.branchName}`
        });
      }
      return {
        type: "file",
        content: headCommit + "\n",
        mode: 420,
        size: headCommit.length
      };
    } catch (error) {
      return void 0;
    }
  }, "getFile"),
  rename(args) {
    throw new Error("not implementsd");
  },
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/gitBranchTipVirtualFile.ts
var import_isomorphic_git5 = __toESM(require_isomorphic_git(), 1);
var gitBranchTipVirtualFile = {
  type: "gitBranchTipVirtualFile",
  getStats: /* @__PURE__ */ __name(async (args) => {
    const gitDir = args.gitRoot + "/.git";
    try {
      const gitStats = await args.fs.stat(gitDir);
      return gitStats;
    } catch (err) {
      throw new Error(`ENOENT: no such file or directory, stat '${gitDir}'`);
    }
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async ({ filePath, gitRoot, nodeFs, pathParams }) => {
    if (!pathParams.branchName) {
      throw new Error("branchName should be in pathParams");
    }
    try {
      const tipCommit = await import_isomorphic_git5.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${pathParams.branchName}`
      });
      return {
        type: "file",
        content: tipCommit + "\n",
        mode: 420,
        size: tipCommit.length + 1
      };
    } catch (error) {
      return void 0;
    }
  }, "getFile"),
  rename(args) {
    throw new Error("not implementsd");
  },
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/gitCommitFileVirtualFile.ts
var import_isomorphic_git6 = __toESM(require_isomorphic_git(), 1);
var gitCommitFileVirtualFile = {
  type: "gitCommitFileVirtualFile",
  getStats: /* @__PURE__ */ __name(async ({ filePath, gitRoot, nodeFs, pathParams }) => {
    if (!pathParams.sha_1_1_2) {
      throw new Error("sha_1_1_2 should be in pathParams");
    }
    if (!pathParams.sha1_3__40) {
      throw new Error("sha1_3__40 should be in pathParams");
    }
    const commitSha = pathParams.sha_1_1_2 + pathParams.sha1_3__40;
    const fileOrFolder = await resolveGitObjAtPath({
      filePath,
      gitRoot,
      nodeFs,
      commitSha,
      pathParams
    });
    if (!fileOrFolder) {
      throw new ENOENTError(
        `ENOENT: no such file or directory, stat '${filePath}'`,
        filePath
      );
    }
    const commit = await import_isomorphic_git6.default.readCommit({
      fs: nodeFs,
      dir: gitRoot,
      oid: commitSha
    });
    const { commit: commitObj } = commit;
    const commitTimeMs = commitObj.committer.timestamp * 1e3;
    if (fileOrFolder.type === "tree") {
      return {
        mode: 420,
        size: 0,
        // start with no time,
        isFile: /* @__PURE__ */ __name(() => true, "isFile"),
        isDirectory: /* @__PURE__ */ __name(() => true, "isDirectory"),
        isSymbolicLink: /* @__PURE__ */ __name(() => false, "isSymbolicLink"),
        isBlockDevice: /* @__PURE__ */ __name(() => false, "isBlockDevice"),
        isCharacterDevice: /* @__PURE__ */ __name(() => false, "isCharacterDevice"),
        isSocket: /* @__PURE__ */ __name(() => false, "isSocket"),
        isFIFO: /* @__PURE__ */ __name(() => false, "isFIFO"),
        isFileSync: /* @__PURE__ */ __name(() => true, "isFileSync"),
        isDirectorySync: /* @__PURE__ */ __name(() => false, "isDirectorySync"),
        dev: 0,
        ino: 0,
        nlink: 1,
        uid: 0,
        gid: 0,
        rdev: 0,
        blksize: 4096,
        blocks: 0,
        atimeMs: commitTimeMs,
        mtimeMs: commitTimeMs,
        ctimeMs: commitTimeMs,
        birthtimeMs: commitTimeMs,
        atime: new Date(commitTimeMs),
        mtime: new Date(commitTimeMs),
        ctime: new Date(commitTimeMs),
        birthtime: new Date(commitTimeMs)
      };
    } else {
      const { blob } = await import_isomorphic_git6.default.readBlob({
        fs: nodeFs,
        dir: gitRoot,
        oid: fileOrFolder.oid
      });
      return {
        mode: 420,
        size: blob.length,
        isFile: /* @__PURE__ */ __name(() => true, "isFile"),
        isDirectory: /* @__PURE__ */ __name(() => false, "isDirectory"),
        isSymbolicLink: /* @__PURE__ */ __name(() => false, "isSymbolicLink"),
        isBlockDevice: /* @__PURE__ */ __name(() => false, "isBlockDevice"),
        isCharacterDevice: /* @__PURE__ */ __name(() => false, "isCharacterDevice"),
        isSocket: /* @__PURE__ */ __name(() => false, "isSocket"),
        isFIFO: /* @__PURE__ */ __name(() => false, "isFIFO"),
        isFileSync: /* @__PURE__ */ __name(() => true, "isFileSync"),
        isDirectorySync: /* @__PURE__ */ __name(() => false, "isDirectorySync"),
        dev: 0,
        ino: 0,
        nlink: 1,
        uid: 0,
        gid: 0,
        rdev: 0,
        blksize: 4096,
        blocks: Math.ceil(blob.length / 4096),
        atimeMs: commitTimeMs,
        mtimeMs: commitTimeMs,
        ctimeMs: commitTimeMs,
        birthtimeMs: commitTimeMs,
        atime: new Date(commitTimeMs),
        mtime: new Date(commitTimeMs),
        ctime: new Date(commitTimeMs),
        birthtime: new Date(commitTimeMs)
      };
    }
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async ({ filePath, gitRoot, nodeFs, pathParams }) => {
    if (!pathParams.sha_1_1_2) {
      throw new Error("sha_1_1_2 should be in pathParams");
    }
    if (!pathParams.sha1_3__40) {
      throw new Error("sha1_3__40 should be in pathParams");
    }
    const commitSha = pathParams.sha_1_1_2 + pathParams.sha1_3__40;
    try {
      const fileOrFolder = await resolveGitObjAtPath({
        filePath,
        gitRoot,
        nodeFs,
        commitSha,
        pathParams
      });
      if (!fileOrFolder) {
        return void 0;
      }
      if (fileOrFolder.type === "blob") {
        const { blob } = await import_isomorphic_git6.default.readBlob({
          fs: nodeFs,
          dir: gitRoot,
          oid: fileOrFolder.oid
        });
        return {
          type: "file",
          content: Buffer.from(blob),
          mode: 420,
          size: blob.length,
          oid: fileOrFolder.oid
        };
      } else {
        const allEntries = Array.from(
          /* @__PURE__ */ new Set([...fileOrFolder.entries.filter((v) => v !== ".keep")])
        );
        return {
          type: "directory",
          content: allEntries,
          mode: 493
        };
      }
    } catch (error) {
      return void 0;
    }
  }, "getFile"),
  rename(args) {
    throw new Error("not implementsd");
  },
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/gitStatusVirtualFile.ts
var import_isomorphic_git7 = __toESM(require_isomorphic_git(), 1);
function getFileStatus(head, workdir, stage) {
  if (head === 0 && workdir === 2 && stage === 0) return "untracked";
  if (head === 1 && workdir === 0 && stage === 0) return "deleted";
  if (head === 1 && workdir === 2 && stage !== 0) return "modified";
  if (head === 0 && workdir === 2 && stage === 2) return "added";
  return "unknown";
}
__name(getFileStatus, "getFileStatus");
var gitStatusVirtualFile = {
  type: "gitStatusVirtualFile",
  getStats: /* @__PURE__ */ __name(async (args) => {
    const gitDir = args.gitRoot + "/.git";
    try {
      const gitStats = await args.fs.stat(gitDir);
      return gitStats;
    } catch (err) {
      throw new Error(`ENOENT: no such file or directory, stat '${gitDir}'`);
    }
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async ({ gitRoot, nodeFs }) => {
    try {
      const currentBranch2 = await import_isomorphic_git7.default.currentBranch({ fs: nodeFs, dir: gitRoot }) || "HEAD";
      const headCommit = await import_isomorphic_git7.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: "HEAD"
      });
      const statusMatrix = await import_isomorphic_git7.default.statusMatrix({ fs: nodeFs, dir: gitRoot });
      const modifiedFiles = statusMatrix.filter(
        ([, head, workdir, stage]) => head !== workdir || workdir !== stage
      ).map(([filepath, head, workdir, stage]) => ({
        path: filepath,
        status: getFileStatus(head, workdir, stage)
      }));
      const content = JSON.stringify(
        {
          branch: currentBranch2,
          commit: headCommit,
          clean: modifiedFiles.length === 0,
          files: modifiedFiles
        },
        null,
        2
      );
      return {
        type: "file",
        content,
        mode: 33188,
        size: Buffer.byteLength(content)
      };
    } catch (err) {
      console.error(err);
      throw err;
    }
  }, "getFile"),
  rename(args) {
    throw new Error("not implementsd");
  },
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/legitVirtualFile.ts
var legitVirtualFile = {
  type: "legitVirtualFile",
  getStats: /* @__PURE__ */ __name(async ({ gitRoot, nodeFs }) => {
    const gitDir = gitRoot + "/.git";
    try {
      const gitStats = await nodeFs.stat(gitDir);
      return gitStats;
    } catch (err) {
      throw new Error(`ENOENT: no such file or directory, stat '${gitDir}'`);
    }
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async ({ gitRoot, nodeFs }) => {
    return {
      type: "directory",
      content: [],
      mode: 493,
      size: 0
    };
  }, "getFile"),
  rename(args) {
    throw new Error("not implementsd");
  },
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/gitVirtualFiles.ts
var allGitVirtualFiles = [
  legitVirtualFile,
  // legit must have the highest prio because it should also match in sub paths for example in /.legit/branches/main/.legit
  gitStatusVirtualFile,
  gitCommitFileVirtualFile,
  gitBranchesListVirtualFile,
  gitBranchFileVirtualFile,
  gitBranchHeadVirtualFile,
  gitBranchTipVirtualFile
];

// src/compositeFs/subsystems/git/LegitPathRouter.ts
var _LegitPathRouter = class _LegitPathRouter {
  constructor(routes) {
    this.routes = routes;
    __publicField(this, "compiledRoutes");
    const flatRoutes = {};
    const walk = /* @__PURE__ */ __name((node, path6) => {
      if (typeof node.type === "string") {
        flatRoutes[path6] = {
          handler: node,
          siblings: []
        };
        const vFile = node;
      } else {
        const siblings = [];
        for (const [segment, child] of Object.entries(node)) {
          if (segment === ".") {
            if (flatRoutes[path6]) {
              throw new Error(
                `Conflict: multiple handlers for path '${path6}', '.' and optional '[[parameter_name]]' defined?`
              );
            }
            flatRoutes[path6] = {
              handler: child,
              siblings
            };
          } else if (segment.startsWith("[[") && segment.endsWith("]]")) {
            if (flatRoutes[path6]) {
              throw new Error(
                `Conflict: multiple handlers for path '${path6}', '.' and optional '[[parameter_name]]' defined?`
              );
            }
            flatRoutes[path6] = {
              handler: child,
              siblings
            };
            if (segment.startsWith("[[...")) {
              flatRoutes[path6 ? `${path6}/${segment}` : segment] = {
                handler: child,
                siblings: []
              };
            } else {
              walk(child, path6 ? `${path6}/${segment}` : segment);
            }
          } else if (segment.startsWith("[") && segment.endsWith("]")) {
            if (segment.startsWith("[...")) {
              flatRoutes[path6 ? `${path6}/${segment}` : segment] = {
                handler: child,
                siblings: []
              };
            } else {
              walk(child, path6 ? `${path6}/${segment}` : segment);
            }
          } else {
            siblings.push(segment);
            walk(child, path6 ? `${path6}/${segment}` : segment);
          }
        }
      }
    }, "walk");
    for (const [root, node] of Object.entries(routes)) {
      walk(node, root);
    }
    this.compiledRoutes = Object.entries(flatRoutes).map(([pattern, entry]) => {
      const paramNames = [];
      const regexStr = pattern.split("/").map((segment) => {
        if (segment.startsWith("[[") && segment.endsWith("]]")) {
          const name = segment.slice(2, -2).replace(/^\.\.\./, "");
          paramNames.push(name);
          return "(.*)";
        }
        if (segment.startsWith("[") && segment.endsWith("]")) {
          const name = segment.slice(1, -1);
          paramNames.push(name);
          return "([^/]+)";
        }
        return segment.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }).join("/");
      const regex = new RegExp(`^${regexStr}$`);
      return {
        regex,
        paramNames,
        staticSiblings: entry.siblings,
        handler: entry.handler
      };
    });
  }
  match(path6) {
    if (path6.length > 1 && path6.endsWith("/")) {
      path6 = path6.replace(/\/+$/, "");
    }
    for (const { regex, paramNames, handler, staticSiblings } of this.compiledRoutes) {
      const match = path6.match(regex);
      if (!match) continue;
      const params = {};
      for (let i = 0; i < paramNames.length; i++) {
        params[paramNames[i]] = decodeURIComponent(match[i + 1] || "");
      }
      return { handler, params, staticSiblings };
    }
    return;
  }
};
__name(_LegitPathRouter, "LegitPathRouter");
var LegitPathRouter = _LegitPathRouter;

// src/compositeFs/subsystems/git/virtualFiles/gitCommitVirtualFolder.ts
var import_isomorphic_git8 = __toESM(require_isomorphic_git(), 1);
var gitCommitVirtualFolder = {
  type: "gitCommitVirtualFolder",
  getStats: /* @__PURE__ */ __name(async (args) => {
    const gitDir = args.gitRoot + "/.git";
    try {
      const gitStats = await args.fs.stat(gitDir);
      return gitStats;
    } catch (err) {
      throw new Error(`ENOENT: no such file or directory, stat '${gitDir}'`);
    }
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async ({ filePath, gitRoot, nodeFs, pathParams }) => {
    const branchNames = await import_isomorphic_git8.default.listBranches({ fs: nodeFs, dir: gitRoot });
    const headCommits = /* @__PURE__ */ new Set();
    const commits = /* @__PURE__ */ new Set();
    for (const branch of branchNames) {
      const ref = `refs/heads/${branch}`;
      try {
        const commitOid = await import_isomorphic_git8.default.resolveRef({
          fs: nodeFs,
          dir: gitRoot,
          ref
        });
        headCommits.add(commitOid);
      } catch (err) {
      }
    }
    for (const headCommit of headCommits) {
      const commitsFromHead = await import_isomorphic_git8.default.log({
        fs: nodeFs,
        dir: gitRoot,
        ref: headCommit
      });
      for (const commit of commitsFromHead) {
        commits.add(commit.oid);
      }
    }
    if (!pathParams.sha_1_1_2) {
      const fistTwo = /* @__PURE__ */ new Set();
      for (const commit of commits) {
        fistTwo.add(commit.slice(0, 2));
        if (fistTwo.size >= 256) {
          break;
        }
      }
      const content2 = Array.from(fistTwo).sort();
      return {
        type: "directory",
        content: content2,
        mode: 493,
        size: content2
      };
    }
    const lastThrityEight = /* @__PURE__ */ new Set();
    for (const commit of commits) {
      if (commit.startsWith(pathParams.sha_1_1_2)) {
        lastThrityEight.add(commit.slice(2, 40));
      }
    }
    const content = Array.from(lastThrityEight).sort();
    return {
      type: "directory",
      content,
      mode: 493,
      size: content.length
    };
  }, "getFile"),
  rename(args) {
    throw new Error("not implementsd");
  },
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/operations/gitBranchOperationVirtualFile.ts
var import_isomorphic_git10 = __toESM(require_isomorphic_git(), 1);

// src/compositeFs/subsystems/git/virtualFiles/operations/resolveOperationBranchName.ts
var import_isomorphic_git9 = __toESM(require_isomorphic_git(), 1);
var operationBranchNamePostfix = "-operation";
async function resolveOperationBranchName(fs, repoPath, branchName) {
  const branches = await import_isomorphic_git9.default.listBranches({ fs, dir: repoPath });
  return branches.filter(
    (b) => b.endsWith("__" + branchName + operationBranchNamePostfix)
  )[0];
}
__name(resolveOperationBranchName, "resolveOperationBranchName");

// src/compositeFs/subsystems/git/virtualFiles/operations/gitBranchOperationVirtualFile.ts
var gitBranchOperationVirtualFile = {
  type: "gitBranchOperationVirtualFile",
  getStats: /* @__PURE__ */ __name(async (args) => {
    const { gitRoot, nodeFs, pathParams } = args;
    let headCommit;
    try {
      headCommit = await import_isomorphic_git10.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${pathParams.branchName}`
      });
    } catch {
      throw new Error(
        `Base Branch ${pathParams.branchName} for operations does not exis`
      );
    }
    let operationBranchName = await resolveOperationBranchName(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    let hasOperations = false;
    if (operationBranchName) {
      try {
        headCommit = await import_isomorphic_git10.default.resolveRef({
          fs: nodeFs,
          dir: gitRoot,
          ref: operationBranchName
        });
        hasOperations = true;
      } catch {
        try {
          headCommit = await import_isomorphic_git10.default.resolveRef({
            fs: nodeFs,
            dir: gitRoot,
            ref: `refs/heads/${operationBranchName}`
          });
          hasOperations = true;
        } catch {
        }
      }
    }
    const commit = await import_isomorphic_git10.default.readCommit({
      fs: nodeFs,
      dir: gitRoot,
      oid: headCommit
    });
    const { commit: commitObj } = commit;
    const commitTimeMs = commitObj.committer.timestamp * 1e3;
    try {
      return {
        mode: 420,
        size: 40,
        // sha length
        atimeMs: commitTimeMs,
        mtimeMs: commitTimeMs,
        ctimeMs: commitTimeMs,
        birthtimeMs: commitTimeMs,
        atime: new Date(commitTimeMs),
        mtime: new Date(commitTimeMs),
        ctime: new Date(commitTimeMs),
        birthtime: new Date(commitTimeMs),
        // hardcoded to epoch as Date object
        isFile: /* @__PURE__ */ __name(() => true, "isFile"),
        isDirectory: /* @__PURE__ */ __name(() => false, "isDirectory"),
        isSymbolicLink: /* @__PURE__ */ __name(() => false, "isSymbolicLink"),
        isBlockDevice: /* @__PURE__ */ __name(() => false, "isBlockDevice"),
        isCharacterDevice: /* @__PURE__ */ __name(() => false, "isCharacterDevice"),
        isSocket: /* @__PURE__ */ __name(() => false, "isSocket"),
        isFIFO: /* @__PURE__ */ __name(() => false, "isFIFO"),
        isFileSync: /* @__PURE__ */ __name(() => true, "isFileSync"),
        isDirectorySync: /* @__PURE__ */ __name(() => false, "isDirectorySync"),
        dev: 0,
        ino: 0,
        nlink: 1,
        uid: 0,
        gid: 0,
        rdev: 0,
        blksize: 4096,
        blocks: 0
      };
    } catch (err) {
      throw new Error(
        `ENOENT: no such file or directory, stat operationHistory`
      );
    }
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async (args) => {
    const { gitRoot, nodeFs, pathParams } = args;
    let operationBranchName = await resolveOperationBranchName(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    let headCommit;
    let hasOperations = false;
    if (operationBranchName) {
      headCommit = await import_isomorphic_git10.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: operationBranchName
      });
      hasOperations = true;
    } else {
      headCommit = await import_isomorphic_git10.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${pathParams.branchName}`
      });
    }
    return {
      type: "file",
      content: Buffer.from(headCommit),
      mode: 420,
      size: headCommit.length
    };
  }, "getFile"),
  writeFile: /* @__PURE__ */ __name(async ({
    filePath,
    gitRoot,
    nodeFs,
    content,
    cacheFs,
    pathParams
  }) => {
    if (pathParams.branchName === void 0) {
      throw new Error("branchName should be in pathParams");
    }
    let blob;
    if (typeof content === "string") {
      blob = new TextEncoder().encode(content);
    } else {
      blob = new Uint8Array(content);
    }
    const newOid = await import_isomorphic_git10.default.writeBlob({
      fs: nodeFs,
      dir: gitRoot,
      blob
    });
    let branchCommit = await tryResolveRef(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    if (!branchCommit) {
      throw new Error("Invalid branch file path - branch doesn't exist");
    }
    let operationBranchName = await resolveOperationBranchName(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    let firstOperation = false;
    if (!operationBranchName) {
      operationBranchName = "legit/__" + pathParams.branchName + operationBranchNamePostfix;
      await import_isomorphic_git10.default.branch({
        fs: nodeFs,
        dir: gitRoot,
        ref: operationBranchName,
        object: branchCommit
      });
      firstOperation = true;
    }
    const operationBranchCommit = await import_isomorphic_git10.default.resolveRef({
      fs: nodeFs,
      dir: gitRoot,
      ref: `refs/heads/${operationBranchName}`
    });
    const currentTree = await import_isomorphic_git10.default.readTree({
      fs: nodeFs,
      dir: gitRoot,
      oid: branchCommit
    });
    let commitMessage;
    if (content instanceof ArrayBuffer) {
      commitMessage = Buffer.from(content).toString("utf-8");
    } else if (typeof content === "string") {
      commitMessage = content;
    } else if (content instanceof Uint8Array) {
      commitMessage = Buffer.from(content).toString("utf-8");
    } else {
      commitMessage = String(content);
    }
    let branchUnchanged = false;
    if (!firstOperation) {
      const mergeBase = await import_isomorphic_git10.default.findMergeBase({
        fs: nodeFs,
        dir: gitRoot,
        oids: branchUnchanged ? [operationBranchCommit] : [operationBranchCommit, branchCommit]
      });
      if (mergeBase.length === 1 && mergeBase[0] === branchCommit) {
        branchUnchanged = true;
      }
    }
    const newCommitOid = await import_isomorphic_git10.default.commit({
      fs: nodeFs,
      dir: gitRoot,
      message: commitMessage,
      tree: currentTree.oid,
      noUpdateBranch: true,
      // TODO only reference the branch commit if the commit has changed since last operation commit referencing the branch commit
      parent: branchUnchanged ? firstOperation ? [branchCommit, branchCommit] : [operationBranchCommit] : [operationBranchCommit, branchCommit],
      author: {
        name: "GitLegitFs",
        email: "gitlegit@example.com",
        timestamp: Math.floor(Date.now() / 1e3),
        timezoneOffset: 0
      }
    });
    await import_isomorphic_git10.default.writeRef({
      fs: nodeFs,
      dir: gitRoot,
      ref: `refs/heads/${operationBranchName}`,
      value: newCommitOid,
      force: true
    });
  }, "writeFile"),
  rename: /* @__PURE__ */ __name(async function({
    filePath,
    newPath,
    gitRoot,
    nodeFs,
    pathParams,
    newPathParams
  }) {
    throw new Error("not implemented");
  }, "rename"),
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/operations/gitBranchOperationsVirtualFile.ts
var import_isomorphic_git11 = __toESM(require_isomorphic_git(), 1);
var gitBranchOperationsVirtualFile = {
  type: "gitBranchOperationsVirtualFile",
  getStats: /* @__PURE__ */ __name(async (args) => {
    const { gitRoot, nodeFs, pathParams } = args;
    if (pathParams.branchName === void 0) {
      throw new Error("branchName should be in pathParams");
    }
    let operationBranchName = await resolveOperationBranchName(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    let headCommit;
    let hasOperations = false;
    if (operationBranchName) {
      try {
        headCommit = await import_isomorphic_git11.default.resolveRef({
          fs: nodeFs,
          dir: gitRoot,
          ref: operationBranchName
        });
        hasOperations = true;
      } catch {
        try {
          headCommit = await import_isomorphic_git11.default.resolveRef({
            fs: nodeFs,
            dir: gitRoot,
            ref: `refs/heads/${operationBranchName}`
          });
          hasOperations = true;
        } catch {
          throw new Error(
            `Base Branch ${pathParams.branchName} for operations does not exis`
          );
        }
      }
    } else {
      try {
        headCommit = await import_isomorphic_git11.default.resolveRef({
          fs: nodeFs,
          dir: gitRoot,
          ref: `refs/heads/${pathParams.branchName}`
        });
      } catch {
        throw new Error(
          `Base Branch ${pathParams.branchName} for operations does not exis`
        );
      }
    }
    const commit = await import_isomorphic_git11.default.readCommit({
      fs: nodeFs,
      dir: gitRoot,
      oid: headCommit
    });
    const { commit: commitObj } = commit;
    const commitTimeMs = commitObj.committer.timestamp * 1e3;
    try {
      const file = hasOperations ? await gitBranchOperationsVirtualFile.getFile(args) : void 0;
      const size = file?.content?.length ?? 0;
      return {
        mode: 420,
        size,
        atimeMs: commitTimeMs,
        mtimeMs: commitTimeMs,
        ctimeMs: commitTimeMs,
        birthtimeMs: commitTimeMs,
        atime: new Date(commitTimeMs),
        mtime: new Date(commitTimeMs),
        ctime: new Date(commitTimeMs),
        birthtime: new Date(commitTimeMs),
        // hardcoded to epoch as Date object
        isFile: /* @__PURE__ */ __name(() => true, "isFile"),
        isDirectory: /* @__PURE__ */ __name(() => false, "isDirectory"),
        isSymbolicLink: /* @__PURE__ */ __name(() => false, "isSymbolicLink"),
        isBlockDevice: /* @__PURE__ */ __name(() => false, "isBlockDevice"),
        isCharacterDevice: /* @__PURE__ */ __name(() => false, "isCharacterDevice"),
        isSocket: /* @__PURE__ */ __name(() => false, "isSocket"),
        isFIFO: /* @__PURE__ */ __name(() => false, "isFIFO"),
        isFileSync: /* @__PURE__ */ __name(() => true, "isFileSync"),
        isDirectorySync: /* @__PURE__ */ __name(() => false, "isDirectorySync"),
        dev: 0,
        ino: 0,
        nlink: 1,
        uid: 0,
        gid: 0,
        rdev: 0,
        blksize: 4096,
        blocks: 0
      };
    } catch (err) {
      throw new Error(
        `ENOENT: no such file or directory, stat operationHistory`
      );
    }
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async (args) => {
    const { gitRoot, nodeFs, pathParams } = args;
    let operationBranchName = await resolveOperationBranchName(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    let operations = [];
    if (operationBranchName) {
      const operationBranchRef = await import_isomorphic_git11.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${operationBranchName}`
      });
      let isFirstOperation = false;
      let oid = operationBranchRef;
      while (oid && !isFirstOperation) {
        const commit = await import_isomorphic_git11.default.readCommit({ fs: nodeFs, dir: gitRoot, oid });
        operations.push({
          oid: commit.oid,
          parentOids: commit.commit.parent,
          message: commit.commit.message
        });
        oid = commit.commit.parent && commit.commit.parent.length > 0 ? commit.commit.parent[0] : null;
        if (commit.commit.parent.length === 2 && commit.commit.parent[0] === commit.commit.parent[1]) {
          isFirstOperation = true;
        }
      }
    }
    const content = Buffer.from(JSON.stringify(operations, null, 2), "utf-8");
    return {
      type: "file",
      content,
      mode: 420,
      size: content.length
    };
  }, "getFile"),
  rename: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "rename"),
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/operations/getThreadName.ts
var import_isomorphic_git12 = __toESM(require_isomorphic_git(), 1);

// src/compositeFs/subsystems/git/virtualFiles/operations/nameEncoding.ts
var INVALID_CHARS = /* @__PURE__ */ new Set([" ", "~", "^", ":", "?", "*", "[", "\\"]);
var INVALID_SEQ = [
  /^\/|\/$/,
  // leading or trailing slash
  /\/\//,
  // double slash
  /\.$/,
  // trailing dot
  /\.lock$/,
  // trailing .lock
  /^@$/,
  // single @
  /@\{/
  // @{ sequence
];
var EN_SPACE = "\u2002";
function isValidChar(ch) {
  const code = ch.codePointAt(0);
  if (code >= 0 && code <= 31 || code === 127) return false;
  if (INVALID_CHARS.has(ch)) return false;
  return true;
}
__name(isValidChar, "isValidChar");
function encodeName(text) {
  let encoded = "";
  for (const ch of text) {
    if (ch === " ") {
      encoded += EN_SPACE;
    } else if (!isValidChar(ch)) {
      encoded += "%" + ch.codePointAt(0);
    } else {
      encoded += ch;
    }
  }
  for (const seq of INVALID_SEQ) {
    if (seq.test(encoded)) {
      return Array.from(encoded).map((c) => isValidChar(c) ? c : "%" + c.codePointAt(0)).join("");
    }
  }
  return encoded;
}
__name(encodeName, "encodeName");
function decodeName(branch) {
  return branch.replace(/%(\d+)/g, (_, dec) => String.fromCodePoint(parseInt(dec, 10))).replace(new RegExp(EN_SPACE, "g"), " ");
}
__name(decodeName, "decodeName");

// src/compositeFs/subsystems/git/virtualFiles/operations/getThreadName.ts
var getThreadName = {
  type: "getThreadName",
  getStats: /* @__PURE__ */ __name(async (args) => {
    const { gitRoot, nodeFs, pathParams } = args;
    let headCommit;
    try {
      headCommit = await import_isomorphic_git12.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${pathParams.branchName}`
      });
    } catch {
      throw new Error(
        `Base Branch ${pathParams.branchName} for operations does not exis`
      );
    }
    let operationBranchName = await resolveOperationBranchName(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    let hasOperations = false;
    if (operationBranchName) {
      try {
        headCommit = await import_isomorphic_git12.default.resolveRef({
          fs: nodeFs,
          dir: gitRoot,
          ref: operationBranchName
        });
        hasOperations = true;
      } catch {
        try {
          headCommit = await import_isomorphic_git12.default.resolveRef({
            fs: nodeFs,
            dir: gitRoot,
            ref: `refs/heads/${operationBranchName}`
          });
          hasOperations = true;
        } catch {
        }
      }
    }
    const commit = await import_isomorphic_git12.default.readCommit({
      fs: nodeFs,
      dir: gitRoot,
      oid: headCommit
    });
    const { commit: commitObj } = commit;
    const commitTimeMs = commitObj.committer.timestamp * 1e3;
    try {
      return {
        mode: 420,
        size: 40,
        // sha length
        atimeMs: commitTimeMs,
        mtimeMs: commitTimeMs,
        ctimeMs: commitTimeMs,
        birthtimeMs: commitTimeMs,
        atime: new Date(commitTimeMs),
        mtime: new Date(commitTimeMs),
        ctime: new Date(commitTimeMs),
        birthtime: new Date(commitTimeMs),
        // hardcoded to epoch as Date object
        isFile: /* @__PURE__ */ __name(() => true, "isFile"),
        isDirectory: /* @__PURE__ */ __name(() => false, "isDirectory"),
        isSymbolicLink: /* @__PURE__ */ __name(() => false, "isSymbolicLink"),
        isBlockDevice: /* @__PURE__ */ __name(() => false, "isBlockDevice"),
        isCharacterDevice: /* @__PURE__ */ __name(() => false, "isCharacterDevice"),
        isSocket: /* @__PURE__ */ __name(() => false, "isSocket"),
        isFIFO: /* @__PURE__ */ __name(() => false, "isFIFO"),
        isFileSync: /* @__PURE__ */ __name(() => true, "isFileSync"),
        isDirectorySync: /* @__PURE__ */ __name(() => false, "isDirectorySync"),
        dev: 0,
        ino: 0,
        nlink: 1,
        uid: 0,
        gid: 0,
        rdev: 0,
        blksize: 4096,
        blocks: 0
      };
    } catch (err) {
      throw new Error(
        `ENOENT: no such file or directory, stat operationHistory`
      );
    }
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async (args) => {
    const { gitRoot, nodeFs, pathParams } = args;
    let operationBranchName = await resolveOperationBranchName(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    let operationName = void 0;
    if (operationBranchName) {
      const prefix = "legit/";
      const postfix = `__${pathParams.branchName}-operation`;
      if (operationBranchName.startsWith(prefix) && operationBranchName.endsWith(postfix)) {
        operationName = operationBranchName.slice(
          prefix.length,
          operationBranchName.length - postfix.length
        );
      } else {
        operationName = operationBranchName;
      }
      return {
        type: "file",
        content: Buffer.from(decodeName(operationName)),
        mode: 420,
        size: operationName.length
      };
    }
    return {
      type: "file",
      content: Buffer.from(""),
      mode: 420,
      size: 0
    };
  }, "getFile"),
  writeFile: /* @__PURE__ */ __name(async ({
    filePath,
    gitRoot,
    nodeFs,
    content,
    cacheFs,
    pathParams
  }) => {
    if (pathParams.branchName === void 0) {
      throw new Error("branchName should be in pathParams");
    }
    let operationBranchName = await resolveOperationBranchName(
      nodeFs,
      gitRoot,
      pathParams.branchName
    );
    if (operationBranchName) {
      const newOperationBranchName = `legit/${encodeName(content.toString())}__${pathParams.branchName}-operation`;
      await import_isomorphic_git12.default.renameBranch({
        fs: nodeFs,
        dir: gitRoot,
        oldref: operationBranchName,
        ref: newOperationBranchName
      });
      operationBranchName = newOperationBranchName;
    }
  }, "writeFile"),
  rename: /* @__PURE__ */ __name(async function({
    filePath,
    newPath,
    gitRoot,
    nodeFs,
    pathParams,
    newPathParams
  }) {
    throw new Error("not implemented");
  }, "rename"),
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/virtualFiles/gitBranchHistory.ts
var import_isomorphic_git13 = __toESM(require_isomorphic_git(), 1);
var gitBranchHistory = {
  type: "gitBranchHistory",
  getStats: /* @__PURE__ */ __name(async ({ gitRoot, nodeFs, pathParams }) => {
    if (pathParams.branchName === void 0) {
      throw new Error("branchName should be in pathParams");
    }
    let headCommit;
    try {
      headCommit = await import_isomorphic_git13.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: pathParams.branchName
      });
    } catch {
      headCommit = await import_isomorphic_git13.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${pathParams.branchName}`
      });
    }
    const commit = await import_isomorphic_git13.default.readCommit({
      fs: nodeFs,
      dir: gitRoot,
      oid: headCommit
    });
    const { commit: commitObj } = commit;
    const commitTimeMs = commitObj.committer.timestamp * 1e3;
    return {
      mode: 420,
      size: 1e4,
      isFile: /* @__PURE__ */ __name(() => true, "isFile"),
      isDirectory: /* @__PURE__ */ __name(() => false, "isDirectory"),
      isSymbolicLink: /* @__PURE__ */ __name(() => false, "isSymbolicLink"),
      isBlockDevice: /* @__PURE__ */ __name(() => false, "isBlockDevice"),
      isCharacterDevice: /* @__PURE__ */ __name(() => false, "isCharacterDevice"),
      isSocket: /* @__PURE__ */ __name(() => false, "isSocket"),
      isFIFO: /* @__PURE__ */ __name(() => false, "isFIFO"),
      isFileSync: /* @__PURE__ */ __name(() => true, "isFileSync"),
      isDirectorySync: /* @__PURE__ */ __name(() => false, "isDirectorySync"),
      dev: 0,
      ino: 0,
      nlink: 1,
      uid: 0,
      gid: 0,
      rdev: 0,
      blksize: 4096,
      blocks: Math.ceil(40 / 4096),
      atimeMs: commitTimeMs,
      mtimeMs: commitTimeMs,
      ctimeMs: commitTimeMs,
      birthtimeMs: commitTimeMs,
      atime: new Date(commitTimeMs),
      mtime: new Date(commitTimeMs),
      ctime: new Date(commitTimeMs),
      birthtime: new Date(commitTimeMs)
    };
  }, "getStats"),
  getFile: /* @__PURE__ */ __name(async (args) => {
    const { gitRoot, nodeFs, pathParams } = args;
    let branchName = pathParams.branchName;
    const commits = [];
    if (branchName) {
      const operationBranchRef = await import_isomorphic_git13.default.resolveRef({
        fs: nodeFs,
        dir: gitRoot,
        ref: `refs/heads/${branchName}`
      });
      let isFirstOperation = false;
      let oid = operationBranchRef;
      while (oid && !isFirstOperation) {
        const commit = await import_isomorphic_git13.default.readCommit({ fs: nodeFs, dir: gitRoot, oid });
        commits.push({
          oid: commit.oid,
          ...commit.commit
        });
        oid = commit.commit.parent[0];
      }
    }
    const content = Buffer.from(JSON.stringify(commits, null, 2), "utf-8");
    return {
      type: "file",
      content,
      mode: 420,
      size: content.length
    };
  }, "getFile"),
  rename: /* @__PURE__ */ __name(async (args) => {
    throw new Error("not implemented");
  }, "rename"),
  mkdir: /* @__PURE__ */ __name(async function(args) {
    throw new Error("not implemented");
  }, "mkdir")
};

// src/compositeFs/subsystems/git/GitSubFs.ts
var _GitSubFs = class _GitSubFs extends BaseCompositeSubFs {
  constructor({
    parentFs,
    gitRoot,
    virtualFiles = allGitVirtualFiles
  }) {
    super({ parentFs, gitRoot });
    __publicField(this, "memFs");
    __publicField(this, "openFh", {});
    __publicField(this, "virtualFiles");
    __publicField(this, "legitFileNames");
    this.gitRoot = gitRoot;
    this.memFs = (0, import_memfs4.createFsFromVolume)(new import_memfs4.Volume());
    this.virtualFiles = virtualFiles;
    this.legitFileNames = ["branches", "commits"];
  }
  async responsible(filePath) {
    return this.isLegitPath(filePath);
  }
  isLegitPath(path6) {
    return path6.includes(`/${_GitSubFs.LEGIT_DIR}/`) || path6.includes(`/${_GitSubFs.LEGIT_DIR}`);
  }
  getRouteHandler(filePath) {
    const firstLegitIndex = filePath.indexOf(`/${_GitSubFs.LEGIT_DIR}`);
    if (firstLegitIndex === -1) {
      throw new Error("Not a legit path");
    }
    const filePathWithoutLegit = filePath.slice(firstLegitIndex + 1);
    return _GitSubFs.pathRouter.match(filePathWithoutLegit);
  }
  /**
   * Opens a virtual file from the Git-based virtual file system.
   *
   * This method retrieves a virtual file descriptor for the given `filePath`, checks if the file is writable
   * based on its type and the provided `flags`, and ensures that write operations are only allowed for
   * certain file types (e.g., "branch-file", "branch-head", "branch-tip"). It then loads the file's content
   * into the in-memory file system (`memFs`), ensures parent directories exist, and finally opens the file,
   * returning a `CompositFsFileHandle` for further operations.
   *
   * @param filePath - The path to the virtual file to open.
   * @param flags - The file system flags indicating the desired open mode (e.g., "r" for read, "w" for write, "a" for append, "x" for exclusive creation).
   *   - "r": Open file for reading. An exception occurs if the file does not exist.
   *   - "w": Open file for writing. The file is created (if it does not exist) or truncated (if it exists).
   *   - "a": Open file for appending. The file is created if it does not exist.
   *   - "x": Exclusive flag. Used with "w" or "a" to fail if the file exists.
   *   - Combinations like "wx", "ax", etc., are also supported.
   * @param mode - Optional file mode (permission and sticky bits) to use if creating a file.
   * @returns A promise that resolves to a `CompositFsFileHandle` for the opened file.
   * @throws If the file is not a virtual legit file, if write operations are not allowed for the file type,
   *         or if the file does not exist.
   */
  async open(filePath, flags, mode) {
    const parsed = this.getRouteHandler(filePath);
    if (!parsed) throw new Error("Not a virtual legit file");
    const isWritable = parsed?.handler.writeFile !== void 0;
    if (!isWritable && (flags.includes("w") || flags.includes("a"))) {
      throw new Error(
        `Write operations not allowed for ${parsed?.handler.type}`
      );
    }
    if (flags.includes("x") && parsed?.handler.type !== "gitBranchFileVirtualFile") {
      throw new Error(
        `Exclusive operations not allowed for ${parsed?.handler.type}`
      );
    }
    const fileFromGit = await parsed.handler.getFile({
      cacheFs: this.memFs,
      filePath,
      fs: this.compositFs,
      gitRoot: this.gitRoot,
      nodeFs: this.compositFs,
      pathParams: parsed.params
    });
    if (flags.includes("x")) {
      for (const fh2 of Object.values(this.openFh)) {
        if (fh2.path === filePath) {
          throw Object.assign(
            new Error(`EEXIST: file already exists, open '${filePath}'`),
            { code: "EEXIST", errno: -17, syscall: "open", path: filePath }
          );
        }
      }
      if (fileFromGit !== void 0) {
        throw Object.assign(
          new Error(`EEXIST: file already exists, open '${filePath}'`),
          { code: "EEXIST", errno: -17, syscall: "open", path: filePath }
        );
      }
    }
    if (fileFromGit && flags.includes("x")) {
      throw new Error("file existed - openend with x flag");
    }
    if (!fileFromGit && !(flags.includes("w") || flags.includes("a"))) {
      throw new Error(`ENOENT: no such file or directory, open '${filePath}'`);
    }
    const dir = path5.dirname(filePath);
    await this.memFs.promises.mkdir(dir, { recursive: true });
    if (fileFromGit === void 0 && !flags.includes("x") || fileFromGit && fileFromGit.type === "file") {
      try {
        const access = await this.memFs.promises.access(filePath);
      } catch (err) {
        await this.memFs.promises.writeFile(
          filePath,
          ""
          // we start with an empty string and use the memfs file only as placeholder
        );
      }
    }
    const fh = await this.memFs.promises.open(filePath, flags, mode);
    const fd = fh.fd;
    const filehandle = new CompositFsFileHandle({
      fs: this,
      subFsFileDescriptor: fd,
      parentFsFileDescriptors: []
    });
    this.openFh[fd] = {
      path: filePath,
      mode: flags,
      fh,
      // NOTE consider using empty content sha instead of undefined
      openSha: fileFromGit?.oid,
      readSha: void 0,
      unflushed: []
    };
    if (flags.includes("x") || flags.includes("w")) {
      this.openFh[fd].unflushed.push({
        length: 0,
        start: 0
      });
    }
    return filehandle;
  }
  async mkdir(path6, options) {
    const pathStr = path6.toString();
    const branchFileVf = this.getRouteHandler(pathStr);
    const optionsToPass = options ? { options } : {};
    try {
      await branchFileVf?.handler.mkdir({
        cacheFs: this.memFs,
        filePath: path6.toString(),
        fs: this.compositFs,
        nodeFs: this.compositFs,
        gitRoot: this.gitRoot,
        pathParams: branchFileVf.params,
        ...optionsToPass
      });
      const optionsToPassToMemfs = typeof options === "object" ? { ...options, recursive: true } : { recursive: true };
      await this.memFs.promises.mkdir(path6, optionsToPassToMemfs);
      const parts = pathStr.split("/");
      let current = "";
      for (let i = 1; i <= parts.length; i++) {
        current = "/" + parts.slice(0, i).join("/");
        try {
          const stats = await this.memFs.promises.stat(current);
          if (stats.isDirectory()) {
            const fh = await this.memFs.promises.open(current, "r");
            this.openFh[fh.fd] = {
              path: current,
              mode: "r",
              fh,
              openSha: void 0,
              readSha: void 0,
              unflushed: []
            };
          }
        } catch {
        }
      }
    } catch (e) {
      throw e;
    }
  }
  async access(path6, mode) {
    await this.stat(path6);
  }
  async futimes(fh, atime, mtime) {
    const openFh = this.openFh[fh.subFsFileDescriptor];
    if (!openFh) {
      throw new Error("Invalid file handle");
    }
    return await openFh.fh.utimes(atime, mtime);
  }
  async fstat(fh, options) {
    const openFh = this.openFh[fh.subFsFileDescriptor];
    if (!openFh) {
      throw new Error("Invalid file handle");
    }
    return this.stat(openFh.path, options);
  }
  async ftruncate(fh, len) {
    const openFh = this.openFh[fh.subFsFileDescriptor];
    if (!openFh) {
      throw new Error("Invalid file handle");
    }
    return await openFh.fh.truncate(len);
  }
  async stat(path6, opts) {
    const pathStr = path6.toString();
    const openFhEntry = Object.values(this.openFh).find(
      (fh) => fh.path === pathStr
    );
    if (openFhEntry && openFhEntry.unflushed.length > 0) {
      return await openFhEntry.fh.stat(opts);
    }
    const parsed = this.getRouteHandler(pathStr);
    if (!parsed) {
      throw new Error(`ENOENT: no such file or directory, stat '${pathStr}'`);
    }
    const stats = await parsed.handler.getStats({
      cacheFs: this.memFs,
      filePath: pathStr,
      fs: this.compositFs,
      gitRoot: this.gitRoot,
      nodeFs: this.compositFs,
      pathParams: parsed.params
    });
    return stats;
  }
  async lstat(path6, opts) {
    return this.stat(path6, opts);
  }
  async readdir(path6, options) {
    const pathStr = path6.toString();
    if (!this.isLegitPath(pathStr)) {
      return [".legit"];
    }
    const parsed = this.getRouteHandler(pathStr);
    if (!parsed) {
      throw new Error(
        `ENOENT: no such file or directory, scandir '${pathStr}'`
      );
    }
    const result = await parsed?.handler.getFile({
      cacheFs: this.memFs,
      filePath: pathStr,
      fs: this.compositFs,
      gitRoot: this.gitRoot,
      nodeFs: this.compositFs,
      pathParams: parsed.params
    });
    if (result) {
      if (result.type !== "directory") {
        throw new Error("not a folder");
      }
      const siblings = parsed?.staticSiblings ?? [];
      let entries = result.content;
      if (entries && !Array.isArray(result.content)) {
        entries = JSON.parse(result.content);
      }
      const allFolders = Array.from(/* @__PURE__ */ new Set([...entries, ...siblings])).sort(
        (a, b) => a.localeCompare(b, void 0, { numeric: true, sensitivity: "base" })
      );
      return allFolders;
    }
    return [];
  }
  // write not implemented - we do this when we implement branches
  async read(fh, buffer, offset, length, position) {
    const subFsFd = fh.subFsFileDescriptor;
    const openFh = this.openFh[subFsFd];
    if (!openFh) {
      throw new Error("Invalid file handle");
    }
    if (openFh.unflushed.length === 0) {
      const parsed = this.getRouteHandler(openFh.path);
      const fileFromGit = await parsed.handler.getFile({
        cacheFs: this.memFs,
        filePath: openFh.path,
        fs: this.compositFs,
        gitRoot: this.gitRoot,
        nodeFs: this.compositFs,
        pathParams: parsed?.params
      });
      if (!fileFromGit?.content) {
        throw new Error("couldnt access content");
      }
      if (fileFromGit.type !== "file") {
        throw new Error("not a file");
      }
      const contentBuffer = typeof fileFromGit.content === "string" ? Buffer.from(fileFromGit.content) : fileFromGit.content;
      const start = typeof position === "number" ? position : 0;
      const end = Math.min(start + length, contentBuffer.length);
      const bytesToRead = Math.max(0, end - start);
      contentBuffer.copy(buffer, offset, start, start + bytesToRead);
      return { bytesRead: bytesToRead, buffer };
    }
    return await openFh.fh.read(buffer, offset, length, position);
  }
  /**
   *
   * Writes (parts) of a buffer to a specific position in the file
   *
   * - a write leads to a new commit and on flush since the point in time a flush may occur may vary a read operation may
   *  not see changed done on the read lays.
   *
   *
   * @param fh
   * @param buffer
   * @param offset
   * @param length
   * @param position
   * @returns
   */
  async write(fh, buffer, offset, length, position) {
    const openFh = this.openFh[fh.subFsFileDescriptor];
    if (!openFh) {
      throw new Error("Invalid file handle");
    }
    const flags = openFh.mode;
    if (!flags.includes("w") && !flags.includes("a") && !flags.includes("+")) {
      throw Object.assign(new Error(`EBADF: bad file descriptor, write`), {
        code: "EBADF",
        errno: -9,
        syscall: "write"
      });
    }
    if (openFh.unflushed.length === 0) {
      const parsed = this.getRouteHandler(openFh.path);
      const fileFromGit = await parsed.handler.getFile({
        cacheFs: this.memFs,
        filePath: openFh.path,
        fs: this.compositFs,
        gitRoot: this.gitRoot,
        nodeFs: this.compositFs,
        pathParams: parsed.params
      });
      if (fileFromGit && fileFromGit.oid) {
        await this.memFs.promises.writeFile(
          openFh.path,
          fileFromGit.content
        );
        openFh.readSha = fileFromGit.oid;
      }
    }
    const result = await openFh.fh.write(buffer, offset, length, position);
    const setOffset = offset ?? 0;
    const startPos = position ?? 0;
    openFh.unflushed.push({
      start: startPos,
      length: length ? length : buffer.byteLength - setOffset + startPos
    });
    return result;
  }
  async close(fh) {
    const subFsFd = fh.subFsFileDescriptor;
    const openFh = this.openFh[subFsFd];
    if (!openFh) {
      throw new Error("Invalid file handle");
    }
    await this.dataSync(fh);
    delete this.openFh[subFsFd];
  }
  async dataSync(fh) {
    const subFsFd = fh.subFsFileDescriptor;
    const openFh = this.openFh[subFsFd];
    if (!openFh) {
      throw new Error("Invalid file handle");
    }
    if (openFh.unflushed.length > 0) {
      const pathHandler = this.getRouteHandler(openFh.path);
      if (pathHandler && pathHandler.handler.writeFile) {
        const content = await this.memFs.promises.readFile(openFh.path);
        await pathHandler.handler.writeFile({
          cacheFs: this.memFs,
          filePath: openFh.path,
          fs: this.compositFs,
          gitRoot: this.gitRoot,
          nodeFs: this.compositFs,
          content,
          pathParams: pathHandler.params
        });
      }
      openFh.unflushed = [];
      await this.memFs.promises.writeFile(openFh.path, "");
    }
  }
  async readFile(path6, options) {
    const pathStr = typeof path6 === "string" ? path6 : Buffer.isBuffer(path6) ? path6.toString() : path6.fd ? `FileHandle(${path6.fd})` : path6.toString();
    let encoding = null;
    if (typeof options === "string") {
      encoding = options;
    } else if (options && typeof options === "object") {
      if (options.encoding) encoding = options.encoding;
    }
    const fh = await this.open(pathStr, "r");
    try {
      const stats = await this.fstat(fh);
      const size = stats.size;
      const buffer = Buffer.alloc(size);
      await this.read(fh, buffer, 0, size, 0);
      await this.close(fh);
      if (encoding) {
        return buffer.toString(encoding);
      }
      return buffer;
    } catch (error) {
      try {
        await this.close(fh);
      } catch (closeError) {
      }
      throw error;
    }
  }
  async writeFile(path6, data, options) {
    let flags = "w";
    let encoding = "utf8";
    let mode;
    if (typeof options === "string") {
      encoding = options;
    } else if (options && typeof options === "object") {
      if (options.flag) flags = String(options.flag);
      if (options.encoding) encoding = options.encoding;
      if (options.mode)
        mode = typeof options.mode === "string" ? parseInt(options.mode, 8) : options.mode;
    }
    const fh = await this.open(path6, flags, mode);
    try {
      let buffer;
      if (typeof data === "string") {
        buffer = Buffer.from(data, encoding);
      } else if (Buffer.isBuffer(data)) {
        buffer = data;
      } else if (data instanceof Uint8Array) {
        buffer = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buffer = Buffer.from(data);
      }
      await this.write(fh, buffer, 0, buffer.length, 0);
    } finally {
      await this.close(fh);
    }
  }
  async rename(oldPath, newPath) {
    const oldPathStr = oldPath.toString();
    const newPathStr = newPath.toString();
    const oldParsed = this.getRouteHandler(oldPathStr);
    const newParsed = this.getRouteHandler(newPathStr);
    if (oldParsed?.handler.type === "gitBranchFileVirtualFile" && newParsed?.handler.type === "gitBranchFileVirtualFile") {
      let newExistsInMemory = true;
      try {
        await this.memFs.promises.access(newPathStr);
      } catch (e) {
        newExistsInMemory = false;
      }
      let newExistsInBranch = true;
      try {
        await this.stat(newPathStr);
      } catch (e) {
        newExistsInBranch = false;
      }
      let oldExistsInBranch = true;
      try {
        await this.stat(oldPathStr);
      } catch (e) {
        oldExistsInBranch = false;
      }
      let oldExistsInMemory = true;
      try {
        await this.memFs.promises.access(oldPathStr);
      } catch (e) {
        oldExistsInMemory = false;
      }
      if (oldExistsInMemory) {
        const targetDir = path5.dirname(newPathStr);
        try {
          await this.memFs.promises.access(targetDir);
        } catch {
          await this.memFs.promises.mkdir(targetDir, { recursive: true });
        }
        await this.memFs.promises.rename(oldPath, newPath);
      }
      const branchFileVf = this.getRouteHandler(oldPathStr);
      if (!branchFileVf) {
        throw new Error("VF not found");
      }
      const result = await branchFileVf.handler.rename({
        cacheFs: this.memFs,
        filePath: oldPathStr,
        fs: this.compositFs,
        gitRoot: this.gitRoot,
        nodeFs: this.compositFs,
        newPath: newPathStr,
        pathParams: branchFileVf?.params ?? {},
        newPathParams: newParsed?.params ?? {}
      });
    } else {
      throw new Error(
        `Unsupported rename operation from ${oldParsed?.handler.type} to ${newParsed?.handler.type}`
      );
    }
  }
  async fchmod(fh, mode) {
  }
  async unlink(path6) {
    const pathStr = path6.toString();
    const parsed = this.getRouteHandler(pathStr);
    if (parsed?.handler.unlink !== void 0) {
      await parsed.handler.unlink({
        cacheFs: this.memFs,
        filePath: pathStr,
        fs: this.compositFs,
        nodeFs: this.compositFs,
        gitRoot: this.gitRoot,
        pathParams: parsed.params
      });
      for (const [fd, fh] of Object.entries(this.openFh)) {
        if (fh.path === pathStr) {
          await fh.fh.close();
          await this.memFs.promises.unlink(pathStr);
          delete this.openFh[Number(fd)];
        }
      }
    } else {
      throw new Error(`Cannot unlink ${parsed?.handler.type} files`);
    }
  }
  fileType() {
    return 10;
  }
};
__name(_GitSubFs, "GitSubFs");
__publicField(_GitSubFs, "LEGIT_DIR", ".legit");
__publicField(_GitSubFs, "pathRouter", new LegitPathRouter({
  ".legit": {
    ".": legitVirtualFile,
    branches: {
      ".": gitBranchesListVirtualFile,
      "[branchName]": {
        ".legit": {
          ".": legitVirtualFile,
          operation: gitBranchOperationVirtualFile,
          head: gitBranchHeadVirtualFile,
          operationHistory: gitBranchOperationsVirtualFile,
          threadName: getThreadName,
          history: gitBranchHistory
        },
        "[[...filePath]]": gitBranchFileVirtualFile
      }
    },
    commits: {
      ".": gitCommitVirtualFolder,
      "[sha_1_1_2]": {
        ".": gitCommitVirtualFolder,
        "[sha1_3__40]": {
          "[[...filePath]]": gitCommitFileVirtualFile
        }
      }
    }
    // TODO add a compare setup
    // compare: {
    //   '[[aWithB]]': {
    //     '.legit': {
    //       'changelist': getChangeList,
    //     }, // gitCompareVirtualFile,
    //     '[...filePath]': gitCompareVirtualFile,
    //   }
    // }
  }
}));
var GitSubFs = _GitSubFs;

// src/legitfs.ts
function createLegitFs(storageFs, gitRoot) {
  const rootFs = new CompositeFs({
    name: "root",
    // the root CompositeFs has no parent - it doesn't propagate up
    parentFs: void 0,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    storageFs,
    gitRoot
  });
  const rootEphemeralFs = new EphemeralSubFs({
    parentFs: rootFs,
    gitRoot,
    ephemeralPatterns: []
  });
  const rootHiddenFs = new HiddenFileSubFs({
    parentFs: rootFs,
    gitRoot,
    hiddenFiles: []
  });
  rootFs.setHiddenFilesSubFs(rootHiddenFs);
  rootFs.setEphemeralFilesSubFs(rootEphemeralFs);
  const userSpaceFs = new CompositeFs({
    name: "git",
    parentFs: rootFs,
    storageFs: void 0,
    gitRoot
  });
  const gitSubFs = new GitSubFs({
    // while the git subfs is a subFs of the userSpaceFs - it operates on the rootFs to be able to read and write the .git folder
    parentFs: rootFs,
    gitRoot
  });
  const gitFsHiddenFs = new HiddenFileSubFs({
    parentFs: userSpaceFs,
    gitRoot,
    hiddenFiles: [".git"]
  });
  const gitFsEphemeralFs = new EphemeralSubFs({
    parentFs: userSpaceFs,
    gitRoot,
    ephemeralPatterns: [
      "**/._*",
      "**/.DS_Store",
      "**/.AppleDouble/",
      "**/.AppleDB",
      "**/.AppleDesktop",
      "**/.Spotlight-V100",
      "**/.TemporaryItems",
      "**/.Trashes",
      "**/.fseventsd",
      "**/.VolumeIcon.icns",
      "**/.ql_disablethumbnails",
      // libre office creates a lock file
      "**/.~lock.*",
      // libre office creates a temp file
      "**/lu[0-9a-zA-Z]*.tmp",
      // legit uses a tmp file as well
      "**/.metaentries.json.tmp"
    ]
  });
  userSpaceFs.addSubFs(gitSubFs);
  userSpaceFs.setHiddenFilesSubFs(gitFsHiddenFs);
  userSpaceFs.setEphemeralFilesSubFs(gitFsEphemeralFs);
  return userSpaceFs;
}
__name(createLegitFs, "createLegitFs");

// src/sync/createGitSyncService.ts
var import_isomorphic_git14 = __toESM(require_isomorphic_git(), 1);

// ../../node_modules/.pnpm/isomorphic-git@1.34.0/node_modules/isomorphic-git/http/node/index.js
var import_simple_get = __toESM(require_simple_get(), 1);
function fromValue(value) {
  let queue = [value];
  return {
    next() {
      return Promise.resolve({ done: queue.length === 0, value: queue.pop() });
    },
    return() {
      queue = [];
      return {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
__name(fromValue, "fromValue");
function getIterator(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]();
  }
  if (iterable[Symbol.iterator]) {
    return iterable[Symbol.iterator]();
  }
  if (iterable.next) {
    return iterable;
  }
  return fromValue(iterable);
}
__name(getIterator, "getIterator");
async function forAwait(iterable, cb) {
  const iter = getIterator(iterable);
  while (true) {
    const { value, done } = await iter.next();
    if (value) await cb(value);
    if (done) break;
  }
  if (iter.return) iter.return();
}
__name(forAwait, "forAwait");
function asyncIteratorToStream(iter) {
  const { PassThrough } = require_readable_browser();
  const stream = new PassThrough();
  setTimeout(async () => {
    await forAwait(iter, (chunk) => stream.write(chunk));
    stream.end();
  }, 1);
  return stream;
}
__name(asyncIteratorToStream, "asyncIteratorToStream");
async function collect(iterable) {
  let size = 0;
  const buffers = [];
  await forAwait(iterable, (value) => {
    buffers.push(value);
    size += value.byteLength;
  });
  const result = new Uint8Array(size);
  let nextIndex = 0;
  for (const buffer of buffers) {
    result.set(buffer, nextIndex);
    nextIndex += buffer.byteLength;
  }
  return result;
}
__name(collect, "collect");
function fromNodeStream(stream) {
  const asyncIterator = Object.getOwnPropertyDescriptor(
    stream,
    Symbol.asyncIterator
  );
  if (asyncIterator && asyncIterator.enumerable) {
    return stream;
  }
  let ended = false;
  const queue = [];
  let defer = {};
  stream.on("data", (chunk) => {
    queue.push(chunk);
    if (defer.resolve) {
      defer.resolve({ value: queue.shift(), done: false });
      defer = {};
    }
  });
  stream.on("error", (err) => {
    if (defer.reject) {
      defer.reject(err);
      defer = {};
    }
  });
  stream.on("end", () => {
    ended = true;
    if (defer.resolve) {
      defer.resolve({ done: true });
      defer = {};
    }
  });
  return {
    next() {
      return new Promise((resolve, reject) => {
        if (queue.length === 0 && ended) {
          return resolve({ done: true });
        } else if (queue.length > 0) {
          return resolve({ value: queue.shift(), done: false });
        } else if (queue.length === 0 && !ended) {
          defer = { resolve, reject };
        }
      });
    },
    return() {
      stream.removeAllListeners();
      if (stream.destroy) stream.destroy();
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
__name(fromNodeStream, "fromNodeStream");
async function request({
  onProgress,
  url,
  method = "GET",
  headers = {},
  agent,
  body
}) {
  if (body && Array.isArray(body)) {
    body = Buffer.from(await collect(body));
  } else if (body) {
    body = asyncIteratorToStream(body);
  }
  return new Promise((resolve, reject) => {
    (0, import_simple_get.default)(
      {
        url,
        method,
        headers,
        agent,
        body
      },
      (err, res) => {
        if (err) return reject(err);
        try {
          const iter = fromNodeStream(res);
          resolve({
            url: res.url,
            method: res.method,
            statusCode: res.statusCode,
            statusMessage: res.statusMessage,
            body: iter,
            headers: res.headers
          });
        } catch (e) {
          reject(e);
        }
      }
    );
  });
}
__name(request, "request");
var index = { request };
var node_default = index;

// src/sync/createGitSyncService.ts
function normalizeRemoteUrl(remoteUrl) {
  const sshPattern = /^git@([^:]+):(.+)$/;
  const match = remoteUrl.match(sshPattern);
  if (match) {
    const host = match[1];
    const path6 = match[2];
    return `https://${host}/${path6}`;
  }
  return remoteUrl;
}
__name(normalizeRemoteUrl, "normalizeRemoteUrl");
var createGitSyncService = /* @__PURE__ */ __name(({
  fs,
  gitRepoPath,
  originPrefix,
  corsProxy,
  user,
  password
}) => {
  let running = false;
  let lastPushedCommit = void 0;
  let remoteUrl = void 0;
  async function pull() {
    let result = await import_isomorphic_git14.default.fetch({
      fs,
      http: node_default,
      dir: gitRepoPath,
      url: remoteUrl,
      corsProxy,
      // we fetch all branches
      // ref,
      //   singleBranch: true,
      onAuth: /* @__PURE__ */ __name(() => ({
        username: user,
        password
      }), "onAuth")
    });
    const remote = "origin";
    const localRefs = await import_isomorphic_git14.default.listBranches({ fs, dir: gitRepoPath });
    let unpushedRefs = [];
    for (const localRef of localRefs) {
      const remoteRef = `${remote}/${localRef}`;
      let localCommit;
      let remoteCommit;
      try {
        localCommit = await import_isomorphic_git14.default.resolveRef({
          fs,
          dir: gitRepoPath,
          ref: localRef
        });
      } catch (e) {
        console.log(`Could not resolve local ref ${localRef}:`, e);
      }
      try {
        remoteCommit = await import_isomorphic_git14.default.resolveRef({
          fs,
          dir: gitRepoPath,
          ref: remoteRef
        });
      } catch (e) {
        remoteCommit = void 0;
      }
      if (localCommit && remoteCommit) {
        if (localCommit === remoteCommit) {
        } else {
          const mergeBase = await import_isomorphic_git14.default.findMergeBase({
            fs,
            dir: gitRepoPath,
            oids: [localCommit, remoteCommit]
          });
          if (mergeBase[0] !== localCommit && mergeBase[0] !== remoteCommit) {
            const mergeResult = await import_isomorphic_git14.default.merge({
              fs,
              dir: gitRepoPath,
              ours: localCommit,
              theirs: remoteCommit,
              fastForwardOnly: false,
              abortOnConflict: false,
              author: {
                name: "Your Name",
                email: "your.email@example.com"
              },
              mergeDriver: /* @__PURE__ */ __name(async ({ branches, contents, path: path6 }) => {
                const [_base, mine, theirs] = contents;
                console.log(`Merging ${branches[0]} with ${branches[1]}...`);
                console.log(`merged:`);
                console.log(contents);
                return {
                  cleanMerge: true,
                  mergedText: theirs === void 0 ? mine : theirs
                };
              }, "mergeDriver")
            });
            await import_isomorphic_git14.default.writeRef({
              fs,
              dir: gitRepoPath,
              ref: `refs/heads/${localRef}`,
              value: mergeResult.oid,
              force: true
            });
          }
          if (mergeBase[0] === localCommit) {
            console.log(
              `branch ${localRef} differs - remote ahaed, not behind`
            );
            await import_isomorphic_git14.default.writeRef({
              fs,
              dir: gitRepoPath,
              ref: `refs/heads/${localRef}`,
              value: remoteCommit,
              force: true
            });
          } else if (mergeBase[0] === remoteCommit) {
            console.log(`branch ${localRef} differs - local ahead, not behind`);
            unpushedRefs.push(localRef);
          } else {
            console.log(`branch ${localRef} differs - both changed`);
            unpushedRefs.push(localRef);
          }
        }
      } else {
      }
    }
    if (unpushedRefs.length === 0) {
      return;
    } else {
      await push(unpushedRefs);
    }
  }
  __name(pull, "pull");
  async function push(branchesToPush) {
    for (const branch of branchesToPush) {
      await import_isomorphic_git14.default.push({
        fs,
        http: node_default,
        dir: gitRepoPath,
        corsProxy,
        url: remoteUrl,
        ref: branch,
        onAuth: /* @__PURE__ */ __name(() => ({
          username: user,
          password
        }), "onAuth")
      });
    }
  }
  __name(push, "push");
  async function monitorChanges() {
    let value = await import_isomorphic_git14.default.getConfig({
      fs,
      dir: gitRepoPath,
      path: "remote.origin.url"
    });
    remoteUrl = normalizeRemoteUrl(value);
    try {
      await pull();
    } catch (err) {
      console.error("Error monitoring changes:", err);
    } finally {
      if (running) {
        setTimeout(monitorChanges, 1e3);
      }
    }
  }
  __name(monitorChanges, "monitorChanges");
  function startPolling() {
    running = true;
    monitorChanges();
  }
  __name(startPolling, "startPolling");
  function stopPolling() {
    running = false;
  }
  __name(stopPolling, "stopPolling");
  return {
    clone: /* @__PURE__ */ __name(async (url) => {
      return import_isomorphic_git14.default.clone({
        fs,
        http: node_default,
        corsProxy,
        dir: gitRepoPath,
        url,
        onAuth: /* @__PURE__ */ __name(() => ({
          username: user,
          password
        }), "onAuth")
      });
    }, "clone"),
    start: /* @__PURE__ */ __name(() => {
      if (!running) {
        startPolling();
        running = true;
      }
    }, "start"),
    stop: /* @__PURE__ */ __name(() => {
      stopPolling();
    }, "stop")
  };
}, "createGitSyncService");

// src/adapter/browser-fs-access.ts
var import_buffer = __toESM(require_buffer(), 1);
function fileHandleToFileSystemFileHandle(handle) {
  const name = handle.name || "untitled";
  return {
    kind: "file",
    name,
    async getFile() {
      const dataStats = await handle.stat();
      const size = dataStats.size;
      console.log("reading data into buffer of size" + size);
      const nodeBuffer = import_buffer.Buffer.alloc(size);
      await handle.read(nodeBuffer, 0, size, 0);
      const buffer = new Uint8Array(
        nodeBuffer.buffer,
        nodeBuffer.byteOffset,
        nodeBuffer.byteLength
      );
      console.log("buffer read", buffer);
      const data = buffer;
      return new File([data], name || "untitled");
    },
    async createWritable() {
      return {
        async write(data) {
          console.log("writing data to handle", handle);
          let buffer;
          if (typeof data === "string") {
            buffer = import_buffer.Buffer.from(data, "utf-8");
          } else if (data instanceof Blob) {
            const arrayBuffer = await data.arrayBuffer();
            buffer = new Uint8Array(arrayBuffer);
          } else if (ArrayBuffer.isView(data)) {
            buffer = new Uint8Array(
              data.buffer,
              data.byteOffset,
              data.byteLength
            );
          } else {
            console.log("data", data);
            throw new Error("Unsupported data type for write");
          }
          await handle.write(buffer);
          await handle.sync();
          console.log("write completed");
        },
        async close() {
          await handle.close();
        }
      };
    }
    // Add other methods as needed
  };
}
__name(fileHandleToFileSystemFileHandle, "fileHandleToFileSystemFileHandle");
async function fileSystemFileHandleToFileWithHandle(handle) {
  const file = await handle.getFile();
  file.handle = handle;
  return file;
}
__name(fileSystemFileHandleToFileWithHandle, "fileSystemFileHandleToFileWithHandle");
async function getLegitFsAccess(legitFs) {
  return {
    openFile: /* @__PURE__ */ __name(async (filePath) => {
      const handle = await legitFs.promises.open(filePath, "w");
      handle.name = filePath;
      return await fileSystemFileHandleToFileWithHandle(
        fileHandleToFileSystemFileHandle(handle)
      );
    }, "openFile"),
    fileSave: /* @__PURE__ */ __name(async (blobOrPromiseBlobOrResponse, options, existingHandle, throwIfExistingHandleNotGood, filePickerShown) => {
      if (!existingHandle) {
        const fileName = window.prompt(
          "Save as",
          options?.fileName ?? "untitled"
        );
        console.log("result of prompt", fileName);
        if (!fileName) {
          throw new Error("no file choosen");
        }
        try {
          const legitFileHandle = await legitFs.promises.open(
            `${fileName}`,
            "w"
          );
          existingHandle = fileHandleToFileSystemFileHandle(legitFileHandle);
        } catch (err) {
          console.error("Failed to open file in legitFs", err);
          throw new Error("Failed to open file in legitFs");
        }
      } else {
        console.log("using existing handle", existingHandle);
      }
      const blob = blobOrPromiseBlobOrResponse instanceof Blob ? blobOrPromiseBlobOrResponse : await blobOrPromiseBlobOrResponse;
      const writable = await existingHandle.createWritable();
      await writable.write(blob);
      return existingHandle;
    }, "fileSave")
  };
}
__name(getLegitFsAccess, "getLegitFsAccess");
export {
  CompositeFs,
  EphemeralSubFs,
  GitSubFs,
  HiddenFileSubFs,
  PassThroughSubFs,
  createGitSyncService,
  createLegitFs,
  getLegitFsAccess,
  gitBranchOperationsVirtualFile
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

crc-32/crc32.js:
  (*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com *)

simple-concat/index.js:
  (*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

simple-get/index.js:
  (*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=legit-sdk.js.map
